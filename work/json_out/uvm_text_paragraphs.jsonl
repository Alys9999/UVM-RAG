{"type": "text", "page_from": 1, "page_to": 1, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=1", "section_title": "UVM Class 1.2 Reference", "content": "Universal Verification Methodology (UVM) 1.2 Class Reference"}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Copyright© 2011 - 2014 Accellera Systems Initiative (Accellera). All rights reserved. Accellera Systems Initiative Inc., 1370 Trancas Street #163, Napa, CA 94558, USA."}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Accellera Systems Initiative (Accellera) Standards documents are developed within Accellera and the Technical Committees of Accellera. Accellera develops its standards through a consensus development process, approved by its members and board of directors, which brings together volunteers representing varied viewpoints and interests to achieve the final product. Volunteers are not necessarily members of Accellera and serve without compensation. While Accellera administers the process and establishes rules to promote fairness in the consensus development process, Accellera does not independently evaluate, test, or verify the accuracy of any of the information contained in its standards."}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Use of an Accellera Standard is wholly voluntary. Accellera disclaims liability for any personal injury, property or other damage, of any nature whatsoever, whether special, indirect, consequential, or compensatory, directly or indirectly resulting from the publication, use of, or reliance upon this, or any other Accellera Standard document."}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Accellera does not warrant or represent the accuracy or content of the material contained herein, and expressly disclaims any express or implied warranty, including any implied warranty of merchantability or suitability for a specific purpose, or that the use of the material contained herein is free from patent infringement. Accellera Standards documents are supplied “AS IS.”"}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "The existence of an Accellera Standard does not imply that there are no other ways to produce, test, measure, purchase, market, or provide other goods and services related to the scope of an Accellera Standard. Furthermore, the viewpoint expressed at the time a standard is approved and issued is subject to change due to developments in the state of the art and comments received from users of the standard. Every Accellera Standard is subjected to review periodically for revision and update. Users are cautioned to check to determine that they have the latest edition of any Accellera Standard."}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "In publishing and making this document available, Accellera is not suggesting or rendering professional or other services for, or on behalf of, any person or entity. Nor is Accellera undertaking to perform any duty owed by any other person or entity to another. Any person utilizing this, and any other Accellera Standards document, should rely upon the advice of a competent professional in determining the exercise of reasonable care in any given circumstances."}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Interpretations: Occasionally questions may arise regarding the meaning of portions of standards as they relate to specific applications. When the need for interpretations is brought to the attention of Accellera, Accellera will initiate action to prepare appropriate responses. Since Accellera Standards represent a consensus of concerned interests, it is important to ensure that any interpretation has also received the concurrence of a balance of interests. For this reason, Accellera and the members of its Technical Committees are not able to provide an instant response to interpretation requests except in those cases where the matter has previously received formal consideration."}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Comments for revision of Accellera Standards are welcome from any interested party, regardless of membership affiliation with Accellera. Suggestions for changes in documents should be in the form of a proposed change of text, together with appropriate supporting comments. Comments on standards and requests for interpretations should be addressed to:"}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Accellera Systems Initiative Inc. 1370 Trancas Street #163 Napa, CA 94558 USA"}
{"type": "text", "page_from": 2, "page_to": 2, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=2", "section_title": "UVM Class 1.2 Reference", "content": "Note: Attention is called to the possibility that implementation of this standard may require use of subject matter covered by patent rights. By publication of this standard, no position is taken with respect to the existence or validity of any patent rights in connection therewith. Accellera shall not be responsible for identifying patents for which a license may be required by an Accellera standard or for conducting inquiries into the legal validity or scope of those patents that are brought to its attention."}
{"type": "text", "page_from": 3, "page_to": 3, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=3", "section_title": "UVM Class 1.2 Reference", "content": "Accellera is the sole entity that may authorize the use of Accellera-owned certification marks and/or trademarks to indicate compliance with the materials set forth herein."}
{"type": "text", "page_from": 3, "page_to": 3, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=3", "section_title": "UVM Class 1.2 Reference", "content": "Authorization to photocopy portions of any individual standard for internal or personal use must be granted by Accellera, provided that permission is obtained from and any required fee is paid to Accellera. To arrange for authorization please contact Lynn Bannister, Accellera, 1370 Trancas Street #163, Napa, CA 94558, phone (707) 251-9977, e-mail lynn@accellera.org. Permission to photocopy portions of any individual standard for educational classroom use can also be obtained from Accellera."}
{"type": "text", "page_from": 3, "page_to": 3, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=3", "section_title": "UVM Class 1.2 Reference", "content": "Suggestions for improvements to the UVM 1.2 Class Reference are welcome. They should be sent to the UVM email reflector"}
{"type": "text", "page_from": 3, "page_to": 3, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=3", "section_title": "UVM Class 1.2 Reference", "content": "uvm-wg@lists.accellera.org"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Scope . 1.2 Purpose .", "header_path": ["1", "1"], "chapter": "1", "section": "1.1", "content": "1.1 Scope . 1.2 Purpose ."}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "2. Normative References."}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "3. Definitions, Acronyms, and Abbreviations.."}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Definitions 2 3.2 Acronyms and Abbreviations .", "header_path": ["3", "1"], "chapter": "3", "section": "3.1", "content": "3.1 Definitions 2 3.2 Acronyms and Abbreviations ."}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "4. Classes and Utilities ."}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "5. Core Base Classes .. .8"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Miscellaneous Structures . 9 5.2 uvm_object . . 11 5.3 uvm_transaction . . 26 5.4 uvm_root. . 34 5.5 Port Base Classes 38", "header_path": ["5", "1"], "chapter": "5", "section": "5.1", "content": "5.1 Miscellaneous Structures . 9 5.2 uvm_object . . 11 5.3 uvm_transaction . . 26 5.4 uvm_root. . 34 5.5 Port Base Classes 38"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "6. Reporting Classes. ..46"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "uvm_report_message 47 6.2 uvm_report_object . . 59 6.3 uvm_report_handler . 68 6.4 uvm_report_server . . 70 6.5 uvm_report_catcher 81", "header_path": ["6", "1"], "chapter": "6", "section": "6.1", "content": "6.1 uvm_report_message 47 6.2 uvm_report_object . . 59 6.3 uvm_report_handler . 68 6.4 uvm_report_server . . 70 6.5 uvm_report_catcher 81"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "7. Recording Classes . .89"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "uvm_tr_database. . . 90 7.2 uvm_tr_stream . 96", "header_path": ["7", "1"], "chapter": "7", "section": "7.1", "content": "7.1 uvm_tr_database. . . 90 7.2 uvm_tr_stream . 96"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "8. Factory Classes . .103"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "uvm_\\*_registry. . 104 8.2 uvm_factory 110", "header_path": ["8", "1"], "chapter": "8", "section": "8.1", "content": "8.1 uvm_\\*_registry. . 104 8.2 uvm_factory 110"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "Contents", "content": "9. Phasing Classes . .125"}
{"type": "text", "page_from": 4, "page_to": 4, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=4", "section_title": "uvm_phase . . 127 9.2 uvm_domain . 140 9.3 uvm_bottomup_phase. . 142 9.4 uvm_task_phase . . . 144 9.5 uvm_topdown_phase . . 146 9.6 UVM Common Phases . . . 148 9.7 UVM Run-Time Phases . . 159 9.8 User-Defined Phases. . . 172", "header_path": ["9", "1"], "chapter": "9", "section": "9.1", "content": "9.1 uvm_phase . . 127 9.2 uvm_domain . 140 9.3 uvm_bottomup_phase. . 142 9.4 uvm_task_phase . . . 144 9.5 uvm_topdown_phase . . 146 9.6 UVM Common Phases . . . 148 9.7 UVM Run-Time Phases . . 159 9.8 User-Defined Phases. . . 172"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "Contents", "content": "10. Configuration and Resource Classes.. .173"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "uvm_resource . 174 10.2 uvm_resource_db 192 10.3 uvm_config_db. . 197", "header_path": ["10", "1"], "chapter": "10", "section": "10.1", "content": "10.1 uvm_resource . 174 10.2 uvm_resource_db 192 10.3 uvm_config_db. . 197"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "Contents", "content": "11. Synchronization Classes . ..202"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "uvm_event . . 203 11.2 uvm_event_callback . . . 208 11.3 uvm_barrier . . 210 11.4 uvm_objection . . 213 11.5 uvm_heartbeat . . 221 11.6 uvm_callback . . 224", "header_path": ["11", "1"], "chapter": "11", "section": "11.1", "content": "11.1 uvm_event . . 203 11.2 uvm_event_callback . . . 208 11.3 uvm_barrier . . 210 11.4 uvm_objection . . 213 11.5 uvm_heartbeat . . 221 11.6 uvm_callback . . 224"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "Contents", "content": "12. Container Classes . ..232"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "uvm_pool . 233 12.2 uvm_queue . 238", "header_path": ["12", "1"], "chapter": "12", "section": "12.1", "content": "12.1 uvm_pool . 233 12.2 uvm_queue . 238"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "Contents", "content": "13. TLM Interfaces . ..241"}
{"type": "text", "page_from": 5, "page_to": 5, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=5", "section_title": "Interfaces . 250 14.2 Exports . . 254 14.3 Ports . . 257 14.4 Imps . . 260 14.5 FIFO . . . 263 14.6 FIFO Base. . . 266 14.7 Channel Classes . . 269 14.8 Sequence Item Pull Ports . . 274 14.9 Sequencer Base. . . 276", "header_path": ["14", "1"], "chapter": "14", "section": "14.1", "content": "14.1 Interfaces . 250 14.2 Exports . . 254 14.3 Ports . . 257 14.4 Imps . . 260 14.5 FIFO . . . 263 14.6 FIFO Base. . . 266 14.7 Channel Classes . . 269 14.8 Sequence Item Pull Ports . . 274 14.9 Sequencer Base. . . 276"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "Interface Masks. . . 284 15.2 Types . . 285 15.3 Generic Payload . . 289 15.4 Socket Base. . . 303 15.5 Sockets . . 308 15.6 Exports . . 315 15.7 Imps . . . . 317 15.8 Ports . . 321 15.9 Temporal Decoupling . . . 323", "header_path": ["15", "1"], "chapter": "15", "section": "15.1", "content": "15.1 Interface Masks. . . 284 15.2 Types . . 285 15.3 Generic Payload . . 289 15.4 Socket Base. . . 303 15.5 Sockets . . 308 15.6 Exports . . 315 15.7 Imps . . . . 317 15.8 Ports . . 321 15.9 Temporal Decoupling . . . 323"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "Contents", "content": "16. Analysis Ports .328"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "Contents", "content": "17. Component Classes . ..331"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "uvm_component . . 332 17.2 uvm_test . . 359 17.3 uvm_env . . 361 17.4 uvm_agent . 362 17.5 uvm_monitor . 364 17.6 uvm_scoreboard . 365 17.7 uvm_driver . . . 366 17.8 uvm_push_driver . . 368 17.9 uvm_random_stimulus . . 370 17.10 uvm_subscriber. . . 372", "header_path": ["17", "1"], "chapter": "17", "section": "17.1", "content": "17.1 uvm_component . . 332 17.2 uvm_test . . 359 17.3 uvm_env . . 361 17.4 uvm_agent . 362 17.5 uvm_monitor . 364 17.6 uvm_scoreboard . 365 17.7 uvm_driver . . . 366 17.8 uvm_push_driver . . 368 17.9 uvm_random_stimulus . . 370 17.10 uvm_subscriber. . . 372"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "Contents", "content": "18. Comparators . .374"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "uvm_in_order_comparator . 375 18.2 uvm_algorithmic_comparator . 378 18.3 uvm_pair. . . 381 18.4 uvm_policies . 384", "header_path": ["18", "1"], "chapter": "18", "section": "18.1", "content": "18.1 uvm_in_order_comparator . 375 18.2 uvm_algorithmic_comparator . 378 18.3 uvm_pair. . . 381 18.4 uvm_policies . 384"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "Contents", "content": "19. Sequencer Classes . .387"}
{"type": "text", "page_from": 6, "page_to": 6, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=6", "section_title": "uvm_sequencer_base . 389 19.2 uvm_sequencer_param_base 397 19.3 uvm_sequencer . . 401 19.4 uvm_push_sequencer . . 404", "header_path": ["19", "1"], "chapter": "19", "section": "19.1", "content": "19.1 uvm_sequencer_base . 389 19.2 uvm_sequencer_param_base 397 19.3 uvm_sequencer . . 401 19.4 uvm_push_sequencer . . 404"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Contents", "content": "20. Sequence Classes . .406"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "uvm_sequence_item . . 407 20.2 uvm_sequence_base . . 413 20.3 uvm_sequence . 428 20.4 uvm_sequence_library . 431", "header_path": ["20", "1"], "chapter": "20", "section": "20.1", "content": "20.1 uvm_sequence_item . . 407 20.2 uvm_sequence_base . . 413 20.3 uvm_sequence . 428 20.4 uvm_sequence_library . 431"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Report Macros . . 437 21.2 Component and Object Macros . . 445 21.3 Sequence-Related Macros . 470 21.4 Callback Macros . 477 21.5 TLM Macros. . . 481 21.6 Register Defines . . 487 21.7 Version Defines . 488", "header_path": ["21", "1"], "chapter": "21", "section": "21.1", "content": "21.1 Report Macros . . 437 21.2 Component and Object Macros . . 445 21.3 Sequence-Related Macros . 470 21.4 Callback Macros . 477 21.5 TLM Macros. . . 481 21.6 Register Defines . . 487 21.7 Version Defines . 488"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Contents", "content": "22. Policy Classes ..491"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "uvm_printer . . 492 22.2 uvm_comparer . . 504 22.3 uvm_recorder . . 508 22.4 uvm_packer . 522 22.5 links . . . 529", "header_path": ["22", "1"], "chapter": "22", "section": "22.1", "content": "22.1 uvm_printer . . 492 22.2 uvm_comparer . . 504 22.3 uvm_recorder . . 508 22.4 uvm_packer . 522 22.5 links . . . 529"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Contents", "content": "23. Data Access Policies . .538"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Set / Get Base . 539 23.2 Simple Lock . . 541 23.3 Get To Lock . . 544 23.4 Set Before Get . 546", "header_path": ["23", "1"], "chapter": "23", "section": "23.1", "content": "23.1 Set / Get Base . 539 23.2 Simple Lock . . 541 23.3 Get To Lock . . 544 23.4 Set Before Get . 546"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Contents", "content": "24. Register Layer .. .549"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Register Layer Overview . 549 24.2 Global Declarations 551", "header_path": ["24", "1"], "chapter": "24", "section": "24.1", "content": "24.1 Register Layer Overview . 549 24.2 Global Declarations 551"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Contents", "content": "25. Register Model.. .557"}
{"type": "text", "page_from": 7, "page_to": 7, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=7", "section_title": "Blocks . . . 557 25.2 Address Maps . . . 573 25.3 Register Files . 584 25.4 Registers . 588", "header_path": ["25", "1"], "chapter": "25", "section": "25.1", "content": "25.1 Blocks . . . 557 25.2 Address Maps . . . 573 25.3 Register Files . 584 25.4 Registers . 588"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "Memories . . 619 25.7 Indirect Registers . 635 25.8 FIFO Registers . . 637 25.9 Virtual Registers . . . 641 25.10 Virtual Fields . 654 25.11 Callbacks . 662 25.12 Memory Allocation Manager . 671", "header_path": ["25", "6"], "chapter": "25", "section": "25.6", "content": "25.6 Memories . . 619 25.7 Indirect Registers . 635 25.8 FIFO Registers . . 637 25.9 Virtual Registers . . . 641 25.10 Virtual Fields . 654 25.11 Callbacks . 662 25.12 Memory Allocation Manager . 671"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "Contents", "content": "26. DUT Integration. .682"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "Generic Register Operation Descriptors. . . 682 26.2 Register Model Adaptor . . 688 26.3 Explicit Register Predictor . . 692 26.4 Register Sequences . . . 695 26.5 Backdoors . . . 704 26.6 HDL Access . . . 708", "header_path": ["26", "1"], "chapter": "26", "section": "26.1", "content": "26.1 Generic Register Operation Descriptors. . . 682 26.2 Register Model Adaptor . . 688 26.3 Explicit Register Predictor . . 692 26.4 Register Sequences . . . 695 26.5 Backdoors . . . 704 26.6 HDL Access . . . 708"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "Contents", "content": "27. Test Sequences . ..711"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "Run All Built-In . 711 27.2 Reset . . . 713 27.3 Register Bit Bash . 715 27.4 Register Access . 718 27.5 Shared Access. . . 722 27.6 Memory Access . . 727 27.7 Memory Walk. . . 730 27.8 HDL Paths Checking Test Sequence . 734", "header_path": ["27", "1"], "chapter": "27", "section": "27.1", "content": "27.1 Run All Built-In . 711 27.2 Reset . . . 713 27.3 Register Bit Bash . 715 27.4 Register Access . 718 27.5 Shared Access. . . 722 27.6 Memory Access . . 727 27.7 Memory Walk. . . 730 27.8 HDL Paths Checking Test Sequence . 734"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "Contents", "content": "28. Command Line Processor (CLP) Class .736"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "CLP Overview . 736 28.2 uvm_cmdline_processor. 737", "header_path": ["28", "1"], "chapter": "28", "section": "28.1", "content": "28.1 CLP Overview . 736 28.2 uvm_cmdline_processor. 737"}
{"type": "text", "page_from": 8, "page_to": 8, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=8", "section_title": "Types and Enumerations . 745 29.2 Globals . . 754 29.3 Core Service . . 759 29.4 Traversal . . 763", "header_path": ["29", "1"], "chapter": "29", "section": "29.1", "content": "29.1 Types and Enumerations . 745 29.2 Globals . . 754 29.3 Core Service . . 759 29.4 Traversal . . 763"}
{"type": "text", "page_from": 9, "page_to": 9, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=9", "section_title": "Contents", "content": "Bibliography.. ..769"}
{"type": "text", "page_from": 10, "page_to": 10, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=10", "section_title": "Purpose", "content": "Verification has evolved into a complex project that often spans internal and external teams, but the discontinuity associated with multiple, incompatible methodologies among those teams has limited productivity. The Universal Verification Methodology (UVM) 1.2 Class Reference addresses verification complexity and interoperability within companies and throughout the electronics industry for both novice and advanced teams while also providing consistency. While UVM is revolutionary, being the first verification methodology to be standardized, it is also evolutionary, as it is built on the Open Verification Methodology (OVM), which combined the Advanced Verification Methodology (AVM) with the Universal Reuse Methodology (URM) and concepts from the e Reuse Methodology (eRM). Furthermore, UVM also infuses concepts and code from the Verification Methodology Manual (VMM), plus the collective experience and knowledge of the $3 0 0 +$ members of the Accellera Universal Verification Methodology Work Group (UVMWG) to help standardize verification methodology."}
{"type": "text", "page_from": 10, "page_to": 10, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=10", "section_title": "Purpose", "content": "The UVM application programming interface (API) defines a standard for the creation, integration, and extension of UVM Verification Components (UVCs) and verification environments that scale from block to system. The UVM 1.2 Class Reference is independent of any specific design processes and is complete for the construction of verification environments. The generator to connect register abstractions, many of which are captured using IPXACT (IEEE Std $1 6 8 5 ^ { \\mathrm { { T M } } }$ ), is not part of the standard, although a register package is."}
{"type": "text", "page_from": 10, "page_to": 10, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=10", "section_title": "Purpose", "content": "The purpose of the UVM 1.2 Class Reference is to enable verification interoperability throughout the electronics ecosystem. To further that goal, a reference implementation will be made available, along with the UVM 1.2 User’s Guide. While these materials are neither required to implement UVM, nor considered part of the standard, they help provide consistency when the UVM 1.2 Class Reference is applied and further enable UVM to achieve its purpose."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "2. Normative References"}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "The following referenced documents are indispensable for the application of this specification (i.e., they must be understood and used, so each referenced document is cited in text and its relationship to this document is explained). For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments or corrigenda) applies."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "IEEE Std ${ 1 8 0 0 } ^ { \\mathrm { { T M } } }$ , IEEE Standard for SystemVerilog Unified Hardware Design, Specification and Verification Language.1, 2"}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "3. Definitions, Acronyms, and Abbreviations"}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "For the purposes of this document, the following terms and definitions apply. The IEEE Standards Dictionary Online should be consulted for terms not defined in this clause.3"}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "agent: An abstract container used to emulate and verify DUT devices; agents encapsulate a driver, sequencer, and monitor."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "blocking: An interface where tasks block execution until they complete. See also: non blocking."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "component: A piece of VIP that provides functionality and interfaces. Also referred to as a transactor."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "consumer: A verification component that receives transactions from another component."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "driver: A component responsible for executing or otherwise processing transactions, usually interacting with the device under test (DUT) to do so."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "environment: The container object that defines the testbench topology."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "export: A transaction level modeling (TLM) interface that provides the implementation of methods used for communication. Used in UVM to connect to a port."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "factory method: A classic software design pattern used to create generic code by deferring, until run time, the exact specification of the object to be created."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "foreign methodology: A verification methodology that is different from the methodology being used for the majority of the verification environment."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "generator: A verification component that provides transactions to another component. Also referred to as a producer."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "monitor: A passive entity that samples DUT signals, but does not drive them."}
{"type": "text", "page_from": 11, "page_to": 11, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=11", "section_title": "Definitions", "content": "non blocking: A call that returns immediately. See also: blocking."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "port: A TLM interface that defines the set of methods used for communication. Used in UVM to connect to an export."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "primary (host) methodology: The methodology that manages the top-level operation of the verification environment and with which the user/integrator is presumably more familiar."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "request: A transaction that provides information to initiate the processing of a particular operation."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "response: A transaction that provides information about the completion or status of a particular operation."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "scoreboard: The mechanism used to dynamically predict the response of the design and check the observed response against the predicted response. Usually refers to the entire dynamic response-checking structure."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "sequence: A UVM object that procedurally defines a set of transactions to be executed and/or controls the execution of other sequences."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "sequencer: An advanced stimulus generator which executes sequences that define the transactions provided to the driver for execution."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "test: Specific customization of an environment to exercise required functionality of the DUT."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "testbench: The structural definition of a set of verification components used to verify a DUT. Also referred to as a verification environment."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "transaction: A class instance that encapsulates information used to communicate between two or more components."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "transactor: See component."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "virtual sequence: A conceptual term for a sequence that controls the execution of sequences on other sequencers."}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "header_path": ["3", "2"], "chapter": "3", "section": "3.2", "content": "3.2 Acronyms and Abbreviations"}
{"type": "text", "page_from": 12, "page_to": 12, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=12", "section_title": "Acronyms and Abbreviations", "content": "application programming interface coverage-driven verification common base class library command line interface device under test device under verification electronic design automation first-in, first-out hardware description language high-level verification language intellectual property"}
{"type": "text", "page_from": 13, "page_to": 13, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=13", "section_title": "Acronyms and Abbreviations", "content": "Open SystemC Initiative transaction level modeling UVM Verification Component Universal Verification Methodology verification intellectual property"}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "4. Classes and Utilities"}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "The UVM Class Library provides the building blocks needed to quickly develop wellconstructed and reusable verification components and test environments in SystemVerilog."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "This UVM Class Reference provides detailed reference information for each user-visible class in the UVM library. For additional information on using UVM, see the UVM User’s Guide located in the top level directory within the UVM kit."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "We divide the UVM classes and utilities into categories pertaining to their role or function. A more detailed overview of each category-- and the classes comprising them-- can be found in the menu at left."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "This category defines a small list of types, variables, functions, and tasks defined in the uvm_pkg scope. These items are accessible from any scope that imports the uvm_pkg. See Types and Enumerations and Globals for details."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "This basic building blocks for all environments are components, which do the actual work, transactions, which convey information between components, and ports, which provide the interfaces used to convey transactions. The UVM’s core base classes provide these building blocks. See Core Base Classes for more information."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "The reporting classes provide a facility for issuing reports (messages) with consistent formatting and configurable side effects, such as logging to a file or exiting simulation. Users can also filter out reports based on their verbosity , unique ID, or severity. See Reporting Classes for more information."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "As the name implies, the UVM factory is used to manufacture (create) UVM objects and components. Users can configure the factory to produce an object of a given type on a global or instance basis. Use of the factory allows dynamically configurable component hierarchies and object substitutions without having to modify their code and without breaking encapsulation. See Factory Classes for details."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "This sections describes the phasing capability providing by UVM. The details can be found in Phasing Overview."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "The Configuration and Resource Classes are a set of classes which provide a configuration database. The configuration database is used to store and retrieve both configuration time and run time properties."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "The UVM provides event and barrier synchronization classes for process synchronization. See Synchronization Classes for more information."}
{"type": "text", "page_from": 14, "page_to": 14, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=14", "section_title": "Classes and Utilities", "content": "The Container Classes are type parameterized data structures which provide queue and pool services. The class based queue and pool types allow for efficient sharing of the data structures compared with their SystemVerilog built-in counterparts."}
{"type": "text", "page_from": 15, "page_to": 15, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=15", "section_title": "Classes and Utilities", "content": "Each of UVM’s policy classes performs a specific task for uvm_object-based objects: printing, comparing, recording, packing, and unpacking. They are implemented separately from uvm_object so that users can plug in different ways to print, compare, etc. without modifying the object class being operated on. The user can simply apply a different printer or compare “policy” to change how an object is printed or compared. See Policy Classes for more information."}
{"type": "text", "page_from": 15, "page_to": 15, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=15", "section_title": "Classes and Utilities", "content": "The UVM TLM library defines several abstract, transaction-level interfaces and the ports and exports that facilitate their use. Each TLM interface consists of one or more methods used to transport data, typically whole transactions (objects) at a time. Component designs that use TLM ports and exports to communicate are inherently more reusable, interoperable, and modular. See TLM Interfaces for details."}
{"type": "text", "page_from": 15, "page_to": 15, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=15", "section_title": "Classes and Utilities", "content": "Components form the foundation of the UVM. They encapsulate behavior of drivers, scoreboards, and other objects in a testbench. The UVM library provides a set of predefined component types, all derived directly or indirectly from uvm_component. See Predefined Component Classes for more information."}
{"type": "text", "page_from": 15, "page_to": 15, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=15", "section_title": "Classes and Utilities", "content": "The sequencer serves as an arbiter for controlling transaction flow from multiple stimulus generators. More specifically, the sequencer controls the flow of uvm_sequence_item-based transactions generated by one or more uvm_sequence #(REQ,RSP)-based sequences. See Sequencer Classes for more information."}
{"type": "text", "page_from": 15, "page_to": 15, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=15", "section_title": "Classes and Utilities", "content": "Sequences encapsulate user-defined procedures that generate multiple uvm_sequence_itembased transactions. Such sequences can be reused, extended, randomized, and combined sequentially and hierarchically in interesting ways to produce realistic stimulus to your DUT. See Sequence Classes for more information."}
{"type": "text", "page_from": 15, "page_to": 15, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=15", "section_title": "Classes and Utilities", "content": "The UVM provides several macros to help increase user productivity. See the set of macro categories in the main menu for a complete list of macros for Reporting, Components, Objects, Sequences, Callbacks, TLM and Registers."}
{"type": "text", "page_from": 15, "page_to": 15, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=15", "section_title": "Classes and Utilities", "content": "The Register abstraction classes, when properly extended, abstract the read/write operations to registers and memories in a design-under"}
{"type": "text", "page_from": 16, "page_to": 16, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=16", "section_title": "Classes and Utilities", "content": "verification. See Register Layer for more information."}
{"type": "text", "page_from": 16, "page_to": 16, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=16", "section_title": "Classes and Utilities", "content": "Command Line Processor"}
{"type": "text", "page_from": 16, "page_to": 16, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=16", "section_title": "Classes and Utilities", "content": "The command line processor provides a general interface to the command line arguments that were provided for the given simulation. The capabilities are detailed in the uvm_cmdline_processor section."}
{"type": "text", "page_from": 16, "page_to": 16, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=16", "section_title": "Classes and Utilities", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 16, "page_to": 16, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=16", "section_title": "Classes and Utilities", "content": "The UVM Class Library provides the building blocks needed to quickly develop well-constructed and reusable verification components and test environments in SystemVerilog."}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "5. Core Base Classes"}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "The UVM library defines a set of base classes and utilities that facilitate the design of modular, scalable, reusable verification environments."}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "The basic building blocks for all environments are components and the transactions they use to communicate. The UVM provides base classes for these, as shown below."}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "uvm_object - All components and transactions derive from uvm_object, which defines an interface of core class-based operations: create, copy, compare, print, sprint, record, etc. It also defines interfaces for instance identification (name, type name, unique id, etc.) and random seeding."}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "uvm_component - The uvm_component class is the root base class for all UVM components. Components are quasi-static objects that exist throughout simulation. This allows them to establish structural hierarchy much like modules and program blocks. Every component is uniquely addressable via a hierarchical path name, e.g. “env1.pci1.master3.driver”. The uvm_component also defines a phased test flow that components follow during the course of simulation. Each phase-- build, connect, run, etc.-- is defined by a callback that is executed in precise order. Finally, the uvm_component also defines configuration, reporting, transaction recording, and factory interfaces."}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "uvm_transaction - The uvm_transaction is the root base class for UVM transactions, which, unlike uvm_components, are transient in nature. It extends uvm_object to include a timing and recording interface. Simple transactions can derive directly from uvm_transaction, while sequence-enabled transactions derive from uvm_sequence_item."}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "uvm_root - The uvm_root class is special uvm_component that serves as the toplevel component for all UVM components, provides phasing control for all UVM components, and other global services."}
{"type": "text", "page_from": 17, "page_to": 17, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=17", "section_title": "Base Classes", "content": "The UVM library defines a set of base classes and utilities that facilitate the design of modular, scalable, reusable verification environments."}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "header_path": ["5", "1"], "chapter": "5", "section": "5.1", "content": "5.1 Miscellaneous Structures"}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "Miscellaneous Structures"}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "The uvm_void class is the base class for all UVM classes."}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "uvm_utils #(TYPE,FIELD) This class contains useful template functions."}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "The uvm_void class is the base class for all UVM classes. It is an abstract class with no data members or functions. It allows for generic containers of objects to be created, similar to a void pointer in the C programming language. User classes derived directly from uvm_void inherit none of the UVM functionality, but such classes may be placed in uvm_void-typed containers along with other UVM objects."}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "The uvm_void class is the base class for all UVM classes."}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "virtual class uvm_void"}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "This class contains useful template functions."}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "uvm_utils #(TYPE,FIEL D)"}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "This class contains useful template functions."}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "class uvm_utils #( type TYPE $=$ int, string FIELD $=$ \"config\" )"}
{"type": "text", "page_from": 18, "page_to": 18, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=18", "section_title": "Miscellaneous Structures", "content": "find_all Recursively finds all component instances of the parameter type TYPE, starting with the component given by start. get_config This method gets the object config of type TYPE associated with"}
{"type": "text", "page_from": 19, "page_to": 19, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=19", "section_title": "Miscellaneous Structures", "content": "Recursively finds all component instances of the parameter type TYPE, starting with the component given by start. Uses uvm_root::find_all."}
{"type": "text", "page_from": 19, "page_to": 19, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=19", "section_title": "Miscellaneous Structures", "content": "static function TYPE get_config( uvm_component comp, bit is_fatal )"}
{"type": "text", "page_from": 19, "page_to": 19, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=19", "section_title": "Miscellaneous Structures", "content": "This method gets the object config of type TYPE associated with component comp. We check for the two kinds of error which may occur with this kind of operation."}
{"type": "text", "page_from": 20, "page_to": 20, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=20", "section_title": "uvm_object", "content": "The uvm_object class is the base class for all UVM data and hierarchical classes. Its primary role is to define a set of methods for such common operations as create, copy, compare, print, and record. Classes deriving from uvm_object must implement the pure virtual methods such as create and get_type_name."}
{"type": "text", "page_from": 20, "page_to": 20, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=20", "section_title": "uvm_object", "content": "The uvm_object class is the base class for all UVM data and hierarchical classes."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "static bit use_uvm_seeding = 1"}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "This bit enables or disables the UVM seeding mechanism. It globally affects the operation of the reseed method."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "When enabled, UVM-based objects are seeded based on their type and full hierarchical name rather than allocation order. This improves random stability for objects whose instance names are unique across each type. The uvm_component class is an example of a type that has a unique instance name."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "function void reseed ()"}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "Calls srandom on the object to reseed the object using the UVM seeding mechanism, which sets the seed based on type name and instance name instead of based on instance position in a thread."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "If the use_uvm_seeding static variable is set to 0, then reseed() does not perform any function."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "virtual function void set_name ( string name"}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "Sets the instance name of this object, overwriting any previously given name."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "virtual function string get_name ()"}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "Returns the name of the object, as provided by the name argument in the new constructor or set_name method."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "virtual function string get_full_name ()"}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "Returns the full hierarchical name of this object. The default implementation is the same as get_name, as uvm_objects do not inherently possess hierarchy."}
{"type": "text", "page_from": 22, "page_to": 22, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=22", "section_title": "uvm_object", "content": "Objects possessing hierarchy, such as uvm_components, override the default implementation. Other objects might be associated with component hierarchy but are not themselves components. For example, uvm_sequence #(REQ,RSP) classes are typically associated with a uvm_sequencer #(REQ,RSP). In this case, it is useful to override get_full_name to return the sequencer’s full name concatenated with the sequence’s name. This provides the sequence a full context, which is useful when debugging."}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "virtual function int get_inst_id ()"}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "Returns the object’s unique, numeric instance identifier."}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "static function int get_inst_count()"}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "Returns the current value of the instance counter, which represents the total number of uvm_object-based objects that have been allocated in simulation. The instance counter is used to form a unique numeric instance identifier."}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "static function uvm_object_wrapper get_type ()"}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "Returns the type-proxy (wrapper) for this object. The uvm_factory’s type-based override and creation methods take arguments of uvm_object_wrapper. This method, if implemented, can be used as convenient means of supplying those arguments."}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "The default implementation of this method produces an error and returns null. To enable use of this method, a user’s subtype must implement a version that returns the subtype’s wrapper."}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "This function is implemented by the \\`uvm_\\*_utils macros, if employed."}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "virtual function uvm_object_wrapper get_object_type ()"}
{"type": "text", "page_from": 23, "page_to": 23, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=23", "section_title": "uvm_object", "content": "Returns the type-proxy (wrapper) for this object. The uvm_factory’s type-based override and creation methods take arguments of uvm_object_wrapper. This method, if implemented, can be used as convenient means of supplying those arguments. This method is the same as the static get_type method, but uses an already allocated object to determine the type-proxy to access (instead of using the static object)."}
{"type": "text", "page_from": 24, "page_to": 24, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=24", "section_title": "uvm_object", "content": "The default implementation of this method does a factory lookup of the proxy using the return value from get_type_name. If the type returned by get_type_name is not registered with the factory, then a null handle is returned."}
{"type": "text", "page_from": 24, "page_to": 24, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=24", "section_title": "uvm_object", "content": "This function is implemented by the \\`uvm_\\*_utils macros, if employed."}
{"type": "text", "page_from": 24, "page_to": 24, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=24", "section_title": "uvm_object", "content": "virtual function string get_type_name ()"}
{"type": "text", "page_from": 24, "page_to": 24, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=24", "section_title": "uvm_object", "content": "This function returns the type name of the object, which is typically the type identifier enclosed in quotes. It is used for various debugging functions in the library, and it is used by the factory for creating objects."}
{"type": "text", "page_from": 24, "page_to": 24, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=24", "section_title": "uvm_object", "content": "This function must be defined in every derived class."}
{"type": "text", "page_from": 24, "page_to": 24, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=24", "section_title": "uvm_object", "content": "A typical implementation is as follows"}
{"type": "text", "page_from": 24, "page_to": 24, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=24", "section_title": "uvm_object", "content": "We define the type_name static variable to enable access to the type name without need of an object of the class, i.e., to enable access via the scope operator, mytype::type_name."}
{"type": "text", "page_from": 25, "page_to": 25, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=25", "section_title": "uvm_object", "content": "indirectly, must implement the create method."}
{"type": "text", "page_from": 25, "page_to": 25, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=25", "section_title": "uvm_object", "content": "A typical implementation is as follows"}
{"type": "text", "page_from": 25, "page_to": 25, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=25", "section_title": "uvm_object", "content": "virtual function uvm_object clone ()"}
{"type": "text", "page_from": 25, "page_to": 25, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=25", "section_title": "uvm_object", "content": "The clone method creates and returns an exact copy of this object."}
{"type": "text", "page_from": 25, "page_to": 25, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=25", "section_title": "uvm_object", "content": "The default implementation calls create followed by copy. As clone is virtual, derived classes may override this implementation if desired."}
{"type": "text", "page_from": 25, "page_to": 25, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=25", "section_title": "uvm_object", "content": "The print method deep-prints this object’s properties in a format and manner governed by the given printer argument; if the printer argument is not provided, the global uvm_default_printer is used. See uvm_printer for more information on printer output formatting. See also uvm_line_printer, uvm_tree_printer, and uvm_table_printer for details on the pre-defined printer “policies,” or formatters, provided by the UVM."}
{"type": "text", "page_from": 25, "page_to": 25, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=25", "section_title": "uvm_object", "content": "The print method is not virtual and must not be overloaded. To include custom information in the print and sprint operations, derived classes must override the do_print method and use the provided printer policy class to format the output."}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "virtual function void do_print ( uvm_printer printer"}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "The do_print method is the user-definable hook called by print and sprint that allows users to customize what gets printed or sprinted beyond the field information provided by the \\`uvm_field_\\* macros, Utility and Field Macros for Components and Objects."}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "The printer argument is the policy object that governs the format and content of the output. To ensure correct print and sprint operation, and to ensure a consistent output format, the printer must be used by all do_print implementations. That is, instead of using \\$display or string concatenations directly, a do_print implementation must call through the printer’s API to add information to be printed or sprinted."}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "An example implementation of do_print is as follows"}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "Then, to print and sprint the object, you could write"}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "See uvm_printer for information about the printer API."}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "virtual function string convert2string()"}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "This virtual function is a user-definable hook, called directly by the user, that allows users to provide object information in the form of a string. Unlike sprint, there is no requirement to use a uvm_printer policy object. As such, the format and content of the output is fully customizable, which may be suitable for applications not requiring the consistent formatting offered by the print/sprint/do_print API."}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "Fields declared in Utility Macros macros (\\`uvm_field_\\*), if used, will not automatically appear in calls to convert2string."}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "An example implementation of convert2string follows."}
{"type": "text", "page_from": 26, "page_to": 26, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=26", "section_title": "uvm_object", "content": "class base extends uvm_object; string field $=$ \"foo\"; virtual function string convert2string(); convert2string $=$ {\"base_field=\",field}; endfunction endclass class obj2 extends uvm_object;"}
{"type": "text", "page_from": 27, "page_to": 27, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=27", "section_title": "uvm_object", "content": "Then, to display an object, you could write"}
{"type": "text", "page_from": 27, "page_to": 27, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=27", "section_title": "uvm_object", "content": "The output will look similar to"}
{"type": "text", "page_from": 27, "page_to": 27, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=27", "section_title": "uvm_object", "content": "function void record ( uvm_recorder recorder $=$ null"}
{"type": "text", "page_from": 27, "page_to": 27, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=27", "section_title": "uvm_object", "content": "The record method deep-records this object’s properties according to an optional recorder policy. The method is not virtual and must not be overloaded. To include additional fields in the record operation, derived classes should override the do_record method."}
{"type": "text", "page_from": 27, "page_to": 27, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=27", "section_title": "uvm_object", "content": "The optional recorder argument specifies the recording policy, which governs how recording takes place. See uvm_recorder for information."}
{"type": "text", "page_from": 27, "page_to": 27, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=27", "section_title": "uvm_object", "content": "A simulator’s recording mechanism is vendor-specific. By providing access via a common interface, the uvm_recorder policy provides vendor-independent access to a simulator’s recording capabilities."}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "class should override this method to include its fields in a record operation."}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "The recorder argument is policy object for recording this object. A do_record implementation should call the appropriate recorder methods for each of its fields. Vendor-specific recording implementations are encapsulated in the recorder policy, thereby insulating user-code from vendor-specific behavior. See uvm_recorder for more information."}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "A typical implementation is as follows"}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "The copy makes this object a copy of the specified object."}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "The copy method is not virtual and should not be overloaded in derived classes. To copy the fields of a derived class, that class should override the do_copy method."}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "virtual function void do_copy ( uvm_object rhs"}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "The do_copy method is the user-definable hook called by the copy method. A derived class should override this method to include its fields in a copy operation."}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "A typical implementation is as follows"}
{"type": "text", "page_from": 28, "page_to": 28, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=28", "section_title": "uvm_object", "content": "The implementation must call super.do_copy, and it must $\\$ 030$ the rhs argument to the derived type before copying."}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "function bit compare ( uvm_object rhs, uvm_comparer comparer $=$ null )"}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "Deep compares members of this data object with those of the object provided in the rhs (right-hand side) argument, returning 1 on a match, 0 otherwise."}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "The compare method is not virtual and should not be overloaded in derived classes. To compare the fields of a derived class, that class should override the do_compare method."}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "The optional comparer argument specifies the comparison policy. It allows you to control some aspects of the comparison operation. It also stores the results of the comparison, such as field-by-field miscompare information and the total number of miscompares. If a compare policy is not provided, then the global uvm_default_comparer policy is used. See uvm_comparer for more information."}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "virtual function bit do_compare ( uvm_object rhs, uvm_comparer comparer )"}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "The do_compare method is the user-definable hook called by the compare method. A derived class should override this method to include its fields in a compare operation. It should return 1 if the comparison succeeds, 0 otherwise."}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "A typical implementation is as follows"}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "class mytype extends uvm_object; int f1; virtual function bit do_compare (uvm_object rhs,uvm_comparer comparer); mytype rhs_; do_compare $\\mathop { \\bf { \\bar { \\mathbf { \\Lambda } } } }$ super.do_compare(rhs,comparer); \\$cast(rhs_,rhs); do_compare $\\& =$ comparer.compare_field_int(\"f1\", f1, rhs_.f1); endfunction"}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "A derived class implementation must call super.do_compare() to ensure its base class’ properties, if any, are included in the comparison. Also, the rhs argument is provided as a generic uvm_object. Thus, you must \\$cast it to the type of this object before comparing."}
{"type": "text", "page_from": 29, "page_to": 29, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=29", "section_title": "uvm_object", "content": "The actual comparison should be implemented using the uvm_comparer object rather than direct field-by-field comparison. This enables users of your class to customize how comparisons are performed and how much miscompare information is collected. See uvm_comparer for more details."}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "function int pack ( ref bit bitstream[], input uvm_packer packer = null )"}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "function int pack_bytes ref byte unsigned bytestream[], input uvm_packer packer $=$ null )"}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "function int pack_ints ( ref int unsigned intstream[], input uvm_packer packer $=$ null )"}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "The pack methods bitwise-concatenate this object’s properties into an array of bits, bytes, or ints. The methods are not virtual and must not be overloaded. To include additional fields in the pack operation, derived classes should override the do_pack method."}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "The optional packer argument specifies the packing policy, which governs the packing operation. If a packer policy is not provided, the global uvm_default_packer policy is used. See uvm_packer for more information."}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "The return value is the total number of bits packed into the given array. Use the array’s built-in size method to get the number of bytes or ints consumed during the packing process."}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "virtual function void do_pack ( uvm_packer packer"}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "The do_pack method is the user-definable hook called by the pack methods. A derived class should override this method to include its fields in a pack operation."}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "The packer argument is the policy object for packing. The policy object should be used to pack objects."}
{"type": "text", "page_from": 30, "page_to": 30, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=30", "section_title": "uvm_object", "content": "A typical example of an object packing itself is as follows class mysubtype extends mysupertype; ...shortint myshort; obj_type myobj; byte myarray[]; function void do_pack (uvm_packer packer); super.do_pack(packer); // pack mysupertype properties"}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "The implementation must call super.do_pack so that base class properties are packed as well."}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "If your object contains dynamic data (object, string, queue, dynamic array, or associative array), and you intend to unpack into an equivalent data structure when unpacking, you must include meta-information about the dynamic data when packing as follows."}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "For queues, dynamic arrays, or associative arrays, pack the number of elements in the array in the 32 bits immediately before packing individual elements, as shown above. For string data types, append a zero byte after packing the string contents. For objects, pack 4 bits immediately before packing the object. For null objects, pack 4’b0000. For non-null objects, pack $4 ^ { \\prime } { \\mathsf { b } } 0 0 0 1$ . When the \\`uvm_field_\\* macros are used, Utility and Field Macros for Components and Objects, the above meta information is included provided the uvm_packer::use_metadata variable is set for the packer."}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "Packing order does not need to match declaration order. However, unpacking order must match packing order."}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "function int unpack ( ref bit bitstream[], input uvm_packer packer = null )"}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "function int unpack_bytes ( ref byte unsigned bytestream[], input uvm_packer packer $=$ null )"}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "function int unpack_ints ( ref int unsigned intstream[], input uvm_packer packer = null )"}
{"type": "text", "page_from": 31, "page_to": 31, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=31", "section_title": "uvm_object", "content": "The unpack methods extract property values from an array of bits, bytes, or ints. The method of unpacking must exactly correspond to the method of packing. This is assured if (a) the same packer policy is used to pack and unpack, and (b) the order of unpacking is the same as the order of packing used to create the input array."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "The unpack methods are fixed (non-virtual) entry points that are directly callable by the user. To include additional fields in the unpack operation, derived classes should override the do_unpack method."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "The optional packer argument specifies the packing policy, which governs both the pack and unpack operation. If a packer policy is not provided, then the global uvm_default_packer policy is used. See uvm_packer for more information."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "The return value is the actual number of bits unpacked from the given array."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "virtual function void do_unpack ( uvm_packer packer"}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "The do_unpack method is the user-definable hook called by the unpack method. A derived class should override this method to include its fields in an unpack operation."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "The packer argument is the policy object for both packing and unpacking. It must be the same packer used to pack the object into bits. Also, do_unpack must unpack fields in the same order in which they were packed. See uvm_packer for more information."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "The following implementation corresponds to the example given in do_pack."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "function void do_unpack (uvm_packer packer); int sz; super.do_unpack(packer); // unpack super's properties $\\begin{array} { r l } { \\mathrm { s } z ^ { \\mathrm { ~ \\tiny ~ - ~ } } = } \\end{array}$ packer.unpack_field_int(myarray.size(), 32); myarray.delete(); for(int index ${ } = 0$ ; index<sz; index++) myarray[index] $=$ packer.unpack_field_int(8); myshort $=$ packer.unpack_field_int(\\$bits(myshort)); packer.unpack_object(myobj); endfunction"}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "If your object contains dynamic data (object, string, queue, dynamic array, or associative array), and you intend to unpack into an equivalent data structure, you must have included meta-information about the dynamic data when it was packed."}
{"type": "text", "page_from": 32, "page_to": 32, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=32", "section_title": "uvm_object", "content": "For queues, dynamic arrays, or associative arrays, unpack the number of elements in the array from the 32 bits immediately before unpacking individual elements, as shown above. For string data types, unpack into the new string until a null byte is encountered. For objects, unpack 4 bits into a byte or int variable. If the value is 0, the target object should be set to null and unpacking continues to the next property, if any. If the least significant bit is 1, then the target object should be allocated and its properties unpacked."}
{"type": "text", "page_from": 33, "page_to": 33, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=33", "section_title": "uvm_object", "content": "set_string_local virtual function void set_string_local ( string field_name, string value, bit recurse = 1"}
{"type": "text", "page_from": 33, "page_to": 33, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=33", "section_title": "uvm_object", "content": "These methods provide write access to integral, string, and uvm_object-based properties indexed by a field_name string. The object designer choose which, if any, properties will be accessible, and overrides the appropriate methods depending on the properties’ types. For objects, the optional clone argument specifies whether to clone the value argument before assignment."}
{"type": "text", "page_from": 33, "page_to": 33, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=33", "section_title": "uvm_object", "content": "The global uvm_is_match function is used to match the field names, so field_name may contain wildcards."}
{"type": "text", "page_from": 33, "page_to": 33, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=33", "section_title": "uvm_object", "content": "An example implementation of all three methods is as follows."}
{"type": "text", "page_from": 34, "page_to": 34, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=34", "section_title": "uvm_object", "content": "Although the object designer implements these methods to provide outside access to one or more properties, they are intended for internal use (e.g., for command-line debugging and auto-configuration) and should not be called directly by the user."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "The uvm_transaction class is the root base class for UVM transactions. Inheriting all the methods of uvm_object, uvm_transaction adds a timing and recording interface."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "This class provides timestamp properties, notification events, and transaction recording support."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "Use of this class as a base for user-defined transactions is deprecated. Its subtype, uvm_sequence_item, shall be used as the base class for all user-defined transaction types."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "The intended use of this API is via a uvm_driver #(REQ,RSP) to call uvm_component::accept_tr, uvm_component::begin_tr, and uvm_component::end_tr during the course of sequence item execution. These methods in the component base class will call into the corresponding methods in this class to set the corresponding timestamps (accept_time, begin_time, and end_time), trigger the corresponding event (begin_event and end_event, and, if enabled, record the transaction contents to a vendor-specific transaction database."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "Note that get_next_item/item_done when called on a uvm_seq_item_pull_port will automatically trigger the begin_event and end_events via calls to begin_tr and end_tr. While convenient, it is generally the responsibility of drivers to mark a transaction’s progress during execution. To allow the driver or layering sequence to control sequence item timestamps, events, and recording, you must call uvm_sqr_if_base#(REQ,RSP)::disable_auto_item_recording at the beginning of the driver’s run_phase task."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "Users may also use the transaction’s event pool, events, to define custom events for the driver to trigger and the sequences to wait on. Any in-between events such as marking the beginning of the address and data phases of transaction execution could be implemented via the events pool."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "In pipelined protocols, the driver may release a sequence (return from finish_item() or its \\`uvm_do macro) before the item has been completed. If the driver uses the begin_tr/end_tr API in uvm_component, the sequence can wait on the item’s end_event to block until the item was fully executed, as in the following example."}
{"type": "text", "page_from": 35, "page_to": 35, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=35", "section_title": "uvm_transaction", "content": "A simple two-stage pipeline driver that can execute address and data phases concurrently might be implemented as follows:"}
{"type": "text", "page_from": 36, "page_to": 36, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=36", "section_title": "uvm_transaction", "content": "lock.get(); seq_item_port.get(req); // Completes the sequencer-driver handshake accept_tr(req); // request bus, wait for grant, etc. begin_tr(req); // execute address phase // allows next transaction to begin address phase lock.put(); // execute data phase // (may trigger custom \"data_phase\" event here) end_tr(req); end"}
{"type": "text", "page_from": 36, "page_to": 36, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=36", "section_title": "uvm_transaction", "content": "The uvm_transaction class is the root base class for UVM transactions."}
{"type": "text", "page_from": 36, "page_to": 36, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=36", "section_title": "uvm_transaction", "content": "virtual class uvm_transaction extends uvm_object"}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "function new string ( name $=$ uvm_component initiator $=$ null )"}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "Creates a new transaction object. The name is the instance name of the transaction. If not supplied, then the object is unnamed."}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "Calling accept_tr indicates that the transaction item has been received by a consumer component. Typically a uvm_driver #(REQ,RSP) would call uvm_component::accept_tr, which calls this method-- upon return from a get_next_item(), get(), or peek() call on its sequencer port, uvm_driver#(REQ,RSP)::seq_item_port."}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "With some protocols, the received item may not be started immediately after it is accepted. For example, a bus driver, having accepted a request transaction, may still have to wait for a bus grant before beginning to execute the request."}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "This function performs the following actions"}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "The transaction’s internal accept time is set to the current simulation time, or to accept_time if provided and non-zero. The accept_time may be any time, past or future."}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "The transaction’s internal accept event is triggered. Any processes waiting on the this event will resume in the next delta cycle."}
{"type": "text", "page_from": 37, "page_to": 37, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=37", "section_title": "uvm_transaction", "content": "The do_accept_tr method is called to allow for any post-accept action in derived"}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "virtual protected function void do_accept_tr ()"}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "This user-definable callback is called by accept_tr just before the accept event is triggered. Implementations should call super.do_accept_tr to ensure correct operation."}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "function integer begin_tr ( time begin_time"}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "This function indicates that the transaction has been started and is not the child of another transaction. Generally, a consumer component begins execution of a transactions it receives."}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "Typically a uvm_driver #(REQ,RSP) would call uvm_component::begin_tr, which calls this method, before actual execution of a sequence item transaction. Sequence items received by a driver are always a child of a parent sequence. In this case, begin_tr obtains the parent handle and delegates to begin_child_tr."}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "See accept_tr for more information on how the begin-time might differ from when the transaction item was received."}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "This function performs the following actions"}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "The transaction’s internal start time is set to the current simulation time, or to begin_time if provided and non-zero. The begin_time may be any time, past or future, but should not be less than the accept time. If recording is enabled, then a new database-transaction is started with the same begin time as above. The do_begin_tr method is called to allow for any post-begin action in derived classes. The transaction’s internal begin event is triggered. Any processes waiting on this event will resume in the next delta cycle."}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "The return value is a transaction handle, which is valid (non-zero) only if recording is enabled. The meaning of the handle is implementation specific."}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "function integer begin_child_tr ( time begin_time integer parent_handle = 0"}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "This function indicates that the transaction has been started as a child of a parent transaction given by parent_handle. Generally, a consumer component calls this method via uvm_component::begin_child_tr to indicate the actual start of execution of this transaction."}
{"type": "text", "page_from": 38, "page_to": 38, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=38", "section_title": "uvm_transaction", "content": "The parent handle is obtained by a previous call to begin_tr or begin_child_tr. If the parent_handle is invalid $( = 0 )$ , then this function behaves the same as begin_tr."}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "This function performs the following actions"}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "The transaction’s internal start time is set to the current simulation time, or to begin_time if provided and non-zero. The begin_time may be any time, past or future, but should not be less than the accept time. If recording is enabled, then a new database-transaction is started with the same begin time as above. The inherited uvm_object::record method is then called, which records the current property values to this new transaction. Finally, the newly started transaction is linked to the parent transaction given by parent_handle. The do_begin_tr method is called to allow for any post-begin action in derived classes. The transaction’s internal begin event is triggered. Any processes waiting on this event will resume in the next delta cycle."}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "The return value is a transaction handle, which is valid (non-zero) only if recording is enabled. The meaning of the handle is implementation specific."}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "virtual protected function void do_begin_tr ()"}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "This user-definable callback is called by begin_tr and begin_child_tr just before the begin event is triggered. Implementations should call super.do_begin_tr to ensure correct operation."}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "function void end_tr ( time end_time = 0, bit free_handle = 1"}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "This function indicates that the transaction execution has ended. Generally, a consumer component ends execution of the transactions it receives."}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "You must have previously called begin_tr or begin_child_tr for this call to be successful."}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "Typically a uvm_driver #(REQ,RSP) would call uvm_component::end_tr, which calls this method, upon completion of a sequence item transaction. Sequence items received by a driver are always a child of a parent sequence. In this case, begin_tr obtain the parent handle and delegate to begin_child_tr."}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "This function performs the following actions"}
{"type": "text", "page_from": 39, "page_to": 39, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=39", "section_title": "uvm_transaction", "content": "The transaction’s internal end time is set to the current simulation time, or to end_time if provided and non-zero. The end_time may be any time, past or future, but should not be less than the begin time. If recording is enabled and a database-transaction is currently active, then the record method inherited from uvm_object is called, which records the final property values. The transaction is then ended. If free_handle is set, the transaction is released and can no longer be linked to (if supported by the implementation). The do_end_tr method is called to allow for any post-end action in derived classes. The transaction’s internal end event is triggered. Any processes waiting on this event will resume in the next delta cycle."}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "virtual protected function void do_end_tr ()"}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "This user-definable callback is called by end_tr just before the end event is triggered. Implementations should call super.do_end_tr to ensure correct operation."}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "function integer get_tr_handle ()"}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "Returns the handle associated with the transaction, as set by a previous call to begin_child_tr or begin_tr with transaction recording enabled."}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "function void disable_recording ()"}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "Turns off recording for the transaction stream. This method does not effect a uvm_component’s recording streams."}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "function void enable_recording ( uvm_tr_stream stream"}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "Turns on recording to the stream specified."}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "If transaction recording is on, then a call to record is made when the transaction is ended."}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "is_recording_enabled"}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "function bit is_recording_enabled()"}
{"type": "text", "page_from": 40, "page_to": 40, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=40", "section_title": "uvm_transaction", "content": "Returns 1 if recording is currently on, 0 otherwise."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "Returns the event pool associated with this transaction."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "By default, the event pool contains the events: begin, accept, and end. Events can also be added by derivative objects. An event pool is a specialization of uvm_pool#(KEY,T), e.g. a uvm_pool#(uvm_event)."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "function void set_initiator uvm_component initiator"}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "Sets initiator as the initiator of this transaction."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "The initiator can be the component that produces the transaction. It can also be the component that started the transaction. This or any other usage is up to the transaction designer."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "function uvm_component get_initiator ()"}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "Returns the component that produced or started the transaction, as set by a previous call to set_initiator."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "function time get_accept_time ()"}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "function time get_begin_time ()"}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "function time get_end_time ()"}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "Returns the time at which this transaction was accepted, begun, or ended, as by a previous call to accept_tr, begin_tr, begin_child_tr, or end_tr."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "function void set_transaction_id( integer id"}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "Sets this transaction’s numeric identifier to id. If not set via this method, the transaction ID defaults to $^ { - 1 }$ ."}
{"type": "text", "page_from": 41, "page_to": 41, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=41", "section_title": "uvm_transaction", "content": "When using sequences to generate stimulus, the transaction ID is used along with the sequence ID to route responses in sequencers and to correlate responses to requests."}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "function integer get_transaction_id()"}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "Returns this transaction’s numeric identifier, which is $^ { - 1 }$ if not set explicitly by set_transaction_id."}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "When using a uvm_sequence #(REQ,RSP) to generate stimulus, the transaction ID is used along with the sequence ID to route responses in sequencers and to correlate responses to requests."}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "const uvm_event_pool events $=$ new"}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "The event pool instance for this transaction. This pool is used to track various milestones: by default, begin, accept, and end"}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "uvm_event#( uvm_object ) begin_event"}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "A uvm_event#(uvm_object) that is triggered when this transaction’s actual execution on the bus begins, typically as a result of a driver calling uvm_component::begin_tr. Processes that wait on this event will block until the transaction has begun."}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "For more information, see the general discussion for uvm_transaction. See uvm_event#(T) for details on the event API."}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "uvm_event#( uvm_object ) end_event"}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "A uvm_event#(uvm_object) that is triggered when this transaction’s actual execution on the bus ends, typically as a result of a driver calling uvm_component::end_tr. Processes that wait on this event will block until the transaction has ended."}
{"type": "text", "page_from": 42, "page_to": 42, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=42", "section_title": "uvm_transaction", "content": "For more information, see the general discussion for uvm_transaction. See uvm_event#(T) for details on the event API."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "The uvm_root class serves as the implicit top-level and phase controller for all UVM components. Users do not directly instantiate uvm_root. The UVM automatically creates a single instance of uvm_root that users can access via the global (uvm_pkg-scope) variable, uvm_top."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "The uvm_top instance of uvm_root plays several key roles in the UVM."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "The uvm_top serves as an implicit top-level component. Any component whose parent is specified as null becomes a child of uvm_top. Thus, all UVM components in simulation are descendants of uvm_top."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "Phase control Search"}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "uvm_top manages the phasing for all components."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "Use uvm_top to search for components based on their hierarchical name. See find and find_all."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "Report configuration"}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "Use uvm_top to globally configure report verbosity, log files, and actions. For example, uvm_top.set_report_verbosity_level_hier(UVM_FULL) would set full verbosity for all components in simulation."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "Because uvm_top is globally accessible (in uvm_pkg scope), UVM’s reporting mechanism is accessible from anywhere outside uvm_component, such as in modules and sequences. See uvm_report_error, uvm_report_warning, and other global methods."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "The uvm_top instance checks during the end_of_elaboration phase if any errors have been generated so far. If errors are found a UVM_FATAL error is being generated as result so that the simulation will not continue to the start_of_simulation_phase."}
{"type": "text", "page_from": 43, "page_to": 43, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=43", "section_title": "uvm_root", "content": "The uvm_root class serves as the implicit top-level and phase controller for all UVM components."}
{"type": "text", "page_from": 44, "page_to": 44, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=44", "section_title": "uvm_root", "content": "static function uvm_root get()"}
{"type": "text", "page_from": 44, "page_to": 44, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=44", "section_title": "uvm_root", "content": "Static accessor for uvm_root."}
{"type": "text", "page_from": 44, "page_to": 44, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=44", "section_title": "uvm_root", "content": "The static accessor is provided as a convenience wrapper around retrieving the root via the uvm_coreservice_t::get_root method."}
{"type": "text", "page_from": 44, "page_to": 44, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=44", "section_title": "uvm_root", "content": "// Using the uvm_coreservice_t: uvm_coreservice_t cs; uvm_root r; cs $\\sqsupseteq$ uvm_coreservice_t::get(); r = cs.get_root(); // Not using the uvm_coreservice_t: uvm_root r; r = uvm_root::get();"}
{"type": "text", "page_from": 44, "page_to": 44, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=44", "section_title": "uvm_root", "content": "virtual task run_test string test_name $=$"}
{"type": "text", "page_from": 44, "page_to": 44, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=44", "section_title": "uvm_root", "content": "Phases all components through all registered phases. If the optional test_name argument is provided, or if a command-line plusarg, $+ \\mathsf { U V } \\mathsf { M } .$ _TESTNAME $=$ TEST_NAME, is found, then the specified component is created just prior to phasing. The test may contain new verification components or the entire testbench, in which case the test and testbench can be chosen from the command line without forcing recompilation. If the global (package) variable, finish_on_completion, is set, then $\\$ 9$ finish is called after phasing completes."}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "has a UVM_EXIT action associated with it, e.g., as with fatal errors."}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "Calls the uvm_component::pre_abort() method on the entire uvm_component hierarchy in a bottom-up fashion. It then calls uvm_report_server::report_summarize and terminates the simulation with \\$finish."}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "function void set_timeout( time timeout, bit overridable $= 1$"}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "Specifies the timeout for the simulation. Default is \\`UVM_DEFAULT_TIMEOUT"}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "The timeout is simply the maximum absolute simulation time allowed before a FATAL occurs. If the timeout is set to 20ns, then the simulation must end before 20ns, or a FATAL timeout will occur."}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "This is provided so that the user can prevent the simulation from potentially consuming too many resources (Disk, Memory, CPU, etc) when the testbench is essentially hung."}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "bit finish_on_completion = 1"}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "If set, then run_test will call $\\$ 9$ finish after all phases are executed."}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "uvm_component top_levels[\\$]"}
{"type": "text", "page_from": 45, "page_to": 45, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=45", "section_title": "uvm_root", "content": "This variable is a list of all of the top level components in UVM. It includes the uvm_test_top component that is created by run_test as well as any other top level components that have been instantiated anywhere in the hierarchy."}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "Returns the component handle (find) or list of components handles (find_all) matching a given string. The string may contain the wildcards,"}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "and ?. Strings beginning with ‘.’ are absolute path names. If the optional argument comp is provided, then search begins from that component down (default $\\ l =$ all components)."}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "function void print_topology ( uvm_printer printer $=$ null )"}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "Print the verification environment’s component topology. The printer is a uvm_printer object that controls the format of the topology printout; a null printer prints with the default output."}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "bit enable_print_topology = 0"}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "If set, then the entire testbench topology is printed just after completion of the end_of_elaboration phase."}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "const uvm_root uvm_top $=$ uvm_root::get()"}
{"type": "text", "page_from": 46, "page_to": 46, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=46", "section_title": "uvm_root", "content": "This is the top-level that governs phase execution and provides component search interface. See uvm_root for more information."}
{"type": "text", "page_from": 47, "page_to": 47, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=47", "section_title": "Port Base Classes", "content": "This class defines an interface for obtaining a port’s connectivity lists after or during the end_of_elaboration phase. The sub-class, uvm_port_component #(PORT), implements this interface."}
{"type": "text", "page_from": 47, "page_to": 47, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=47", "section_title": "Port Base Classes", "content": "The connectivity lists are returned in the form of handles to objects of this type. This allowing traversal of any port’s fan-out and fan-in network through recursive calls to get_connected_to and get_provided_to. Each port’s full name and type name can be retrieved using get_full_name and get_type_name methods inherited from uvm_component."}
{"type": "text", "page_from": 47, "page_to": 47, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=47", "section_title": "Port Base Classes", "content": "uvm_port_component_base"}
{"type": "text", "page_from": 47, "page_to": 47, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=47", "section_title": "Port Base Classes", "content": "This class defines an interface for obtaining a port’s connectivity lists after or during the end_of_elaboration phase."}
{"type": "text", "page_from": 47, "page_to": 47, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=47", "section_title": "Port Base Classes", "content": "virtual class uvm_port_component_base extends uvm_component"}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "pure virtual function void get_connected_to( ref uvm_port_list list"}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "For a port or export type, this function fills list with all of the ports, exports and implementations that this port is connected to."}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "pure virtual function void get_provided_to( ref uvm_port_list list"}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "For an implementation or export type, this function fills list with all of the ports, exports and implementations that this port is provides its implementation to."}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "pure virtual function bit is_port()"}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "pure virtual function bit is_export()"}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "pure virtual function bit is_imp()"}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "These function determine the type of port. The functions are mutually exclusive; one will return 1 and the other two will return 0."}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "uvm_port_component #(PORT )"}
{"type": "text", "page_from": 48, "page_to": 48, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=48", "section_title": "Port Base Classes", "content": "See description of uvm_port_component_base for information about this class"}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "uvm_port_component #(PORT )"}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "See description of uvm_port_component_base for information about this class"}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "class uvm_port_component #( type PORT = uvm_object ) extends uvm_port_component_base"}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "get_port Retrieve the actual port object that this proxy refers to."}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "function PORT get_port()"}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "Retrieve the actual port object that this proxy refers to."}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "Transaction-level communication between components is handled via its ports, exports, and imps, all of which derive from this class."}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "The uvm_port_base extends IF, which is the type of the interface implemented by derived port, export, or implementation. IF is also a type parameter to uvm_port_base."}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "IF The interface type implemented by the subtype to this base port"}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "The UVM provides a complete set of ports, exports, and imps for the OSCI- standard TLM interfaces. They can be found in the ../src/tlm/ directory. For the TLM interfaces, the IF parameter is always uvm_tlm_if_base #(T1,T2)."}
{"type": "text", "page_from": 49, "page_to": 49, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=49", "section_title": "Port Base Classes", "content": "Just before uvm_component::end_of_elaboration_phase, an internal uvm_component::resolve_bindings process occurs, after which each port and export holds a list of all imps connected to it via hierarchical connections to other ports and exports. In effect, we are collapsing the port’s fanout, which can span several levels up and down the component hierarchy, into a single array held local to the port. Once the list is determined, the port’s min and max connection settings can be checked and enforced."}
{"type": "text", "page_from": 50, "page_to": 50, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=50", "section_title": "Port Base Classes", "content": "uvm_port_base possesses the properties of components in that they have a hierarchical instance path and parent. Because SystemVerilog does not support multiple inheritance, uvm_port_base cannot extend both the interface it implements and uvm_component. Thus, uvm_port_base contains a local instance of uvm_component, to which it delegates such commands as get_name, get_full_name, and get_parent."}
{"type": "text", "page_from": 50, "page_to": 50, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=50", "section_title": "Port Base Classes", "content": "Transaction-level communication between components is handled via its ports, exports, and imps, all of which derive from this class."}
{"type": "text", "page_from": 50, "page_to": 50, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=50", "section_title": "Port Base Classes", "content": "virtual class uvm_port_base #( type IF = uvm_void ) extends IF"}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "The first two arguments are the normal uvm_component constructor arguments."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "The port_type can be one of UVM_PORT, UVM_EXPORT, or UVM_IMPLEMENTATION."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "The min_size and max_size specify the minimum and maximum number of implementation (imp) ports that must be connected to this port base by the end of elaboration. Setting max_size to UVM_UNBOUNDED_CONNECTIONS sets no maximum, i.e., an unlimited number of connections are allowed."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "By default, the parent/child relationship of any port being connected to this port is not checked. This can be overridden by configuring the port’s check_connection_relationships bit via uvm_config_int::set(). See connect for more information."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "function string get_name()"}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "Returns the leaf name of this port."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "Returns the full hierarchical name of this port."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "virtual function uvm_component get_parent()"}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "Returns the handle to this port’s parent, or null if it has no parent."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "virtual function uvm_port_component_base get_comp()"}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "Returns a handle to the internal proxy component representing this port."}
{"type": "text", "page_from": 51, "page_to": 51, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=51", "section_title": "Port Base Classes", "content": "Ports are considered components. However, they do not inherit uvm_component. Instead, they contain an instance of uvm_port_component #(PORT) that serves as a proxy to this port."}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "virtual function string get_type_name()"}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "Returns the type name to this port. Derived port classes must implement this method to return the concrete type. Otherwise, only a generic “uvm_port”, “uvm_export” or “uvm_implementation” is returned."}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "Returns the minimum number of implementation ports that must be connected to this port by the end_of_elaboration phase."}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "Returns the maximum number of implementation ports that must be connected to this port by the end_of_elaboration phase."}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "function bit is_unbounded ()"}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "Returns 1 if this port has no maximum on the number of implementation ports this port can connect to. A port is unbounded when the max_size argument in the constructor is specified as UVM_UNBOUNDED_CONNECTIONS."}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "function bit is_port ()"}
{"type": "text", "page_from": 52, "page_to": 52, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=52", "section_title": "Port Base Classes", "content": "function bit is_export ()"}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "function void set_default_index ( int index"}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "Sets the default implementation port to use when calling an interface method. This method should only be called on UVM_EXPORT types. The value must not be set before the end_of_elaboration phase, when port connections have not yet been resolved."}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "virtual function void connect ( this_type provider"}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "Connects this port to the given provider port. The ports must be compatible in the following ways"}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "Their type parameters must match The provider’s interface type (blocking, non-blocking, analysis, etc.) must be compatible. Each port has an interface mask that encodes the interface(s) it supports. If the bitwise AND of these masks is equal to the this port’s mask, the requirement is met and the ports are compatible. For example, a uvm_blocking_put_port #(T) is compatible with a uvm_put_export #(T) and uvm_blocking_put_imp #(T) because the export and imp provide the interface required by the uvm_blocking_put_port. Ports of type UVM_EXPORT can only connect to other exports or imps. Ports of type UVM_IMPLEMENTATION cannot be connected, as they are bound to the component that implements the interface at time of construction."}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "In addition to type-compatibility checks, the relationship between this port and the provider port will also be checked if the port’s check_connection_relationships configuration has been set. (See new for more information.)"}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "Relationships, when enabled, are checked are as follows"}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "If this port is a UVM_PORT type, the provider can be a parent port, or a sibling export or implementation port. If this port is a UVM_EXPORT type, the provider can be a child export or implementation port."}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "If any relationship check is violated, a warning is issued."}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "Note- the uvm_component::connect_phase method is related to but not the same as this method. The component’s connect method is a phase callback where port’s connect method calls are made."}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "function void debug_connected_to ( int level $= \\overline { { 0 } } ,$ int max_level $\\qquad = \\quad - 1$ )"}
{"type": "text", "page_from": 53, "page_to": 53, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=53", "section_title": "Port Base Classes", "content": "The debug_connected_to method outputs a visual text display of the port/export/imp network to which this port connects (i.e., the port’s fanout)."}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "This method must not be called before the end_of_elaboration phase, as port connections are not resolved until then."}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "function void debug_provided_to ( int level $= { \\overline { { 0 } } } ,$ int max_level $\\qquad = \\quad - 1$ )"}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "The debug_provided_to method outputs a visual display of the port/export network that ultimately connect to this port (i.e., the port’s fanin)."}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "This method must not be called before the end_of_elaboration phase, as port connections are not resolved until then."}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "virtual function void resolve_bindings()"}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "This callback is called just before entering the end_of_elaboration phase. It recurses through each port’s fanout to determine all the imp destinations. It then checks against the required min and max connections. After resolution, size returns a valid value and get_if can be used to access a particular imp."}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "This method is automatically called just before the start of the end_of_elaboration phase. Users should not need to call it directly."}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "function uvm_port_base #( IF ) get_if(int index ${ \\mathrel { \\mathop : } } = 0$ )"}
{"type": "text", "page_from": 54, "page_to": 54, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=54", "section_title": "Port Base Classes", "content": "Returns the implementation (imp) port at the given index from the array of imps this port is connected to. Use size to get the valid range for index. This method can only be called at the end_of_elaboration phase or after, as port connections are not resolved before then."}
{"type": "text", "page_from": 55, "page_to": 55, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=55", "section_title": "Reporting Classes", "content": "The reporting classes provide a facility for issuing reports with consistent formatting. Users can configure what actions to take and what files to send output to based on report severity, ID, or both severity and ID. Users can also filter messages based on their verbosity settings."}
{"type": "text", "page_from": 55, "page_to": 55, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=55", "section_title": "Reporting Classes", "content": "The primary interface to the UVM reporting facility is the uvm_report_object from which all uvm_components extend. The uvm_report_object delegates most tasks to its internal uvm_report_handler. If the report handler determines the report is not filtered based the configured verbosity setting, it sends the report to the central uvm_report_server for formatting and processing."}
{"type": "text", "page_from": 55, "page_to": 55, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=55", "section_title": "Reporting Classes", "content": "The reporting classes provide a facility for issuing reports with consistent formatting."}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message_element_base", "header_path": ["6", "1"], "chapter": "6", "section": "6.1", "content": "6.1 uvm_report_message_element_base"}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message", "content": "Base class for report message element. Defines common interface."}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message", "content": "virtual function string get_name()"}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message", "content": "virtual function void set_name( string name"}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message", "content": "Get or set the name of the element"}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message", "content": "virtual function uvm_action get_action()"}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message", "content": "virtual function void set_action( uvm_action action"}
{"type": "text", "page_from": 56, "page_to": 56, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=56", "section_title": "uvm_report_message", "content": "Get or set the authorized action for the element"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "Message element class for integral type"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "uvm_report_message_int_element"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "Message element class for integral type"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "uvm_report_message_element_base uvm_report_message_int_element"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "class uvm_report_message_int_element extends uvm_report_message_element_base"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "Get or set the value (integral type) of the element, with size and radix"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "virtual function uvm_bitstream_t get_value( output int size, output uvm_radix_enum radix )"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "virtual function void set_value( uvm_bitstream_t value, int size, uvm_radix_enum radix"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "Get or set the value (integral type) of the element, with size and radix"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "uvm_report_message_string_element"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "Message element class for string type"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "uvm_report_message_string_element"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "Message element class for string type"}
{"type": "text", "page_from": 57, "page_to": 57, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=57", "section_title": "uvm_report_message", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "uvm_report_message_element_base"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "uvm_report_message_string_element"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "class uvm_report_message_string_element extends uvm_report_message_element_base"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "Get or set the value (string type) of the element"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "virtual function string get_value()"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "virtual function void set_value( string value )"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "Get or set the value (string type) of the element"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "uvm_report_message_object_element"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "Message element class for object type"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "uvm_report_message_object_element"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "Message element class for object type"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "class uvm_report_message_object_element extends uvm_report_message_element_base"}
{"type": "text", "page_from": 58, "page_to": 58, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=58", "section_title": "uvm_report_message", "content": "get_value Get the value (object reference) of the element set_value Get or set the value (object reference) of the element"}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "virtual function uvm_object get_value()"}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "Get the value (object reference) of the element"}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "virtual function void set_value( uvm_object value"}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "Get or set the value (object reference) of the element"}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "uvm_report_message_element_container"}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "A container used by report message to contain the dynamically added elements, with APIs to add and delete the elements."}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "uvm_report_message_element_container"}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "A container used by report message to contain the dynamically added elements, with APIs to add and delete the elements."}
{"type": "text", "page_from": 59, "page_to": 59, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=59", "section_title": "uvm_report_message", "content": "class uvm_report_message_element_container extends uvm_object"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "Create a new uvm_report_message_element_container object"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "virtual function int size()"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "Returns the size of the container, i.e. the number of elements"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "virtual function void delete( int index"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "Delete the index-th element in the container"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "virtual function void delete_elements()"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "Delete all the elements in the container"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "Get all the elements from the container and put them in a queue"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "virtual function void add_int( string name, uvm_bitstream_t value, int size, uvm_radix_enum radix, uvm_action action $=$ (UVM_LOG|UVM_RM_RECORD) )"}
{"type": "text", "page_from": 60, "page_to": 60, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=60", "section_title": "uvm_report_message", "content": "This method adds an integral type of the name name and value value to the container. The required size field indicates the size of value. The required radix field determines how to display and record the field. The optional print/record bit is to specify whether the element will be printed/recorded."}
{"type": "text", "page_from": 61, "page_to": 61, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=61", "section_title": "uvm_report_message", "content": "virtual function void add_string( string name, string value, uvm_action action $=$ (UVM_LOG|UVM_RM_RECORD)"}
{"type": "text", "page_from": 61, "page_to": 61, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=61", "section_title": "uvm_report_message", "content": "This method adds a string of the name name and value value to the message. The optional print/record bit is to specify whether the element will be printed/recorded."}
{"type": "text", "page_from": 61, "page_to": 61, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=61", "section_title": "uvm_report_message", "content": "virtual function void add_object( string name, uvm_object obj, uvm_action action $=$ (UVM_LOG|UVM_RM_RECORD) ) This method adds a uvm_object of the name name and reference obj to the message. The optional print/record bit is to specify whether the element will be printed/recorded."}
{"type": "text", "page_from": 61, "page_to": 61, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=61", "section_title": "uvm_report_message", "content": "The uvm_report_message is the basic UVM object message class. It provides the fields that are common to all messages. It also has a message element container and provides the APIs necessary to add integral types, strings and uvm_objects to the container. The report message object can be initialized with the common fields, and passes through the whole reporting system (i.e. report object, report handler, report server, report catcher, etc) as an object. The additional elements can be added/deleted to/from the message object anywhere in the reporting system, and can be printed or recorded along with the common fields."}
{"type": "text", "page_from": 61, "page_to": 61, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=61", "section_title": "uvm_report_message", "content": "The uvm_report_message is the basic UVM object message class."}
{"type": "text", "page_from": 62, "page_to": 62, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=62", "section_title": "uvm_report_message", "content": "Creates a new uvm_report_message object."}
{"type": "text", "page_from": 62, "page_to": 62, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=62", "section_title": "uvm_report_message", "content": "static function uvm_report_message new_report_message("}
{"type": "text", "page_from": 62, "page_to": 62, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=62", "section_title": "uvm_report_message", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "Creates a new uvm_report_message object. This function is the same as new(), but keeps the random stability."}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "virtual function void do_print( uvm_printer printer"}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "The uvm_report_message implements uvm_object::do_print() such that print method provides UVM printer formatted output of the message. A snippet of example output is shown here:"}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "virtual function uvm_report_object get_report_object()"}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "virtual function void set_report_object( uvm_report_object ro"}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "Get or set the uvm_report_object that originated the message."}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "virtual function uvm_report_handler get_report_handler()"}
{"type": "text", "page_from": 63, "page_to": 63, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=63", "section_title": "uvm_report_message", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "virtual function void set_report_handler( uvm_report_handler rh"}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "Get or set the uvm_report_handler that is responsible for checking whether the message is enabled, should be upgraded/downgraded, etc."}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "virtual function uvm_report_server get_report_server()"}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "virtual function void set_report_server( uvm_report_server rs"}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "Get or set the uvm_report_server that is responsible for servicing the message’s actions."}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "virtual function uvm_severity get_severity()"}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "virtual function void set_severity( uvm_severity sev"}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "Get or set the severity (UVM_INFO, UVM_WARNING, UVM_ERROR or UVM_FATAL) of the message. The value of this field is determined via the API used (\\`uvm_info(), \\`uvm_waring(), etc.) and populated for the user."}
{"type": "text", "page_from": 64, "page_to": 64, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=64", "section_title": "uvm_report_message", "content": "virtual function string get_id()"}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "virtual function string get_message()"}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "virtual function void set_message( string msg"}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "Get or set the user message content string."}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "virtual function int get_verbosity()"}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "virtual function void set_verbosity( int ver"}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "Get or set the message threshold value. This value is compared against settings in the uvm_report_handler to determine whether this message should be executed."}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "virtual function string get_filename()"}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "virtual function void set_filename( string fname"}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "Get or set the file from which the message originates. This value is automatically populated by the messaging macros."}
{"type": "text", "page_from": 65, "page_to": 65, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=65", "section_title": "uvm_report_message", "content": "virtual function int get_line()"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "Get or set the line in the file from which the message originates. This value is automatically populate by the messaging macros."}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "virtual function string get_context()"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "virtual function void set_context( string cn"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "Get or set the optional user-supplied string that is meant to convey the context of the message. It can be useful in scopes that are not inherently UVM like modules, interfaces, etc."}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "virtual function uvm_action get_action()"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "virtual function void set_action( uvm_action act"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "Get or set the action(s) that the uvm_report_server should perform for this message. This field is populated by the uvm_report_handler during message execution flow."}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "virtual function UVM_FILE get_file()"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "virtual function void set_file( UVM_FILE fl"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "Get or set the file that the message is to be written to when the message’s action is UVM_LOG. This field is populated by the uvm_report_handler during message execution flow."}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "get_element_container"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "virtual function uvm_report_message_element_container get_element_container()"}
{"type": "text", "page_from": 66, "page_to": 66, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=66", "section_title": "uvm_report_message", "content": "Get the element_container of the message"}
{"type": "text", "page_from": 67, "page_to": 67, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=67", "section_title": "uvm_report_message", "content": "Set all the common fields of the report message in one shot."}
{"type": "text", "page_from": 67, "page_to": 67, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=67", "section_title": "uvm_report_message", "content": "MESSAGE ELEmENT APIS"}
{"type": "text", "page_from": 67, "page_to": 67, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=67", "section_title": "uvm_report_message", "content": "This method adds an integral type of the name name and value value to the message. The required size field indicates the size of value. The required radix field determines how to display and record the field. The optional print/record bit is to specify whether the element will be printed/recorded."}
{"type": "text", "page_from": 67, "page_to": 67, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=67", "section_title": "uvm_report_message", "content": "This method adds a string of the name name and value value to the message. The optional print/record bit is to specify whether the element will be printed/recorded."}
{"type": "text", "page_from": 67, "page_to": 67, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=67", "section_title": "uvm_report_message", "content": "virtual function void add_object( string name, uvm_object obj, uvm_action action $=$ (UVM_LOG|UVM_RM_RECORD) ) This method adds a uvm_object of the name name and reference obj to the message. The optional print/record bit is to specify whether the element will be printed/recorded."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "header_path": ["6", "2"], "chapter": "6", "section": "6.2", "content": "6.2 uvm_report_object"}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "The uvm_report_object provides an interface to the UVM reporting facility. Through this interface, components issue the various messages that occur during simulation. Users can configure what actions are taken and what file(s) are output for individual messages from a particular component or for all messages from all components in the environment. Defaults are applied where there is no explicit configuration."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "Most methods in uvm_report_object are delegated to an internal instance of a uvm_report_handler, which stores the reporting configuration and determines whether an issued message should be displayed based on that configuration. Then, to display a message, the report handler delegates the actual formatting and production of messages to a central uvm_report_server."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "A report consists of an id string, severity, verbosity level, and the textual message itself. They may optionally include the filename and line number from which the message came. If the verbosity level of a report is greater than the configured maximum verbosity level of its report object, it is ignored. If a report passes the verbosity filter in effect, the report’s action is determined. If the action includes output to a file, the configured file descriptor(s) are determined."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "can be set for (in increasing priority) severity, id, and (severity,id) pair. They include output to the screen UVM_DISPLAY, whether the message counters should be incremented UVM_COUNT, and whether a $\\$ 1$ finish should occur UVM_EXIT."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "The following provides the default actions assigned to each severity. These can be overridden by any of the set_\\*_action methods."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "These can be set by (in increasing priority) default, severity level, an id, or (severity,id) pair. File descriptors are standard SystemVerilog file descriptors; they may refer to more than one file. It is the user’s responsibility to open and close them."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "The default file handle is 0, which means that reports are not sent to a file even if a UVM_LOG attribute is set in the action associated with the report. This can be overridden by any of the set_\\*_file methods."}
{"type": "text", "page_from": 68, "page_to": 68, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=68", "section_title": "uvm_report_object", "content": "The uvm_report_object provides an interface to the UVM reporting facility."}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "Creates a new report object with the given name. This method also creates a new uvm_report_handler object to which most tasks are delegated."}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "uvm_get_report_object"}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "function uvm_report_object uvm_get_report_object()"}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "Returns the nearest uvm_report_object when called. From inside a uvm_component, the method simply returns this."}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "See also the global version of uvm_get_report_object."}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "Returns 1 if the configured verbosity for this severity/id is greater than or equal to verbosity else returns 0."}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "See also get_report_verbosity_level and the global version of uvm_report_enabled."}
{"type": "text", "page_from": 70, "page_to": 70, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=70", "section_title": "uvm_report_object", "content": "virtual function void uvm_report_info("}
{"type": "text", "page_from": 71, "page_to": 71, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=71", "section_title": "uvm_report_object", "content": "virtual function void uvm_report_fatal( string id, string message, int verbosity UVM_NONE, string filename int line 0, , string context_name = bit report_enabled_checked = \"\", )"}
{"type": "text", "page_from": 71, "page_to": 71, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=71", "section_title": "uvm_report_object", "content": "These are the primary reporting methods in the UVM. Using these instead of \\$display and other ad hoc approaches ensures consistent output and central control over where output is directed and any actions that result. All reporting methods have the same arguments, although each has a different default verbosity:"}
{"type": "text", "page_from": 71, "page_to": 71, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=71", "section_title": "uvm_report_object", "content": "a unique id for the report or report group that can be used for identification and therefore targeted filtering. You can configure an individual report’s actions and output file(s) using this id string."}
{"type": "text", "page_from": 71, "page_to": 71, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=71", "section_title": "uvm_report_object", "content": "the message body, preformatted if necessary to a single string."}
{"type": "text", "page_from": 71, "page_to": 71, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=71", "section_title": "uvm_report_object", "content": "the verbosity of the message, indicating its relative importance. If this number is less than or equal to the effective verbosity level, see set_report_verbosity_level, then the report is issued, subject to the configured action and file descriptor settings. Verbosity is ignored for warnings, errors, and fatals. However, if a warning, error or fatal is demoted to an info message using the uvm_report_catcher, then the verbosity is taken into account."}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "(Optional) The location from which the report was issued. Use the predefined macros, \\`__FILE__ and _LINE__. If specified, it is displayed in the output."}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "(Optional) The string context from where the message is originating. This can be the %m of a module, a specific method, etc."}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "report_enabled_checked"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "(Optional) This bit indicates whether the currently provided message has been checked as to whether the message should be processed. If it hasn’t been checked, it will be checked inside the uvm_report function."}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "uvm_process_report_message"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "virtual function void uvm_process_report_message( uvm_report_message report_message"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "This method takes a preformed uvm_report_message, populates it with the report object and passes it to the report handler for processing. It is expected to be checked for verbosity and populated."}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "VERBOsITY CONFIGURATION"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "get_report_verbosity_level"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "function int get_report_verbosity_level( uvm_severity severity $=$ UVM_INFO, string id $=$ )"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "Gets the verbosity level in effect for this object. Reports issued with verbosity greater than this will be filtered out. The severity and tag arguments check if the verbosity level has been modified for specific severity/tag combinations."}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "get_report_max_verbosity_level"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "function int get_report_max_verbosity_level()"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "Gets the maximum verbosity level in effect for this report object. Any report from this component whose verbosity exceeds this maximum will be ignored."}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "set_report_verbosity_level"}
{"type": "text", "page_from": 72, "page_to": 72, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=72", "section_title": "uvm_report_object", "content": "function void set_report_verbosity_level ( int verbosity_level"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "This method sets the maximum verbosity level for reports for this component. Any report from this component whose verbosity exceeds this maximum will be ignored."}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "set_report_id_verbosity"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "function void set_report_id_verbosity ( string id, int verbosity"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "set_report_severity_id_verbosity"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "These methods associate the specified verbosity threshold with reports of the given severity, id, or severity-id pair. This threshold is compared with the verbosity originally assigned to the report to decide whether it gets processed. A verbosity threshold associated with a particular severity-id pair takes precedence over a verbosity threshold associated with id, which takes precedence over a verbosity threshold associated with a severity."}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "The verbosity argument can be any integer, but is most commonly a predefined uvm_verbosity value, UVM_NONE, UVM_LOW, UVM_MEDIUM, UVM_HIGH, UVM_FULL."}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "AcTION CONFIGURATION"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "function int get_report_action( uvm_severity severity, string id"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "Gets the action associated with reports having the given severity and id."}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "set_report_severity_action"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "function void set_report_severity_action ( uvm_severity severity, uvm_action action"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "set_report_id_action"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "function void set_report_id_action ( string id, uvm_action action"}
{"type": "text", "page_from": 73, "page_to": 73, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=73", "section_title": "uvm_report_object", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "set_report_severity_id_action"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "function void set_report_severity_id_action ( uvm_severity severity, string id, uvm_action action ）"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "These methods associate the specified action or actions with reports of the given severity, id, or severity-id pair. An action associated with a particular severity-id pair takes precedence over an action associated with id, which takes precedence over an action associated with a severity."}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "The action argument can take the value UVM_NO_ACTION, or it can be a bitwise OR of any combination of UVM_DISPLAY, UVM_LOG, UVM_COUNT, UVM_STOP, UVM_EXIT, and UVM_CALL_HOOK."}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "get_report_file_handle"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "function int get_report_file_handle( uvm_severity severity, string id )"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "Gets the file descriptor associated with reports having the given severity and id."}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "set_report_default_file"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "function void set_report_default_file ( UVM_FILE file"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "function void set_report_id_file ( string id, UVM_FILE file"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "set_report_severity_file"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "function void set_report_severity_file ( uvm_severity severity, UVM_FILE file"}
{"type": "text", "page_from": 74, "page_to": 74, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=74", "section_title": "uvm_report_object", "content": "set_report_severity_id_file"}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "These methods configure the report handler to direct some or all of its output to the given file descriptor. The file argument must be a multi-channel descriptor (mcd) or file id compatible with $\\$ 9$ fdisplay."}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "A FILE descriptor can be associated with reports of the given severity, id, or severity-id pair. A FILE associated with a particular severity-id pair takes precedence over a FILE associated with $i d ,$ , which take precedence over an a FILE associated with a severity, which takes precedence over the default FILE descriptor."}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "When a report is issued and its associated action has the UVM_LOG bit set, the report will be sent to its associated FILE descriptor. The user is responsible for opening and closing these files."}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "OvERRIdE CONFIGURATION"}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "set_report_severity_override"}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "function void set_report_severity_override( uvm_severity cur_severity, uvm_severity new_severity"}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "set_report_severity_id_override"}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "These methods provide the ability to upgrade or downgrade a message in terms of severity given severity and id. An upgrade or downgrade for a specific id takes precedence over an upgrade or downgrade associated with a severity."}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "REPORT HANdLER CONFIGURATION"}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "function void set_report_handler( uvm_report_handler handler"}
{"type": "text", "page_from": 75, "page_to": 75, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=75", "section_title": "uvm_report_object", "content": "Sets the report handler, overwriting the default instance. This allows more than one component to share the same report handler."}
{"type": "text", "page_from": 76, "page_to": 76, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=76", "section_title": "uvm_report_object", "content": "function uvm_report_handler get_report_handler()"}
{"type": "text", "page_from": 76, "page_to": 76, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=76", "section_title": "uvm_report_object", "content": "Returns the underlying report handler to which most reporting tasks are delegated."}
{"type": "text", "page_from": 76, "page_to": 76, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=76", "section_title": "uvm_report_object", "content": "reset_report_handler"}
{"type": "text", "page_from": 76, "page_to": 76, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=76", "section_title": "uvm_report_object", "content": "function void reset_report_handler"}
{"type": "text", "page_from": 76, "page_to": 76, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=76", "section_title": "uvm_report_object", "content": "Resets the underlying report handler to its default settings. This clears any settings made with the set_report_\\* methods (see below)."}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "header_path": ["6", "3"], "chapter": "6", "section": "6.3", "content": "6.3 uvm_report_handler"}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "content": "The uvm_report_handler is the class to which most methods in uvm_report_object delegate. It stores the maximum verbosity, actions, and files that affect the way reports are handled."}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "content": "The report handler is not intended for direct use. See uvm_report_object for information on the UVM reporting mechanism."}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "content": "The relationship between uvm_report_object (a base class for uvm_component) and uvm_report_handler is typically one to one, but it can be many to one if several uvm_report_objects are configured to use the same uvm_report_handler_object. See uvm_report_object::set_report_handler."}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "content": "The relationship between uvm_report_handler and uvm_report_server is many to one."}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "content": "The uvm_report_handler is the class to which most methods in uvm_report_object delegate."}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "content": "function new( string name $=$ \"uvm_report_handler\" )"}
{"type": "text", "page_from": 77, "page_to": 77, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=77", "section_title": "uvm_report_handler", "content": "Creates and initializes a new uvm_report_handler object."}
{"type": "text", "page_from": 78, "page_to": 78, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=78", "section_title": "uvm_report_handler", "content": "The uvm_report_handler implements the uvm_object::do_print() such that print method provides UVM printer formatted output of the current configuration. A snippet of example output is shown here:"}
{"type": "text", "page_from": 78, "page_to": 78, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=78", "section_title": "uvm_report_handler", "content": "process_report_message"}
{"type": "text", "page_from": 78, "page_to": 78, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=78", "section_title": "uvm_report_handler", "content": "virtual function void process_report_message( uvm_report_message report_message"}
{"type": "text", "page_from": 78, "page_to": 78, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=78", "section_title": "uvm_report_handler", "content": "This is the common handler method used by the four core reporting methods (e.g. uvm_report_error) in uvm_report_object."}
{"type": "text", "page_from": 78, "page_to": 78, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=78", "section_title": "uvm_report_handler", "content": "static function string format_action( uvm_action action"}
{"type": "text", "page_from": 78, "page_to": 78, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=78", "section_title": "uvm_report_handler", "content": "Returns a string representation of the action, e.g., “DISPLAY”."}
{"type": "text", "page_from": 79, "page_to": 79, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=79", "section_title": "UVM Report Server", "header_path": ["6", "4"], "chapter": "6", "section": "6.4", "content": "6.4 UVM Report Server"}
{"type": "text", "page_from": 79, "page_to": 79, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=79", "section_title": "uvm_report_server", "content": "This page covers the classes that define the UVM report server facility."}
{"type": "text", "page_from": 79, "page_to": 79, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=79", "section_title": "uvm_report_server", "content": "uvm_report_server is a global server that processes all of the reports generated by a uvm_report_handler."}
{"type": "text", "page_from": 79, "page_to": 79, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=79", "section_title": "uvm_report_server", "content": "The uvm_report_server is an abstract class which declares many of its methods as pure virtual. The UVM uses the uvm_default_report_server class as its default report server implementation."}
{"type": "text", "page_from": 79, "page_to": 79, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=79", "section_title": "uvm_report_server", "content": "uvm_report_server is a global server that processes all of the reports generated by a uvm_report_handler."}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "pure virtual function void set_max_quit_count( int count, bit overridable $= ~ 1$ )"}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "count is the maximum number of UVM_QUIT actions the uvm_report_server will tolerate before invoking client.die(). when overridable $= 0$ is passed, the set quit count cannot be changed again"}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "pure virtual function int get_max_quit_count()"}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "returns the currently configured max quit count"}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "pure virtual function void set_quit_count( int quit_count"}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "sets the current number of UVM_QUIT actions already passed through this uvm_report_server"}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "pure virtual function int get_quit_count()"}
{"type": "text", "page_from": 80, "page_to": 80, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=80", "section_title": "uvm_report_server", "content": "returns the current number of UVM_QUIT actions already passed through this server"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "pure virtual function void set_severity_count( uvm_severity severity, int count"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "sets the count of already passed messages with severity severity to count"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "pure virtual function int get_severity_count( uvm_severity severity"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "returns the count of already passed messages with severity severity"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "pure virtual function void set_id_count( string id, int count )"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "sets the count of already passed messages with id to count"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "pure virtual function int get_id_count( string id"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "returns the count of already passed messages with id"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "pure virtual function void get_id_set( output string q[\\$]"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "returns the set of id’s already used by this uvm_report_server"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "pure virtual function void get_severity_set( output uvm_severity q[\\$]"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "returns the set of severities already used by this uvm_report_server"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "set_message_database"}
{"type": "text", "page_from": 81, "page_to": 81, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=81", "section_title": "uvm_report_server", "content": "pure virtual function void set_message_database( uvm_tr_database database"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "sets the uvm_tr_database used for recording messages"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "get_message_database"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "pure virtual function uvm_tr_database get_message_database()"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "returns the uvm_tr_database used for recording messages"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "function void do_copy ( uvm_object rhs"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "copies all message statistic severity,id counts to the destination uvm_report_server the copy is cummulative (only items from the source are transferred, already existing entries are not deleted, existing entries/counts are overridden when they exist in the source set)"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "execute_report_message"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "pure virtual function void execute_report_message( uvm_report_message report_message, string composed_message )"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "Processes the provided message per the actions contained within."}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "Expert users can overload this method to customize action processing."}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "compose_report_message"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "pure virtual function string compose_report_message( uvm_report_message report_message, string report_object_name = \"\" )"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "Constructs the actual string sent to the file or command line from the severity, component name, report id, and the message itself."}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "Expert users can overload this method to customize report formatting."}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "pure virtual function void report_summarize( UVM_FILE file $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "Outputs statistical information on the reports issued by this central report server. This information will be sent to the command line if file is 0, or to the file descriptor file if it is not 0."}
{"type": "text", "page_from": 82, "page_to": 82, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=82", "section_title": "uvm_report_server", "content": "The run_test method in uvm_top calls this method."}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "static function void set_server( uvm_report_server server"}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "Sets the global report server to use for reporting."}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "This method is provided as a convenience wrapper around setting the report server via the uvm_coreservice_t::set_report_server method."}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "In addition to setting the server this also copies the severity/id counts from the current report_server to the new one"}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "// Using the uvm_coreservice_t: uvm_coreservice_t cs; cs $\\sqsupseteq$ uvm_coreservice_t::get(); your_server.copy(cs.get_report_server()); cs.set_report_server(your_server); // Not using the uvm_coreservice_t: uvm_report_server::set_server(your_server);"}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "static function uvm_report_server get_server()"}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "Gets the global report server used for reporting."}
{"type": "text", "page_from": 83, "page_to": 83, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=83", "section_title": "uvm_report_server", "content": "This method is provided as a convenience wrapper around retrieving the report server via the uvm_coreservice_t::get_report_server method."}
{"type": "text", "page_from": 84, "page_to": 84, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=84", "section_title": "uvm_report_server", "content": "uvm_default_report_server"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "bit enable_report_id_count_summary $^ { \\cdot = 1 }$"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "A flag to enable report count summary for each ID"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "bit record_all_messages = 0"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "A flag to force recording of all messages (add UVM_RM_RECORD action)"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "bit show_verbosity $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "A flag to include verbosity in the messages, e.g."}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "”UVM_INFO(UVM_MEDIUM) file.v(3) $@$ 60: reporter [ID0] Message 0”"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "bit show_terminator $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "A flag to add a terminator in the messages, e.g."}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "”UVM_INFO file.v(3) $@$ 60: reporter [ID0] Message 0 -UVM_INFO”"}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "function new( string name $=$ \"uvm_report_server\""}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "Creates an instance of the class."}
{"type": "text", "page_from": 85, "page_to": 85, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=85", "section_title": "uvm_report_server", "content": "The uvm_report_server implements the uvm_object::do_print() such that print method provides UVM printer formatted output of the current configuration. A snippet of example output is shown here:"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "function int get_max_quit_count()"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "function void set_max_quit_count( int count, bit overridable $= ~ 1$ )"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "Get or set the maximum number of COUNT actions that can be tolerated before a UVM_EXIT action is taken. The default is 0, which specifies no maximum."}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "function int get_quit_count()"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "function void set_quit_count( int quit_count"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "function void incr_quit_count()"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "function void reset_quit_count()"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "Set, get, increment, or reset to 0 the quit count, i.e., the number of COUNT actions issued."}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "is_quit_count_reached"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "function bit is_quit_count_reached()"}
{"type": "text", "page_from": 86, "page_to": 86, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=86", "section_title": "uvm_report_server", "content": "If is_quit_count_reached returns 1, then the quit counter has reached the maximum."}
{"type": "text", "page_from": 87, "page_to": 87, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=87", "section_title": "uvm_report_server", "content": "function int get_severity_count( uvm_severity severity"}
{"type": "text", "page_from": 87, "page_to": 87, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=87", "section_title": "uvm_report_server", "content": "function void set_severity_count( uvm_severity severity, int count )"}
{"type": "text", "page_from": 87, "page_to": 87, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=87", "section_title": "uvm_report_server", "content": "function void incr_severity_count( uvm_severity severity"}
{"type": "text", "page_from": 87, "page_to": 87, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=87", "section_title": "uvm_report_server", "content": "reset_severity_counts"}
{"type": "text", "page_from": 87, "page_to": 87, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=87", "section_title": "uvm_report_server", "content": "function void reset_severity_counts()"}
{"type": "text", "page_from": 87, "page_to": 87, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=87", "section_title": "uvm_report_server", "content": "Set, get, or increment the counter for the given severity, or reset all severity counters to 0."}
{"type": "text", "page_from": 87, "page_to": 87, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=87", "section_title": "uvm_report_server", "content": "function int get_id_count( string id"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "Set, get, or increment the counter for reports with the given id."}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "mEss AGE r EcOr DING"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "The uvm_default_report_server will record messages into the message database, using one transaction per message, and one stream per report object/handler pair."}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "set_message_database"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "virtual function void set_message_database( uvm_tr_database database"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "sets the uvm_tr_database used for recording messages"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "get_message_database"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "virtual function uvm_tr_database get_message_database()"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "returns the uvm_tr_database used for recording messages"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "MEss AGE Pr OcEss ING"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "execute_report_message"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "virtual function void execute_report_message( uvm_report_message report_message, string composed_message )"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "Processes the provided message per the actions contained within."}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "Expert users can overload this method to customize action processing."}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "compose_report_message"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "virtual function string compose_report_message( uvm_report_message report_message, string report_object_name )"}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "Constructs the actual string sent to the file or command line from the severity, component name, report id, and the message itself."}
{"type": "text", "page_from": 88, "page_to": 88, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=88", "section_title": "uvm_report_server", "content": "Expert users can overload this method to customize report formatting."}
{"type": "text", "page_from": 89, "page_to": 89, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=89", "section_title": "uvm_report_server", "content": "virtual function void report_summarize( UVM_FILE file $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 89, "page_to": 89, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=89", "section_title": "uvm_report_server", "content": "Outputs statistical information on the reports issued by this central report server. This information will be sent to the command line if file is 0, or to the file descriptor file if it is not 0."}
{"type": "text", "page_from": 89, "page_to": 89, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=89", "section_title": "uvm_report_server", "content": "The run_test method in uvm_top calls this method."}
{"type": "text", "page_from": 90, "page_to": 90, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=90", "section_title": "uvm_report_catcher", "header_path": ["6", "5"], "chapter": "6", "section": "6.5", "content": "6.5 uvm_report_catcher"}
{"type": "text", "page_from": 90, "page_to": 90, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=90", "section_title": "uvm_report_catcher", "content": "The uvm_report_catcher is used to catch messages issued by the uvm report server. Catchers are uvm_callbacks#(uvm_report_object,uvm_report_catcher) objects, so all facilities in the uvm_callback and uvm_callbacks#(T,CB) classes are available for registering catchers and controlling catcher state. The uvm_callbacks#(uvm_report_object,uvm_report_catcher) class is aliased to uvm_report_cb to make it easier to use. Multiple report catchers can be registered with a report object. The catchers can be registered as default catchers which catch all reports on all uvm_report_object reporters, or catchers can be attached to specific report objects (i.e. components)."}
{"type": "text", "page_from": 90, "page_to": 90, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=90", "section_title": "uvm_report_catcher", "content": "User extensions of uvm_report_catcher must implement the catch method in which the action to be taken on catching the report is specified. The catch method can return CAUGHT, in which case further processing of the report is immediately stopped, or return THROW in which case the (possibly modified) report is passed on to other registered catchers. The catchers are processed in the order in which they are registered."}
{"type": "text", "page_from": 90, "page_to": 90, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=90", "section_title": "uvm_report_catcher", "content": "On catching a report, the catch method can modify the severity, id, action, verbosity or the report string itself before the report is finally issued by the report server. The report can be immediately issued from within the catcher class by calling the issue method."}
{"type": "text", "page_from": 90, "page_to": 90, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=90", "section_title": "uvm_report_catcher", "content": "The catcher maintains a count of all reports with FATAL,ERROR or WARNING severity and a count of all reports with FATAL, ERROR or WARNING severity whose severity was lowered. These statistics are reported in the summary of the uvm_report_server."}
{"type": "text", "page_from": 90, "page_to": 90, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=90", "section_title": "uvm_report_catcher", "content": "This example shows the basic concept of creating a report catching callback and attaching it to all messages that get emitted:"}
{"type": "text", "page_from": 90, "page_to": 90, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=90", "section_title": "uvm_report_catcher", "content": "The uvm_report_catcher is used to catch messages issued by the uvm report se"}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "function new( string name $=$ \"uvm_report_catcher\" )"}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "Create a new report catcher. The name argument is optional, but should generally be provided to aid in debugging."}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "CURRENT MEss AGE STATE"}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "function uvm_report_object get_client()"}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "Returns the uvm_report_object that has generated the message that is currently being processed."}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "function uvm_severity get_severity()"}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "Returns the uvm_severity of the message that is currently being processed. If the severity was modified by a previously executed catcher object (which re-threw the message), then the returned severity is the modified value."}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "function string get_context()"}
{"type": "text", "page_from": 92, "page_to": 92, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=92", "section_title": "uvm_report_catcher", "content": "Returns the context name of the message that is currently being processed. This is typically the full hierarchical name of the component that issued the message. However, if user-defined context is set from a uvm_report_message, the user-defined context will be returned."}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "Returns the string id of the message that is currently being processed. If the id was modified by a previously executed catcher (which re-threw the message), then the returned id is the modified value."}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "function string get_message()"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "Returns the string message of the message that is currently being processed. If the message was modified by a previously executed catcher (which re-threw the message), then the returned message is the modified value."}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "function uvm_action get_action()"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "Returns the uvm_action of the message that is currently being processed. If the action was modified by a previously executed catcher (which re-threw the message), then the returned action is the modified value."}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "function string get_fname()"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "Returns the file name of the message."}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "function int get_line()"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "Returns the line number of the message."}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "get_element_container"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "function uvm_report_message_element_container get_element_container()"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "Returns the element container of the message."}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "ChANGE MEss AGE STATE"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "protected function void set_severity( uvm_severity severity"}
{"type": "text", "page_from": 93, "page_to": 93, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=93", "section_title": "uvm_report_catcher", "content": "Change the severity of the message to severity. Any other report catchers will see the modified value."}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "protected function void set_verbosity( int verbosity"}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "Change the verbosity of the message to verbosity. Any other report catchers will see the modified value."}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "Change the id of the message to id. Any other report catchers will see the modified value."}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "protected function void set_message( string message"}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "Change the text of the message to message. Any other report catchers will see the modified value."}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "protected function void set_action( uvm_action action"}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "Change the action of the message to action. Any other report catchers will see the modified value."}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "protected function void set_context( string context_str"}
{"type": "text", "page_from": 94, "page_to": 94, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=94", "section_title": "uvm_report_catcher", "content": "Change the context of the message to context_str. Any other report catchers will see the modified value."}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "Add an integral type of the name name and value value to the message. The required size field indicates the size of value. The required radix field determines how to display and record the field. Any other report catchers will see the newly added element."}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "protected function void add_string( string name, string value, uvm_action action $=$ (UVM_LOG|UVM_RM_RECORD)"}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "Adds a string of the name name and value value to the message. Any other report catchers will see the newly added element."}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "protected function void add_object( string name, uvm_object obj, uvm_action action $=$ (UVM_LOG|UVM_RM_RECORD)"}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "Adds a uvm_object of the name name and reference obj to the message. Any other report catchers will see the newly added element."}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "static function uvm_report_catcher get_report_catcher( string name"}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "Returns the first report catcher that has name."}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "static function void print_catcher( UVM_FILE file $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 95, "page_to": 95, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=95", "section_title": "uvm_report_catcher", "content": "Prints information about all of the report catchers that are registered. For finer grained detail, the uvm_callbacks #(T,CB)::display method can be used by calling uvm_report_cb::display(uvm_report_object)."}
{"type": "text", "page_from": 96, "page_to": 96, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=96", "section_title": "uvm_report_catcher", "content": "pure virtual function action_e catch()"}
{"type": "text", "page_from": 96, "page_to": 96, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=96", "section_title": "uvm_report_catcher", "content": "This is the method that is called for each registered report catcher. There are no arguments to this function. The Current Message State interface methods can be used to access information about the current message being processed."}
{"type": "text", "page_from": 96, "page_to": 96, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=96", "section_title": "uvm_report_catcher", "content": "protected function void uvm_report_fatal( string id, string message, int verbosity, string fname int line 0, string context_name \"\","}
{"type": "text", "page_from": 96, "page_to": 96, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=96", "section_title": "uvm_report_catcher", "content": "Issues a fatal message using the current message’s report object. This message will bypass any message catching callbacks."}
{"type": "text", "page_from": 96, "page_to": 96, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=96", "section_title": "uvm_report_catcher", "content": "Issues an error message using the current message’s report object. This message will bypass any message catching callbacks."}
{"type": "text", "page_from": 96, "page_to": 96, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=96", "section_title": "uvm_report_catcher", "content": "Issues a warning message using the current message’s report object. This message will bypass any message catching callbacks."}
{"type": "text", "page_from": 96, "page_to": 96, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=96", "section_title": "uvm_report_catcher", "content": "protected function void uvm_report_info( string id, string message,"}
{"type": "text", "page_from": 97, "page_to": 97, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=97", "section_title": "uvm_report_catcher", "content": "Issues a info message using the current message’s report object. This message will bypass any message catching callbacks."}
{"type": "text", "page_from": 97, "page_to": 97, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=97", "section_title": "uvm_report_catcher", "content": "Issues a message using the current message’s report object. This message will bypass any message catching callbacks."}
{"type": "text", "page_from": 97, "page_to": 97, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=97", "section_title": "uvm_report_catcher", "content": "protected function void issue()"}
{"type": "text", "page_from": 97, "page_to": 97, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=97", "section_title": "uvm_report_catcher", "content": "Immediately issues the message which is currently being processed. This is useful if the message is being CAUGHT but should still be emitted."}
{"type": "text", "page_from": 97, "page_to": 97, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=97", "section_title": "uvm_report_catcher", "content": "Issuing a message will update the report_server stats, possibly multiple times if the message is not CAUGHT."}
{"type": "text", "page_from": 97, "page_to": 97, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=97", "section_title": "uvm_report_catcher", "content": "static function void summarize()"}
{"type": "text", "page_from": 97, "page_to": 97, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=97", "section_title": "uvm_report_catcher", "content": "This function is called automatically by uvm_report_server::report_summarize(). It prints the statistics for the active catchers."}
{"type": "text", "page_from": 98, "page_to": 98, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=98", "section_title": "Recording Classes", "content": "7. TRANSACt ION RECORDING CLASSES"}
{"type": "text", "page_from": 98, "page_to": 98, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=98", "section_title": "Recording Classes", "content": "The recording classes provide a facility to record transactions into a database using a consistent API. Users can configure what gets sent to the backend database, without knowing exactly how the connection to that database is established."}
{"type": "text", "page_from": 98, "page_to": 98, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=98", "section_title": "Recording Classes", "content": "The primary interface to the UVM recording facility is the uvm_recorder class, which serves as a reference to the transaction in the database, as well as the policy which is used to record information into the database."}
{"type": "text", "page_from": 98, "page_to": 98, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=98", "section_title": "Recording Classes", "content": "The UVM provides a default implementation of the recording API, which creates textual logs. This is primarily intended to be used as an example of how to create a recording implementation without the user needing to have tool and/or vendor specific code in their testbench."}
{"type": "text", "page_from": 98, "page_to": 98, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=98", "section_title": "Recording Classes", "content": "Transaction Recording Classes"}
{"type": "text", "page_from": 98, "page_to": 98, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=98", "section_title": "Recording Classes", "content": "The recording classes provide a facility to record transactions into a database using a consistent API."}
{"type": "text", "page_from": 99, "page_to": 99, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=99", "section_title": "Transaction Recording Databases", "header_path": ["7", "1"], "chapter": "7", "section": "7.1", "content": "7.1 Transaction Recording Databases"}
{"type": "text", "page_from": 99, "page_to": 99, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=99", "section_title": "uvm_tr_database", "content": "The UVM “Transaction Recording Database” classes are an abstract representation of the backend tool which is recording information for the user. Usually this tool would be dumping information such that it can be viewed with the waves of the DUT."}
{"type": "text", "page_from": 99, "page_to": 99, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=99", "section_title": "uvm_tr_database", "content": "The uvm_tr_database class is intended to hide the underlying database implementation from the end user, as these details are often vendor or tool-specific."}
{"type": "text", "page_from": 99, "page_to": 99, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=99", "section_title": "uvm_tr_database", "content": "The uvm_tr_database class is pure virtual, and must be extended with an implementation. A default text-based implementation is provided via the uvm_text_tr_database class."}
{"type": "text", "page_from": 99, "page_to": 99, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=99", "section_title": "uvm_tr_database", "content": "The uvm_tr_database class is intended to hide the underlying database implementation from the end user, as these details are often vendor or toolspecific."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "function bit open_db()"}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "Open the backend connection to the database."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "If the database is already open, then this method will return 1."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "Otherwise, the method will call do_open_db, and return the result."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "function bit close_db()"}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "Closes the backend connection to the database."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "Closing a database implicitly closes and frees all uvm_tr_streams within the database."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "If the database is already closed, then this method will return 1."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "Otherwise, this method will trigger a do_close_db call, and return the result."}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "function bit is_open()"}
{"type": "text", "page_from": 100, "page_to": 100, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=100", "section_title": "uvm_tr_database", "content": "Returns the open/closed status of the database."}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "This method returns 1 if the database has been successfully opened, but not yet closed."}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "function uvm_tr_stream open_stream( string name, string scope $\\qquad = \\quad \" \" \\mathrm { ~ \\textmu ~ }$ string type_name $=$"}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "Provides a reference to a stream within the database."}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "The method returns a reference to a uvm_tr_stream object if successful, null otherwise."}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "This method will trigger a do_open_stream call, and if a non null stream is returned, then uvm_tr_stream::do_open will be called."}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "Streams can only be opened if the database is open (per is_open). Otherwise the request will be ignored, and null will be returned."}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "function unsigned get_streams( ref uvm_tr_stream q[\\$]"}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "Provides a queue of all streams within the database."}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "$q$ A reference to a queue of uvm_tr_streams"}
{"type": "text", "page_from": 101, "page_to": 101, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=101", "section_title": "uvm_tr_database", "content": "The get_streams method returns the size of the queue, such that the user can conditionally process the elements."}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "function void establish_link( uvm_link_base link"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "Establishes a link between two elements in the database"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "Links are only supported between streams and records within a single database."}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "This method will trigger a do_establish_link call."}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "IMpLEMENt At ION AGNOst Ic API"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "pure virtual protected function bit do_open_db()"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "Backend implementation of open_db"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "pure virtual protected function bit do_close_db()"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "Backend implementation of close_db"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "pure virtual protected function uvm_tr_stream do_open_stream( string name, string scope, string type_name"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "Backend implementation of open_stream"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "pure virtual protected function void do_establish_link( uvm_link_base link"}
{"type": "text", "page_from": 102, "page_to": 102, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=102", "section_title": "uvm_tr_database", "content": "Backend implementation of establish_link"}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "uvm_text_tr_database"}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "The uvm_text_tr_database is the default implementation for the uvm_tr_database."}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "IMpLEMENt At ION AGNOst Ic API"}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "function new( string name $=$ \"unnamed-uvm_text_tr_database\" )"}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "IMpLEMENt At ION AGNOst Ic API"}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "protected virtual function bit do_open_db()"}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "Open the backend connection to the database."}
{"type": "text", "page_from": 103, "page_to": 103, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=103", "section_title": "uvm_tr_database", "content": "Text-Backend implementation of uvm_tr_database::open_db."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "The text-backend will open a text file to dump all records in to. The name of this text file is controlled via set_file_name."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "This will also lock the file_name, so that it cannot be modified while the connection is open."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "protected virtual function bit do_close_db()"}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "Close the backend connection to the database."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "Text-Backend implementation of uvm_tr_database::close_db."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "The text-backend will close the text file used to dump all records in to, if it is currently opened."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "This unlocks the file_name, allowing it to be modified again."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "protected virtual function uvm_tr_stream do_open_stream( string name, string scope, string type_name"}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "Provides a reference to a stream within the database."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "Text-Backend implementation of uvm_tr_database::open_stream"}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "protected virtual function void do_establish_link( uvm_link_base link"}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "Establishes a link between two elements in the database"}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "Text-Backend implementation of uvm_tr_database::establish_link."}
{"type": "text", "page_from": 104, "page_to": 104, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=104", "section_title": "uvm_tr_database", "content": "IMpLEMENt At ION SpEcIFIc API"}
{"type": "text", "page_from": 105, "page_to": 105, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=105", "section_title": "Transaction Recording Streams", "header_path": ["7", "2"], "chapter": "7", "section": "7.2", "content": "7.2 Transaction Recording Streams"}
{"type": "text", "page_from": 105, "page_to": 105, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=105", "section_title": "uvm_tr_stream", "content": "The uvm_tr_stream base class is a representation of a stream of records within a uvm_tr_database."}
{"type": "text", "page_from": 105, "page_to": 105, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=105", "section_title": "uvm_tr_stream", "content": "The record stream is intended to hide the underlying database implementation from the end user, as these details are often vendor or tool-specific."}
{"type": "text", "page_from": 105, "page_to": 105, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=105", "section_title": "uvm_tr_stream", "content": "The uvm_tr_stream class is pure virtual, and must be extended with an implementation. A default text-based implementation is provided via the uvm_text_tr_stream class."}
{"type": "text", "page_from": 105, "page_to": 105, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=105", "section_title": "uvm_tr_stream", "content": "The uvm_tr_stream base class is a representation of a stream of records within a uvm_tr_database."}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "function new( string name $=$ \"unnamed-uvm_tr_stream\" )"}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "name Stream instance name"}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "function uvm_tr_database get_db()"}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "Returns a reference to the database which contains this stream."}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "A warning will be asserted if get_db is called prior to the stream being initialized via do_open."}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "function string get_scope()"}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "Returns the scope supplied when opening this stream."}
{"type": "text", "page_from": 106, "page_to": 106, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=106", "section_title": "uvm_tr_stream", "content": "A warning will be asserted if get_scope is called prior to the stream being initialized via do_open."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "get_stream_type_name"}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "function string get_stream_type_name()"}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "Returns a reference to the database which contains this stream."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "A warning will be asserted if get_stream_type_name is called prior to the stream being initialized via do_open."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "Once a stream has been opened via uvm_tr_database::open_stream, the user can close the stream."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "Due to the fact that many database implementations will require crossing a language boundary, an additional step of freeing the stream is required."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "A link can be established within the database any time between “Open” and “Free”, however it is illegal to establish a link after “Freeing” the stream."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "function void close()"}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "Closing a stream closes all open recorders in the stream."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "This method will trigger a do_close call, followed by uvm_recorder::close on all open recorders within the stream."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "function void free()"}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "Freeing a stream indicates that the database can free any references to the stream (including references to records within the stream)."}
{"type": "text", "page_from": 107, "page_to": 107, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=107", "section_title": "uvm_tr_stream", "content": "This method will trigger a do_free call, followed by uvm_recorder::free on all recorders within the stream."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "function bit is_closed()"}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "Returns true if this uvm_tr_stream was closed on the database, but has not yet been freed."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "Tr ANsAct ION REcOrd Er API"}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "New recorders can be opened prior to the stream being closed."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "Once a stream has been closed, requests to open a new recorder will be ignored (open_recorder will return null)."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "function uvm_recorder open_recorder( string name, time open_time $\\begin{array} { r l } { = { } } & { { } 0 , } \\end{array}$ string type_name = \"\""}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "Marks the opening of a new transaction recorder on the stream."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "name A name for the new transaction open_time Optional time to record as the opening of this transaction type_name Optional type name for the transaction"}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "If open_time is omitted (or set to 0), then the stream will use the current time."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "This method will trigger a do_open_recorder call. If do_open_recorder returns a non-null value, then the uvm_recorder::do_open method will be called in the recorder."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "Transaction recorders can only be opened if the stream is open on the database (per is_open). Otherwise the request will be ignored, and null will be returned."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "function unsigned get_recorders( ref uvm_recorder q[\\$]"}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "Provides a queue of all transactions within the stream."}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "$q$ A reference to the queue of uvm_recorders"}
{"type": "text", "page_from": 108, "page_to": 108, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=108", "section_title": "uvm_tr_stream", "content": "The get_recorders method returns the size of the queue, such that the user can conditionally process the elements."}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "function integer get_handle()"}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "Returns a unique ID for this stream."}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "A value of $o$ indicates that the recorder has been freed, and no longer has a valid ID."}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "get_stream_from_handle"}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "Static accessor, returns a stream reference for a given unique id."}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "If no stream exists with the given id, or if the stream with that id has been freed, then null is returned."}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "IMpLEMENt At ION AGNOst Ic API"}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "Callback triggered via uvm_tr_database::open_stream."}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "db Database which the stream belongs to scope Optional scope stream_type_name Optional type name for the stream"}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "The do_open callback can be used to initialize any internal state within the stream, as well as providing a location to record any initial information about the stream."}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "protected virtual function void do_close()"}
{"type": "text", "page_from": 109, "page_to": 109, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=109", "section_title": "uvm_tr_stream", "content": "Callback triggered via close."}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "The do_close callback can be used to set internal state within the stream, as well as providing a location to record any closing information."}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "protected virtual function void do_free()"}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "Callback triggered via free."}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "The do_free callback can be used to release the internal state within the stream, as well as providing a location to record any “freeing” information."}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "protected virtual function uvm_recorder do_open_recorder( string name, time open_time, string type_name"}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "Marks the beginning of a new record in the stream."}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "Backend implementation of open_recorder"}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "The uvm_text_tr_stream is the default stream implementation for the uvm_text_tr_database."}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "The uvm_text_tr_stream is the default stream implementation for the uvm_text_tr_database."}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "class uvm_text_tr_stream extends uvm_tr_stream"}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "IMpLEMENt At ION AGNOst Ic"}
{"type": "text", "page_from": 110, "page_to": 110, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=110", "section_title": "uvm_tr_stream", "content": "do_open Callback triggered via uvm_tr_database::open_stream. do_close Callback triggered via uvm_tr_stream::close. do_free Callback triggered via uvm_tr_stream::free."}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "IMpLEMENt At ION AGNOst Ic API"}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "do_open protected virtual function void do_open( uvm_tr_database db, string scope, string stream_type_name"}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "Callback triggered via uvm_tr_database::open_stream."}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "protected virtual function void do_close()"}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "Callback triggered via uvm_tr_stream::close."}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "protected virtual function void do_free()"}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "Callback triggered via uvm_tr_stream::free."}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "protected virtual function uvm_recorder do_open_recorder( string name, time open_time, string type_name"}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "Marks the beginning of a new record in the stream"}
{"type": "text", "page_from": 111, "page_to": 111, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=111", "section_title": "uvm_tr_stream", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 112, "page_to": 112, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=112", "section_title": "Factory Classes", "content": "As the name implies, the uvm_factory is used to manufacture (create) UVM objects and components. Only one instance of the factory is present in a given simulation."}
{"type": "text", "page_from": 112, "page_to": 112, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=112", "section_title": "Factory Classes", "content": "User-defined object and component types are registered with the factory via typedef or macro invocation, as explained in uvm_default_factory::Usage. The factory generates and stores lightweight proxies to the user-defined objects and components: uvm_object_registry #(T,Tname) for objects and uvm_component_registry #(T,Tname) for components. Each proxy only knows how to create an instance of the object or component it represents, and so is very efficient in terms of memory usage."}
{"type": "text", "page_from": 112, "page_to": 112, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=112", "section_title": "Factory Classes", "content": "When the user requests a new object or component from the factory (e.g. uvm_factory::create_object_by_type), the factory will determine what type of object to create based on its configuration, then ask that type’s proxy to create an instance of the type, which is returned to the user."}
{"type": "text", "page_from": 112, "page_to": 112, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=112", "section_title": "Factory Classes", "content": "As the name implies, the uvm_factory is used to manufacture (create) UVM objects and components."}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "Factory Component and Object Wrappers", "header_path": ["8", "1"], "chapter": "8", "section": "8.1", "content": "8.1 Factory Component and Object Wrappers"}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "Factory Component and Object Wrappers"}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "This section defines the proxy component and object classes used by the factory. To avoid the overhead of creating an instance of every component and object that get registered, the factory holds lightweight wrappers, or proxies. When a request for a new object is made, the factory calls upon the proxy to create the object it represents."}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "uvm_component_registry #(T,Tname)"}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "The uvm_component_registry serves as a lightweight proxy for a component of type $\\tau$ and type name Tname, a string. The proxy enables efficient registration with the uvm_factory. Without it, registration would require an instance of the component itself."}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "See Usage section below for information on using uvm_component_registry."}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "uvm_component_registry #(T,Tname)"}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "The uvm_component_registry serves as a lightweight proxy for a component of type T and type name Tname, a string."}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "class uvm_component_registry #( type T $=$ uvm_component, string Tname $=$ \"<unknown>\" ) extends uvm_object_wrapper"}
{"type": "text", "page_from": 113, "page_to": 113, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=113", "section_title": "uvm_registry", "content": "create_component Creates a component of type T having the provided name and parent. get_type_name Returns the value given by the string parameter,"}
{"type": "text", "page_from": 114, "page_to": 114, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=114", "section_title": "uvm_registry", "content": "virtual function uvm_component create_component ( string name, uvm_component parent"}
{"type": "text", "page_from": 114, "page_to": 114, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=114", "section_title": "uvm_registry", "content": "Creates a component of type T having the provided name and parent. This is an override of the method in uvm_object_wrapper. It is called by the factory after determining the type of object to create. You should not call this method directly. Call create instead."}
{"type": "text", "page_from": 114, "page_to": 114, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=114", "section_title": "uvm_registry", "content": "virtual function string get_type_name()"}
{"type": "text", "page_from": 114, "page_to": 114, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=114", "section_title": "uvm_registry", "content": "Returns the value given by the string parameter, Tname. This method overrides the method in uvm_object_wrapper."}
{"type": "text", "page_from": 114, "page_to": 114, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=114", "section_title": "uvm_registry", "content": "static function this_type get()"}
{"type": "text", "page_from": 114, "page_to": 114, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=114", "section_title": "uvm_registry", "content": "Returns the singleton instance of this type. Type-based factory operation depends on there being a single proxy instance for each registered type."}
{"type": "text", "page_from": 114, "page_to": 114, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=114", "section_title": "uvm_registry", "content": "Returns an instance of the component type, $T ,$ represented by this proxy, subject to any factory overrides based on the context provided by the parent’s full name. The contxt argument, if supplied, supersedes the parent’s context. The new instance will have the"}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "given leaf name and parent."}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "static function void set_type_override ( uvm_object_wrapper override_type, bit replace"}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "Configures the factory to create an object of the type represented by override_type whenever a request is made to create an object of the type, $T ,$ represented by this proxy, provided no instance override applies. The original type, $T ,$ is typically a super class of the override type."}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "Configures the factory to create a component of the type represented by override_type whenever a request is made to create an object of the type, $T ,$ represented by this proxy, with matching instance paths. The original type, $T ,$ is typically a super class of the override type."}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "If parent is not specified, inst_path is interpreted as an absolute instance path, which enables instance overrides to be set from outside component classes. If parent is specified, inst_path is interpreted as being relative to the parent’s hierarchical instance path, i.e. {parent.get_full_name(),”.”,inst_path} is the instance path that is registered with the override. The inst_path may contain wildcards for matching against multiple contexts."}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "uvm_object_registry #(T,Tname)"}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "The uvm_object_registry serves as a lightweight proxy for a uvm_object of type $\\tau$ and type name Tname, a string. The proxy enables efficient registration with the uvm_factory. Without it, registration would require an instance of the object itself."}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "See Usage section below for information on using uvm_component_registry."}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "uvm_object_registry #(T,Tname)"}
{"type": "text", "page_from": 115, "page_to": 115, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=115", "section_title": "uvm_registry", "content": "The uvm_object_registry serves as a lightweight proxy for a uvm_object of type T and type name Tname, a string."}
{"type": "text", "page_from": 116, "page_to": 116, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=116", "section_title": "uvm_registry", "content": "virtual function uvm_object create_object( string name $=$"}
{"type": "text", "page_from": 116, "page_to": 116, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=116", "section_title": "uvm_registry", "content": "Creates an object of type $\\tau$ and returns it as a handle to a uvm_object. This is an override of the method in uvm_object_wrapper. It is called by the factory after determining the type of object to create. You should not call this method directly. Call create instead."}
{"type": "text", "page_from": 116, "page_to": 116, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=116", "section_title": "uvm_registry", "content": "virtual function string get_type_name()"}
{"type": "text", "page_from": 116, "page_to": 116, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=116", "section_title": "uvm_registry", "content": "Returns the value given by the string parameter, Tname. This method overrides the method in uvm_object_wrapper."}
{"type": "text", "page_from": 116, "page_to": 116, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=116", "section_title": "uvm_registry", "content": "static function this_type get()"}
{"type": "text", "page_from": 116, "page_to": 116, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=116", "section_title": "uvm_registry", "content": "Returns the singleton instance of this type. Type-based factory operation depends on there being a single proxy instance for each registered type."}
{"type": "text", "page_from": 116, "page_to": 116, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=116", "section_title": "uvm_registry", "content": "static function T createstring name $=$ uvm_component parent $=$ null,string contxt $=$ ）"}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "Returns an instance of the object type, $T ,$ represented by this proxy, subject to any factory overrides based on the context provided by the parent’s full name. The contxt argument, if supplied, supersedes the parent’s context. The new instance will have the given leaf name, if provided."}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "static function void set_type_override ( uvm_object_wrapper override_type, bit replace = 1 )"}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "Configures the factory to create an object of the type represented by override_type whenever a request is made to create an object of the type represented by this proxy, provided no instance override applies. The original type, $T ,$ is typically a super class of the override type."}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "Configures the factory to create an object of the type represented by override_type whenever a request is made to create an object of the type represented by this proxy, with matching instance paths. The original type, $T ,$ is typically a super class of the override type."}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "If parent is not specified, inst_path is interpreted as an absolute instance path, which enables instance overrides to be set from outside component classes. If parent is specified, inst_path is interpreted as being relative to the parent’s hierarchical instance path, i.e. {parent.get_full_name(),”.”,inst_path} is the instance path that is registered with the override. The inst_path may contain wildcards for matching against multiple contexts."}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "This section describes usage for the uvm_\\*_registry classes."}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "The wrapper classes are used to register lightweight proxies of objects and components."}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "To register a particular component type, you need only typedef a specialization of its proxy class, which is typically done inside the class."}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "For example, to register a UVM component of type mycomp"}
{"type": "text", "page_from": 117, "page_to": 117, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=117", "section_title": "uvm_registry", "content": "However, because of differences between simulators, it is necessary to use a macro to ensure vendor interoperability with factory registration. To register a UVM component of type mycomp in a vendor-independent way, you would write instead:"}
{"type": "text", "page_from": 118, "page_to": 118, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=118", "section_title": "uvm_registry", "content": "The \\`uvm_component_utils macro is for non-parameterized classes. In this example, the typedef underlying the macro specifies the Tname parameter as “mycomp”, and mycomp’s get_type_name() is defined to return the same. With Tname defined, you can use the factory’s name-based methods to set overrides and create objects and components of non-parameterized types."}
{"type": "text", "page_from": 118, "page_to": 118, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=118", "section_title": "uvm_registry", "content": "For parameterized types, the type name changes with each specialization, so you cannot specify a Tname inside a parameterized class and get the behavior you want; the same type name string would be registered for all specializations of the class! (The factory would produce warnings for each specialization beyond the first.) To avoid the warnings and simulator interoperability issues with parameterized classes, you must register parameterized classes with a different macro."}
{"type": "text", "page_from": 118, "page_to": 118, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=118", "section_title": "uvm_registry", "content": "For example, to register a UVM component of type driver #(T), you would write:"}
{"type": "text", "page_from": 118, "page_to": 118, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=118", "section_title": "uvm_registry", "content": "The \\`uvm_component_param_utils and \\`uvm_object_param_utils macros are used to register parameterized classes with the factory. Unlike the non-param versions, these macros do not specify the Tname parameter in the underlying uvm_component_registry typedef, and they do not define the get_type_name method for the user class. Consequently, you will not be able to use the factory’s name-based methods for parameterized classes."}
{"type": "text", "page_from": 118, "page_to": 118, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=118", "section_title": "uvm_registry", "content": "The primary purpose for adding the factory’s type-based methods was to accommodate registration of parameterized types and eliminate the many sources of errors associated with string-based factory usage. Thus, use of name-based lookup in uvm_factory is no longer recommended."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "This page covers the classes that define the UVM factory facility."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "As the name implies, uvm_factory is used to manufacture (create) UVM objects and components. Object and component types are registered with the factory using lightweight proxies to the actual objects and components being created. The uvm_object_registry #(T,Tname) and uvm_component_registry #(T,Tname) class are used to proxy uvm_objects and uvm_components."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "The factory provides both name-based and type-based interfaces."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "type-based The type-based interface is far less prone to errors in usage. When errors do occur, they are caught at compile-time. name-based The name-based interface is dominated by string arguments that can be misspelled and provided in the wrong order. Errors in name-based requests might only be caught at the time of the call, if at all. Further, the name-based interface is not portable across simulators when used with parameterized classes."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "The uvm_factory is an abstract class which declares many of its methods as pure virtual. The UVM uses the uvm_default_factory class as its default factory implementation."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "See uvm_default_factory::Usage section for details on configuring and using the factory."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "As the name implies, uvm_factory is used to manufacture (create) UVM objects and components."}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "virtual class uvm_factory"}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "RETRIEvING THE f AcTORY get REGIsTERING TYPEs register"}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "Static accessor for uvm_factory"}
{"type": "text", "page_from": 119, "page_to": 119, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=119", "section_title": "uvm_factory", "content": "Registers the given proxy object, obj, with"}
{"type": "text", "page_from": 120, "page_to": 120, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=120", "section_title": "uvm_factory", "content": "static function uvm_factory get()"}
{"type": "text", "page_from": 120, "page_to": 120, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=120", "section_title": "uvm_factory", "content": "Static accessor for uvm_factory"}
{"type": "text", "page_from": 120, "page_to": 120, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=120", "section_title": "uvm_factory", "content": "The static accessor is provided as a convenience wrapper around retrieving the factory via the uvm_coreservice_t::get_factory method."}
{"type": "text", "page_from": 120, "page_to": 120, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=120", "section_title": "uvm_factory", "content": "// Using the uvm_coreservice_t: uvm_coreservice_t cs; uvm_factory f; cs $\\sqsupseteq$ uvm_coreservice_t::get(); f $=$ cs.get_factory();"}
{"type": "text", "page_from": 120, "page_to": 120, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=120", "section_title": "uvm_factory", "content": "// Not using the uvm_coreservice_t: uvm factory f; f $= ^ { - }$ uvm_factory::get();"}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "pure virtual function void register uvm_object_wrapper obj )"}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "Registers the given proxy object, obj, with the factory. The proxy object is a lightweight substitute for the component or object it represents. When the factory needs to create an object of a given type, it calls the proxy’s create_object or create_component method to do so."}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "When doing name-based operations, the factory calls the proxy’s get_type_name method to match against the requested_type_name argument in subsequent calls to create_component_by_name and create_object_by_name. If the proxy object’s get_type_name method returns the empty string, name-based lookup is effectively disabled."}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "TYPE & INsTANcE OvERRIdEs"}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "set_inst_override_by_type"}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "set_inst_override_by_name"}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "pure virtual function void set_inst_override_by_name ( string original_type_name, string override_type_name, string full_inst_path"}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "Configures the factory to create an object of the override’s type whenever a request is made to create an object of the original type using a context that matches full_inst_path. The original type is typically a super class of the override type."}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "When overriding by type, the original_type and override_type are handles to the types’ proxy objects. Preregistration is not required."}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "When overriding by name, the original_type_name typically refers to a preregistered type in the factory. It may, however, be any arbitrary string. Future calls to any of the create_\\* methods with the same string and matching instance path will produce the type represented by override_type_name, which must be preregistered with the factory."}
{"type": "text", "page_from": 121, "page_to": 121, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=121", "section_title": "uvm_factory", "content": "The full_inst_path is matched against the concatenation of $\\{ p a r e n t \\_ i n s t \\_ p a t h , \\ \" , \\ n a m e \\}$ provided in future create requests. The full_inst_path may include wildcards ( $^ *$ and ?) such that a single instance override can be applied in multiple contexts. A full_inst_path of $\\mathbf { u } \\ast \\pmb { \\prime } \\pmb { \\prime }$ is effectively a type override, as it will match all contexts."}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "When the factory processes instance overrides, the instance queue is processed in order of override registrations, and the first override match prevails. Thus, more specific overrides should be registered first, followed by more general overrides."}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "set_type_override_by_type"}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "set_type_override_by_name"}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "pure virtual function void set_type_override_by_name string original_type_name, string override_type_name, bit replace )"}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "Configures the factory to create an object of the override’s type whenever a request is made to create an object of the original type, provided no instance override applies. The original type is typically a super class of the override type."}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "When overriding by type, the original_type and override_type are handles to the types’ proxy objects. Preregistration is not required."}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "When overriding by name, the original_type_name typically refers to a preregistered type in the factory. It may, however, be any arbitrary string. Future calls to any of the create_\\* methods with the same string and matching instance path will produce the type represented by override_type_name, which must be preregistered with the factory."}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "When replace is 1, a previous override on original_type_name is replaced, otherwise a previous override, if any, remains intact."}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "create_object_by_type"}
{"type": "text", "page_from": 122, "page_to": 122, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=122", "section_title": "uvm_factory", "content": "create_component_by_type"}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "create_object_by_name"}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "pure virtual function uvm_object create_object_by_name ( string requested_type_name, string parent_inst_path string name"}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "create_component_by_name"}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "Creates and returns a component or object of the requested type, which may be specified by type or by name. A requested component must be derived from the uvm_component base class, and a requested object must be derived from the uvm_object base class."}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "When requesting by type, the requested_type is a handle to the type’s proxy object. Preregistration is not required."}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "When requesting by name, the request_type_name is a string representing the requested type, which must have been registered with the factory with that name prior to the request. If the factory does not recognize the requested_type_name, an error is produced and a null handle returned."}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "If the optional parent_inst_path is provided, then the concatenation, {parent_inst_path, “.”,\\~name\\~}, forms an instance path (context) that is used to search for an instance override. The parent_inst_path is typically obtained by calling the uvm_component::get_full_name on the parent."}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "If no instance override is found, the factory then searches for a type override."}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "Once the final override is found, an instance of that component or object is returned in place of the requested type. New components will have the given name and parent. New objects will have the given name, if provided."}
{"type": "text", "page_from": 123, "page_to": 123, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=123", "section_title": "uvm_factory", "content": "Override searches are recursively applied, with instance overrides taking precedence over type overrides. If foo overrides bar, and xyz overrides foo, then a request for bar will produce xyz. Recursive loops will result in an error, in which case the type returned will be that which formed the loop. Using the previous example, if bar overrides xyz, then bar is returned after the error is issued."}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "debug_create_by_name"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "pure virtual function void debug_create_by_name ( string requested_type_name, string parent_inst_path string name"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "These methods perform the same search algorithm as the create_\\* methods, but they do not create new objects. Instead, they provide detailed information about what type of object it would return, listing each override that was applied to arrive at the result. Interpretation of the arguments are exactly as with the create_\\* methods."}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "find_override_by_type"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "pure virtual function uvm_object_wrapper find_override_by_type ( uvm_object_wrapper requested_type, string full_inst_path"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "find_override_by_name"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "pure virtual function uvm_object_wrapper find_override_by_name ( string requested_type_name, string full_inst_path"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "These methods return the proxy to the object that would be created given the arguments. The full_inst_path is typically derived from the parent’s instance path and the leaf name of the object to be created, i.e. { parent.get_full_name(), “.”, name $\\}$"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "find_wrapper_by_name"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "pure virtual function uvm_object_wrapper find_wrapper_by_name string type_name"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "This method returns the uvm_object_wrapper associated with a given type_name."}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "pure virtual function void print ( int all_types $= 1$"}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "Prints the state of the uvm_factory, including registered types, instance overrides, and type overrides."}
{"type": "text", "page_from": 124, "page_to": 124, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=124", "section_title": "uvm_factory", "content": "When all_types is 0, only type and instance overrides are displayed. When all_types is 1 (default), all registered user-defined types are printed as well, provided they have names associated with them. When all_types is 2, the UVM types (prefixed with uvm_) are included in the list of registered types."}
{"type": "text", "page_from": 125, "page_to": 125, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=125", "section_title": "uvm_factory", "content": "Default implementation of the UVM factory."}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "Registers the given proxy object, obj, with the factory."}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "TYPE & INsTANcE OvERRIdEs"}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "set_inst_override_by_type"}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "set_inst_override_by_name"}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "virtual function void set_inst_override_by_name ( string original_type_name, string override_type_name, string full_inst_path"}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "Configures the factory to create an object of the override’s type whenever a request is made to create an object of the original type using a context that matches full_inst_path."}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "set_type_override_by_type"}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "set_type_override_by_name"}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "virtual function void set_type_override_by_name ( string original_type_name, string override_type_name, bit replace = 1"}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "Configures the factory to create an object of the override’s type whenever a request is made to create an object of the original type, provided no instance override applies."}
{"type": "text", "page_from": 126, "page_to": 126, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=126", "section_title": "uvm_factory", "content": "create_object_by_type"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "create_component_by_type"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "create_object_by_name"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "virtual function uvm_object create_object_by_name ( string requested_type_name, string parent_inst_path string name"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "create_component_by_name"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "Creates and returns a component or object of the requested type, which may be specified by type or by name."}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "debug_create_by_type"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "debug_create_by_name"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "virtual function void debug_create_by_name ( string requested_type_name, string parent_inst_path \"\", string name )"}
{"type": "text", "page_from": 127, "page_to": 127, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=127", "section_title": "uvm_factory", "content": "These methods perform the same search algorithm as the create_\\* methods, but they do not create new objects."}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "find_override_by_type"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "virtual function uvm_object_wrapper find_override_by_type ( uvm_object_wrapper requested_type, string full_inst_path"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "find_override_by_name"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "virtual function uvm_object_wrapper find_override_by_name ( string requested_type_name, string full_inst_path"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "These methods return the proxy to the object that would be created given the arguments."}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "virtual function void print ( int all_types $= 1$"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "Prints the state of the uvm_factory, including registered types, instance overrides, and type overrides."}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "Using the factory involves three basic operations"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "Registering objects and components types with the factory 2 Designing components to use the factory to create objects or components 3 Configuring the factory with type and instance overrides, both within and outside components", "header_path": ["1"], "chapter": "1", "content": "1 Registering objects and components types with the factory 2 Designing components to use the factory to create objects or components 3 Configuring the factory with type and instance overrides, both within and outside components"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "We’ll briefly cover each of these steps here. More reference information can be found at Utility Macros, uvm_component_registry #(T,Tname), uvm_object_registry #(T,Tname), uvm_component."}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "-- Registering objects and component types with the factory", "header_path": ["1"], "chapter": "1", "content": "1 -- Registering objects and component types with the factory"}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "When defining uvm_object and uvm_component-based classes, simply invoke the appropriate macro. Use of macros are required to ensure portability across different vendors’ simulators."}
{"type": "text", "page_from": 128, "page_to": 128, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=128", "section_title": "uvm_factory", "content": "Objects that are not parameterized are declared as"}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "Objects that are parameterized are declared as"}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "Components that are not parameterized are declared as"}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "Components that are parameterized are declared as"}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "The \\`uvm_\\*_utils macros for simple, non-parameterized classes will register the type with the factory and define the get_type, get_type_name, and create virtual methods inherited from uvm_object. It will also define a static type_name variable in the class, which will allow you to determine the type without having to allocate an instance."}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "The \\`uvm_\\*_param_utils macros for parameterized classes differ from \\`uvm_\\*_utils classes in the following ways:"}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "The get_type_name method and static type_name variable are not defined. You will need to implement these manually. A type name is not associated with the type when registering with the factory, so the factory’s \\*_by_name operations will not work with parameterized classes. The factory’s print, debug_create_by_type, and debug_create_by_name methods, which depend on type names to convey information, will list parameterized types as ‘<unknown>’."}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "It is worth noting that environments that exclusively use the type-based factory methods (\\*_by_type) do not require type registration. The factory’s type-based methods will register the types involved “on the fly,” when first used. However, registering with the \\`uvm_\\*_utils macros enables name-based factory usage and implements some useful utility functions."}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "-- Designing components that defer creation to the factory", "header_path": ["2"], "chapter": "2", "content": "2 -- Designing components that defer creation to the factory"}
{"type": "text", "page_from": 129, "page_to": 129, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=129", "section_title": "uvm_factory", "content": "Having registered your objects and components with the factory, you can now make requests for new objects and components via the factory. Using the factory instead of allocating them directly (via new) allows different objects to be substituted for the original without modifying the requesting class. The following code defines a driver class that is parameterized."}
{"type": "text", "page_from": 130, "page_to": 130, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=130", "section_title": "uvm_factory", "content": "For purposes of illustrating type and instance overrides, we define two subtypes of the driverB class. The subtypes are also parameterized, so we must again provide an implementation for uvm_object::get_type_name, which we recommend writing in terms of a static string constant."}
{"type": "text", "page_from": 130, "page_to": 130, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=130", "section_title": "uvm_factory", "content": "Next, we’ll define a agent component, which requires a utils macro for nonparameterized types. Before creating the drivers using the factory, we override driver0’s packet type to be packetD."}
{"type": "text", "page_from": 131, "page_to": 131, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=131", "section_title": "uvm_factory", "content": "Finally we define an environment class, also not parameterized. Its build_phase method shows three methods for setting an instance override on a grandchild component with relative path name, agent1.driver1, all equivalent."}
{"type": "text", "page_from": 131, "page_to": 131, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=131", "section_title": "-- Configuring the factory with type and instance overrides", "header_path": ["3"], "chapter": "3", "content": "3 -- Configuring the factory with type and instance overrides"}
{"type": "text", "page_from": 131, "page_to": 131, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=131", "section_title": "uvm_factory", "content": "In the previous step, we demonstrated setting instance overrides and creating components using the factory within component classes. Here, we will demonstrate setting overrides from outside components, as when initializing the environment prior to running the test."}
{"type": "text", "page_from": 132, "page_to": 132, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=132", "section_title": "uvm_factory", "content": "When the above example is run, the resulting topology (displayed via a call to uvm_root::print_topology in env’s uvm_component::end_of_elaboration_phase method) is similar to the following:"}
{"type": "text", "page_from": 132, "page_to": 132, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=132", "section_title": "uvm_factory", "content": "The uvm_object_wrapper provides an abstract interface for creating object and component proxies. Instances of these lightweight proxies, representing every uvm_object-based and uvm_component-based object available in the test environment, are registered with the uvm_factory. When the factory is called upon to create an object or component, it finds and delegates the request to the appropriate proxy."}
{"type": "text", "page_from": 132, "page_to": 132, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=132", "section_title": "uvm_factory", "content": "The uvm_object_wrapper provides an abstract interface for creating object and component proxies."}
{"type": "text", "page_from": 132, "page_to": 132, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=132", "section_title": "uvm_factory", "content": "virtual class uvm_object_wrapper"}
{"type": "text", "page_from": 133, "page_to": 133, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=133", "section_title": "uvm_factory", "content": "virtual function uvm_object create_object ( string name $=$"}
{"type": "text", "page_from": 133, "page_to": 133, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=133", "section_title": "uvm_factory", "content": "Creates a new object with the optional name. An object proxy (e.g., uvm_object_registry #(T,Tname)) implements this method to create an object of a specific type, T."}
{"type": "text", "page_from": 133, "page_to": 133, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=133", "section_title": "uvm_factory", "content": "virtual function uvm_component create_component ( string name, uvm_component parent )"}
{"type": "text", "page_from": 133, "page_to": 133, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=133", "section_title": "uvm_factory", "content": "Creates a new component, passing to its constructor the given name and parent. A component proxy (e.g. uvm_component_registry #(T,Tname)) implements this method to create a component of a specific type, T."}
{"type": "text", "page_from": 133, "page_to": 133, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=133", "section_title": "uvm_factory", "content": "pure virtual function string get_type_name()"}
{"type": "text", "page_from": 133, "page_to": 133, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=133", "section_title": "uvm_factory", "content": "Derived classes implement this method to return the type name of the object created by create_component or create_object. The factory uses this name when matching against the requested type in name-based lookups."}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "UVM implements an automated mechanism for phasing the execution of the various components in a testbench."}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "UVM implements an automated mechanism for phasing the execution of the various components in a testbench."}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "Phasing Implementation"}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "The API described here provides a general purpose testbench phasing solution, consisting of a phaser machine, traversing a master schedule graph, which is built by the integrator from one or more instances of template schedules provided by UVM or by 3rd-party VIP, and which supports implicit or explicit synchronization, runtime control of threads and jumps."}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "Each schedule leaf node refers to a single phase that is compatible with that VIP’s components and which executes the required behavior via a functor or delegate extending the phase into component context as required."}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "Execution threads are tracked on a per-component basis."}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "A single class represents both the definition, the state, and the context of a phase. It is instantiated once as a singleton IMP and one or more times as nodes in a graph which represents serial and parallel phase relationships and stores current state as the phaser progresses, and the phase implementation which specifies required component behavior (by extension into component context if non-default behavior required.)"}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "The following classes related to phasing are defined herein"}
{"type": "text", "page_from": 134, "page_to": 134, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=134", "section_title": "Phasing", "content": "uvm_phase : The base class for defining a phase’s behavior, state, context"}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "uvm_domain : Phasing schedule node representing an independent branch of the schedule"}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "uvm_bottomup_phase : A phase implementation for bottom up function phases."}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "uvm_topdown_phase : A phase implementation for topdown function phases."}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "uvm_task_phase : A phase implementation for task phases."}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "Common, Run-Time and User-Defined Phases"}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "The common phases to all uvm_components are described in UVM Common Phases."}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "The run-time phases are described in UVM Run-Time Phases."}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "The ability to create user-defined phases is described User-Defined Phases."}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "Phasing Implementation"}
{"type": "text", "page_from": 135, "page_to": 135, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=135", "section_title": "Phasing", "content": "The API described here provides a general purpose testbench phasing solution, consisting of a phaser machine, traversing a master schedule graph, which is built by the integrator from one or more instances of template schedules provided by UVM or by 3rd-party VIP, and which supports implicit or explicit synchronization, runtime control of threads and jumps."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "Phasing Definition classes", "header_path": ["9", "1"], "chapter": "9", "section": "9.1", "content": "9.1 Phasing Definition classes"}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "The following class are used to specify a phase and its implied functionality."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "This base class defines everything about a phase: behavior, state, and context."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "To define behavior, it is extended by UVM or the user to create singleton objects which capture the definition of what the phase does and how it does it. These are then cloned to produce multiple nodes which are hooked up in a graph structure to provide context: which phases follow which, and to hold the state of the phase throughout its lifetime. UVM provides default extensions of this class for the standard runtime phases. VIP Providers can likewise extend this class to define the phase functor for a particular component context as required."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "This base class defines everything about a phase: behavior, state, and context."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "To define behavior, it is extended by UVM or the user to create singleton objects which capture the definition of what the phase does and how it does it. These are then cloned to produce multiple nodes which are hooked up in a graph structure to provide context: which phases follow which, and to hold the state of the phase throughout its lifetime. UVM provides default extensions of this class for the standard runtime phases. VIP Providers can likewise extend this class to define the phase functor for a particular component context as required."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "Singleton instances of those extensions are provided as package variables. These instances define the attributes of the phase (not what state it is in) They are then cloned into schedule nodes which point back to one of these implementations, and calls its virtual task or function methods on each participating component. It is the base class for phase functors, for both predefined and user-defined phases. Per-component overrides can use a customized imp."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "To create custom phases, do not extend uvm_phase directly: see the three predefined extended classes below which encapsulate behavior for different phase types: task, bottom-up function and top-down function."}
{"type": "text", "page_from": 136, "page_to": 136, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=136", "section_title": "uvm_phase", "content": "Extend the appropriate one of these to create a uvm_YOURNAME_phase class (or YOURPREFIX_NAME_phase class) for each phase, containing the default implementation of the new phase, which must be a uvm_component-compatible delegate, and which may be a null implementation. Instantiate a singleton instance of that class for your code to use when a phase handle is required. If your custom phase depends on methods that are not in uvm_component, but are within an extended class, then extend the base YOURPREFIX_NAME_phase class with parameterized component class context as required, to create a specialized functor which calls your extended component class methods. This scheme ensures compile-safety for your extended component classes while providing homogeneous base types for APIs and underlying data structures."}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "A schedule is a coherent group of one or mode phase/state nodes linked together by a graph structure, allowing arbitrary linear/parallel relationships to be specified, and executed by stepping through them in the graph order. Each schedule node points to a phase and holds the execution state of that phase, and has optional links to other nodes for synchronization."}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "The main operations are: construct, add phases, and instantiate hierarchically within another schedule."}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "Structure is a DAG (Directed Acyclic Graph). Each instance is a node connected to others to form the graph. Hierarchy is overlaid with m_parent. Each node in the graph has zero or more successors, and zero or more predecessors. No nodes are completely isolated from others. Exactly one node has zero predecessors. This is the root node. Also the graph is acyclic, meaning for all nodes in the graph, by following the forward arrows you will never end up back where you started but you will eventually reach a node that has no successors."}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "A given phase may appear multiple times in the complete phase graph, due to the multiple independent domain feature, and the ability for different VIP to customize their own phase schedules perhaps reusing existing phases. Each node instance in the graph maintains its own state of execution."}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "Handles of this type uvm_phase are used frequently in the API, both by the user, to access phasing-specific API, and also as a parameter to some APIs. In many cases, the singleton phase handles can be used (eg. uvm_run_phase::get()) in APIs. For those APIs that need to look up that phase in the graph, this is done automatically."}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "This base class defines everything about a phase: behavior, state, and context."}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "class uvm_phase extends uvm_object"}
{"type": "text", "page_from": 137, "page_to": 137, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=137", "section_title": "uvm_phase", "content": "Create a new phase node, with a name and a note of its type name - name of"}
{"type": "text", "page_from": 139, "page_to": 139, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=139", "section_title": "uvm_phase", "content": "Create a new phase node, with a name and a note of its type name - name of this phase type - a value in uvm_phase_type"}
{"type": "text", "page_from": 139, "page_to": 139, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=139", "section_title": "uvm_phase", "content": "function uvm_phase_type get_phase_type()"}
{"type": "text", "page_from": 139, "page_to": 139, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=139", "section_title": "uvm_phase", "content": "Returns the phase type as defined by uvm_phase_type"}
{"type": "text", "page_from": 139, "page_to": 139, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=139", "section_title": "uvm_phase", "content": "function uvm_phase_state get_state()"}
{"type": "text", "page_from": 139, "page_to": 139, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=139", "section_title": "uvm_phase", "content": "Accessor to return current state of this phase"}
{"type": "text", "page_from": 139, "page_to": 139, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=139", "section_title": "uvm_phase", "content": "function int get_run_count()"}
{"type": "text", "page_from": 139, "page_to": 139, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=139", "section_title": "uvm_phase", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 140, "page_to": 140, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=140", "section_title": "uvm_phase", "content": "Accessor to return the integer number of times this phase has executed"}
{"type": "text", "page_from": 140, "page_to": 140, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=140", "section_title": "uvm_phase", "content": "function uvm_phase find_by_name( string name, bit stay_in_scope $= 1$ )"}
{"type": "text", "page_from": 140, "page_to": 140, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=140", "section_title": "uvm_phase", "content": "Locate a phase node with the specified name and return its handle. With stay_in_scope set, searches only within this phase’s schedule or domain."}
{"type": "text", "page_from": 140, "page_to": 140, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=140", "section_title": "uvm_phase", "content": "function uvm_phase find( uvm_phase phase, bit stay_in_scope = 1"}
{"type": "text", "page_from": 140, "page_to": 140, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=140", "section_title": "uvm_phase", "content": "Locate the phase node with the specified phase IMP and return its handle. With stay_in_scope set, searches only within this phase’s schedule or domain."}
{"type": "text", "page_from": 140, "page_to": 140, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=140", "section_title": "uvm_phase", "content": "returns 1 if the containing uvm_phase refers to the same phase as the phase argument, 0 otherwise"}
{"type": "text", "page_from": 140, "page_to": 140, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=140", "section_title": "uvm_phase", "content": "Returns 1 if the containing uvm_phase refers to a phase that is earlier than the phase argument, 0 otherwise"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "virtual function void exec_func( uvm_component comp, uvm_phase phase"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "Implements the functor/delegate functionality for a function phase type comp - the component to execute the functionality upon phase - the phase schedule that originated this phase call"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "virtual task exec_task( uvm_component comp, uvm_phase phase"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "Implements the functor/delegate functionality for a task phase type comp - the component to execute the functionality upon phase - the phase schedule that originated this phase call"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "Build up a schedule structure inserting phase by phase, specifying linkage"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "Phases can be added anywhere, in series or parallel with existing nodes phase handle of singleton derived imp containing actual functor. by default the new phase is appended to the schedule with_phase specify to add the new phase in parallel with this one after_phase specify to add the new phase as successor to this one before_phase specify to add the new phase as predecessor to this one"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "function uvm_phase get_parent()"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "Returns the parent schedule node, if any, for hierarchical graph traversal"}
{"type": "text", "page_from": 141, "page_to": 141, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=141", "section_title": "uvm_phase", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "Returns the full path from the enclosing domain down to this node. The singleton IMP phases have no hierarchy."}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "function uvm_phase get_schedule( bit hier $\\overline { { \\overline { { = } } } } \\overline { { 0 } }$"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "Returns the topmost parent schedule node, if any, for hierarchical graph traversal"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "function string get_schedule_name( bit hier"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "Returns the schedule name associated with this phase node"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "function uvm_domain get_domain()"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "Returns the enclosing domain"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "function uvm_phase get_imp()"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "Returns the phase implementation for this this node. Returns null if this phase type is not a UVM_PHASE_LEAF_NODE."}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "function string get_domain_name()"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "Returns the domain name associated with this phase node"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "get_adjacent_predecessor_nodes"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "function void get_adjacent_predecessor_nodes( ref uvm_phase pred[]"}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "Provides an array of nodes which are predecessors to this phase node. A ‘predecessor node’ is defined as any phase node which lies prior to this node in the phase graph, with no nodes between this node and the predecessor node."}
{"type": "text", "page_from": 142, "page_to": 142, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=142", "section_title": "uvm_phase", "content": "get_adjacent_successor_nodes"}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "function void get_adjacent_successor_nodes( ref uvm_phase succ[]"}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "Provides an array of nodes which are successors to this phase node. A ‘successor’s node’ is defined as any phase node which comes after this node in the phase graph, with no nodes between this node and the successor node."}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "PhAsE DONE OBJEcTION"}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "Task-based phase nodes within the phasing graph provide a uvm_objection based interface for prolonging the execution of the phase. All other phase types do not contain an objection, and will report a fatal error if the user attempts to raise, drop, or get_objection_count."}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "function uvm_objection get_objection()"}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "Return the uvm_objection that gates the termination of the phase."}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "Raise an objection to ending this phase Provides components with greater control over the phase flow for processes which are not implicit objectors to the phase."}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "virtual function void drop_objection ( uvm_object obj, string description = \"\", int count = 1 )"}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "Drop an objection to ending this phase"}
{"type": "text", "page_from": 143, "page_to": 143, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=143", "section_title": "uvm_phase", "content": "The drop is expected to be matched with an earlier raise."}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "Returns the current number of objections to ending this phase raised by the given object."}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "The functions ‘sync’ and ‘unsync’ add soft sync relationships between nodes"}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "Components in different schedule domains can be phased independently or in sync with each other. An API is provided to specify synchronization rules between any two domains. Synchronization can be done at any of three levels:"}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "the domain’s whole phase schedule can be synchronized a phase can be specified, to sync that phase with a matching counterpart or a more detailed arbitrary synchronization between any two phases"}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "Each kind of synchronization causes the same underlying data structures to be managed. Like other APIs, we use the parameter dot-notation to set optional parameters."}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "When a domain is synced with another domain, all of the matching phases in the two domains get a ‘with’ relationship between them. Likewise, if a domain is unsynched, all of the matching phases that have a ‘with’ relationship have the dependency removed. It is possible to sync two domains and then just remove a single phase from the dependency relationship by unsyncing just the one phase."}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "function void sync( uvm_domain target, uvm_phase phase $=$ null, uvm_phase with_phase $=$ null )"}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "Synchronize two domains, fully or partially"}
{"type": "text", "page_from": 144, "page_to": 144, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=144", "section_title": "uvm_phase", "content": "target handle of target domain to synchronize this one to phase optional single phase in this domain to synchronize, otherwise sync all with_phase optional different target-domain phase to synchronize with, otherwise use phase in the target domain function void unsync( uvm_domain target, uvm_phase phase $=$ null, uvm_phase with_phase $=$ null )"}
{"type": "text", "page_from": 145, "page_to": 145, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=145", "section_title": "uvm_phase", "content": "Remove synchronization between two domains, fully or partially"}
{"type": "text", "page_from": 145, "page_to": 145, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=145", "section_title": "uvm_phase", "content": "target handle of target domain to remove synchronization from phase optional single phase in this domain to un-synchronize, otherwise unsync all with_phase optional different target-domain phase to un-synchronize with, otherwise use phase in the target domain"}
{"type": "text", "page_from": 145, "page_to": 145, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=145", "section_title": "uvm_phase", "content": "task wait_for_state( uvm_phase_state state, uvm_wait_op op = UVM_EQ"}
{"type": "text", "page_from": 145, "page_to": 145, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=145", "section_title": "uvm_phase", "content": "Wait until this phase compares with the given state and op operand. For UVM_EQ and UVM_NE operands, several uvm_phase_states can be supplied by ORing their enum constants, in which case the caller will wait until the phase state is any of (UVM_EQ) or none of (UVM_NE) the provided states."}
{"type": "text", "page_from": 145, "page_to": 145, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=145", "section_title": "uvm_phase", "content": "To wait for the phase to be at the started state or after"}
{"type": "text", "page_from": 145, "page_to": 145, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=145", "section_title": "uvm_phase", "content": "To wait for the phase to be either started or executing"}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "Specify a phase to transition to when phase is complete. Note that this function is part of what jump() does; unlike jump() it does not set the flag to terminate the phase prematurely."}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "function void end_prematurely()"}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "Set a flag to cause the phase to end prematurely. Note that this function is part of what jump() does; unlike jump() it does not set a jump_phase to go to after the phase ends."}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "function uvm_phase get_jump_target()"}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "Return handle to the target phase of the current jump, or null if no jump is in progress. Valid for use during the phase_ended() callback"}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "uvm_phase_state_change"}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "Phase state transition descriptor. Used to describe the phase transition that caused a uvm_phase_state_changed() callback to be invoked."}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "uvm_phase_state_change"}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "Phase state transition descriptor."}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "class uvm_phase_state_change extends uvm_object"}
{"type": "text", "page_from": 146, "page_to": 146, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=146", "section_title": "uvm_phase", "content": "get_state() Returns the state the phase just transitioned to. get_prev_state() Returns the state the phase just transitioned from. jump_to() If the current state is UVM_PHASE_ENDED or UVM_PHASE_JUMPING because of a phase jump, returns the phase that is the target of jump."}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "virtual function uvm_phase_state get_state()"}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "Returns the state the phase just transitioned to. Functionally equivalent to uvm_phase::get_state()."}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "virtual function uvm_phase_state get_prev_state()"}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "Returns the state the phase just transitioned from."}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "function uvm_phase jump_to()"}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "If the current state is UVM_PHASE_ENDED or UVM_PHASE_JUMPING because of a phase jump, returns the phase that is the target of jump. Returns null otherwise."}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "This class defines a callback method that is invoked by the phaser during the execution of a specific node in the phase graph or all phase nodes. User-defined callback extensions can be used to integrate data types that are not natively phase-aware with the UVM phasing."}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "This class defines a callback method that is invoked by the phaser during the execution of a specific node in the phase graph or all phase nodes."}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "class uvm_phase_cb extends uvm_callback"}
{"type": "text", "page_from": 147, "page_to": 147, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=147", "section_title": "uvm_phase", "content": "new Constructor phase_state_change Called whenever a phase changes state."}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "function new( string name $=$ \"unnamed-uvm_phase_cb\" )"}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "virtual function void phase_state_change( uvm_phase phase, uvm_phase_state_change change )"}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "Called whenever a phase changes state. The change descriptor describes the transition that was just completed. The callback method is invoked immediately after the phase state has changed, but before the phase implementation is executed."}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "An extension may interact with the phase, such as raising the phase objection to prolong the phase, in a manner that is consistent with the current phase state."}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "By default, the callback method does nothing. Unless otherwise specified, modifying the phase transition descriptor has no effect on the phasing schedule or execution."}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "Convenience type for the uvm_callbacks#(uvm_phase, uvm_phase_cb) class."}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "Convenience type for the uvm_callbacks#(uvm_phase, uvm_phase_cb) class."}
{"type": "text", "page_from": 148, "page_to": 148, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=148", "section_title": "uvm_phase", "content": "typedef uvm_callbacks#( uvm_phase, uvm_phase_cb ) uvm_phase_cb_pool"}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "Phasing schedule node representing an independent branch of the schedule. Handle used to assign domains to components or hierarchies in the testbench"}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "Phasing schedule node representing an independent branch of the schedule."}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "class uvm_domain extends uvm_phase"}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "static function void get_domains( output uvm_domain domains[string]"}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "Provides a list of all domains in the provided domains argument."}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "static function uvm_phase get_uvm_schedule()"}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "Get the $\\ \" \\mathrm { U V } \\ / \\mathsf { M } ^ { \\prime \\prime }$ schedule, which consists of the run-time phases that all components"}
{"type": "text", "page_from": 149, "page_to": 149, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=149", "section_title": "uvm_domain", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "execute when participating in the “UVM” domain."}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "static function uvm_domain get_common_domain()"}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "Get the “common” domain, which consists of the common phases that all components execute in sync with each other. Phases in the “common” domain are build, connect, end_of_elaboration, start_of_simulation, run, extract, check, report, and final."}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "static function void add_uvm_phases( uvm_phase schedule"}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "Appends to the given schedule the built-in UVM phases."}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "static function uvm_domain get_uvm_domain()"}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "Get a handle to the singleton uvm domain"}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "Create a new instance of a phase domain."}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "function void jump( uvm_phase phase"}
{"type": "text", "page_from": 150, "page_to": 150, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=150", "section_title": "uvm_domain", "content": "jumps all active phases of this domain to to-phase if there is a path between activephase and to-phase"}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "header_path": ["9", "3"], "chapter": "9", "section": "9.3", "content": "9.3 uvm_bottomup_phase"}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "Virtual base class for function phases that operate bottom-up. The pure virtual function execute() is called for each component. This is the default traversal so is included only for naming."}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "A bottom-up function phase completes when the execute() method has been called and returned on all applicable components in the hierarchy."}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "Virtual base class for function phases that operate bottom-up."}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "virtual class uvm_bottomup_phase extends uvm_phase"}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "new Create a new instance of a bottom-up phase. traverse Traverses the component tree in bottom-up order, calling execute for each component. execute Executes the bottom-up phase phase for the component comp."}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "Create a new instance of a bottom-up phase."}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "virtual function void traverse( uvm_component comp, uvm_phase phase, uvm_phase_state state"}
{"type": "text", "page_from": 151, "page_to": 151, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=151", "section_title": "uvm_bottomup_phase", "content": "Traverses the component tree in bottom-up order, calling execute for each component."}
{"type": "text", "page_from": 152, "page_to": 152, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=152", "section_title": "uvm_bottomup_phase", "content": "virtual function void execute( uvm_component comp, uvm_phase phase"}
{"type": "text", "page_from": 152, "page_to": 152, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=152", "section_title": "uvm_bottomup_phase", "content": "Executes the bottom-up phase phase for the component comp."}
{"type": "text", "page_from": 153, "page_to": 153, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=153", "section_title": "uvm_task_phase", "content": "Base class for all task phases. It forks a call to uvm_phase::exec_task() for each component in the hierarchy."}
{"type": "text", "page_from": 153, "page_to": 153, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=153", "section_title": "uvm_task_phase", "content": "The completion of the task does not imply, nor is it required for, the end of phase. Once the phase completes, any remaining forked uvm_phase::exec_task() threads are forcibly and immediately killed."}
{"type": "text", "page_from": 153, "page_to": 153, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=153", "section_title": "uvm_task_phase", "content": "By default, the way for a task phase to extend over time is if there is at least one component that raises an objection."}
{"type": "text", "page_from": 153, "page_to": 153, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=153", "section_title": "uvm_task_phase", "content": "There is however one scenario wherein time advances within a task-based phase without any objections to the phase being raised. If two (or more) phases share a common successor, such as the uvm_run_phase and the uvm_post_shutdown_phase sharing the uvm_extract_phase as a successor, then phase advancement is delayed until all predecessors of the common successor are ready to proceed. Because of this, it is possible for time to advance between uvm_component::phase_started and uvm_component::phase_ended of a task phase without any participants in the phase raising an objection."}
{"type": "text", "page_from": 153, "page_to": 153, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=153", "section_title": "uvm_task_phase", "content": "Base class for all task phases."}
{"type": "text", "page_from": 153, "page_to": 153, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=153", "section_title": "uvm_task_phase", "content": "virtual class uvm_task_phase extends uvm_phase"}
{"type": "text", "page_from": 153, "page_to": 153, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=153", "section_title": "uvm_task_phase", "content": "new Create a new instance of a task-based phase traverse Traverses the component tree in bottom-up order, calling execute for each component. execute Fork the task-based phase phase for the component comp."}
{"type": "text", "page_from": 154, "page_to": 154, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=154", "section_title": "uvm_task_phase", "content": "Create a new instance of a task-based phase"}
{"type": "text", "page_from": 154, "page_to": 154, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=154", "section_title": "uvm_task_phase", "content": "virtual function void traverse( uvm_component comp, uvm_phase phase, uvm_phase_state state"}
{"type": "text", "page_from": 154, "page_to": 154, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=154", "section_title": "uvm_task_phase", "content": "Traverses the component tree in bottom-up order, calling execute for each component. The actual order for task-based phases doesn’t really matter, as each component task is executed in a separate process whose starting order is not deterministic."}
{"type": "text", "page_from": 154, "page_to": 154, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=154", "section_title": "uvm_task_phase", "content": "virtual function void execute( uvm_component comp, uvm_phase phase"}
{"type": "text", "page_from": 154, "page_to": 154, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=154", "section_title": "uvm_task_phase", "content": "Fork the task-based phase phase for the component comp."}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "header_path": ["9", "5"], "chapter": "9", "section": "9.5", "content": "9.5 uvm_topdown_phase"}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "Virtual base class for function phases that operate top-down. The pure virtual function execute() is called for each component."}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "A top-down function phase completes when the execute() method has been called and returned on all applicable components in the hierarchy."}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "Virtual base class for function phases that operate top-down."}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "virtual class uvm_topdown_phase extends uvm_phase"}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "new Create a new instance of a top-down phase traverse Traverses the component tree in top-down order, calling execute for each component. execute Executes the top-down phase phase for the component comp."}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "Create a new instance of a top-down phase"}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "virtual function void traverse( uvm_component comp, uvm_phase phase, uvm_phase_state state"}
{"type": "text", "page_from": 155, "page_to": 155, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=155", "section_title": "uvm_topdown_phase", "content": "Traverses the component tree in top-down order, calling execute for each component."}
{"type": "text", "page_from": 156, "page_to": 156, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=156", "section_title": "uvm_topdown_phase", "content": "virtual function void execute( uvm_component comp, uvm_phase phase"}
{"type": "text", "page_from": 156, "page_to": 156, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=156", "section_title": "uvm_topdown_phase", "content": "Executes the top-down phase phase for the component comp."}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "header_path": ["9", "6"], "chapter": "9", "section": "9.6", "content": "9.6 UVM Common Phases"}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "The common phases are the set of function and task phases that all uvm_components execute together. All uvm_components are always synchronized with respect to the common phases."}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "The names of the UVM phases (which will be returned by get_name() for a phase instance) match the class names specified below with the “uvm_” and “_phase” removed. For example, the build phase corresponds to the uvm_build_phase class below and has the name “build”, which means that the following can be used to call foo() at the end of the build phase (after all lower levels have finished build):"}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "The common phases are executed in the sequence they are specified below."}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "The common phases are the set of function and task phases that all uvm_components execute together."}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "Create and configure of testbench structure"}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "uvm_topdown_phase that calls the uvm_component::build_phase method."}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "The top-level components have been instantiated under uvm_root. Current simulation time is still equal to 0 but some “delta cycles” may have occurred"}
{"type": "text", "page_from": 157, "page_to": 157, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=157", "section_title": "UVM Common Phases", "content": "Instantiate sub-components. Instantiate register model. Get configuration values for the component being built."}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "Set configuration values for sub-components."}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "All uvm_components have been instantiated."}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "Create and configure of testbench structure"}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "class uvm_build_phase extends uvm_topdown_phase"}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "static function uvm_build_phase get()"}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "Establish cross-component connections."}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "uvm_bottomup_phase that calls the uvm_component::connect_phase method."}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "All components have been instantiated. Current simulation time is still equal to 0 but some “delta cycles” may have occurred."}
{"type": "text", "page_from": 158, "page_to": 158, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=158", "section_title": "UVM Common Phases", "content": "Connect TLM ports and exports."}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "Connect TLM initiator sockets and target sockets."}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "Connect register model to adapter components. Setup explicit phase domains."}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "All cross-component connections have been established. All independent phase domains are set."}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "Establish cross-component connections."}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "class uvm_connect_phase extends uvm_bottomup_phase"}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "static function uvm_connect_phase get()"}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "uvm_end_of_elaboration_phase"}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "Fine-tune the testbench."}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "uvm_bottomup_phase that calls the uvm_component::end_of_elaboration_phase method."}
{"type": "text", "page_from": 159, "page_to": 159, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=159", "section_title": "UVM Common Phases", "content": "The verification environment has been completely assembled. Current simulation time is still equal to 0 but some “delta cycles” may have occurred."}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "Display environment topology. Open files. Define additional configuration settings for components."}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "uvm_end_of_elaboration_phase"}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "Fine-tune the testbench."}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "class uvm_end_of_elaboration_phase extends uvm_bottomup_phase"}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "static function uvm_end_of_elaboration_phase get()"}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "uvm_start_of_simulation_phase"}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "Get ready for DUT to be simulated."}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "uvm_bottomup_phase that calls the uvm_component::start_of_simulation_phase method."}
{"type": "text", "page_from": 160, "page_to": 160, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=160", "section_title": "UVM Common Phases", "content": "Other simulation engines, debuggers, hardware assisted platforms and all other run-time tools have been started and synchronized."}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "The verification environment has been completely configured and is ready to start. Current simulation time is still equal to 0 but some “delta cycles” may have occurred."}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "Display environment topology Set debugger breakpoint Set initial run-time configuration values."}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "uvm_start_of_simulation_phase"}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "Get ready for DUT to be simulated."}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "class uvm_start_of_simulation_phase extends uvm_bottomup_phase"}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "static function uvm_start_of_simulation_phase get()"}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "This uvm_task_phase calls the uvm_component::run_phase virtual method. This phase runs in parallel to the runtime phases, uvm_pre_reset_phase through"}
{"type": "text", "page_from": 161, "page_to": 161, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=161", "section_title": "UVM Common Phases", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "uvm_post_shutdown_phase. All components in the testbench are synchronized with respect to the run phase regardless of the phase domain they belong to."}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "Indicates that power has been applied. There should not have been any active clock edges before entry into this phase (e.g. $\\times \\mathord { \\mathrm { - } } \\mathrm { > } 1$ transitions via initial blocks). Current simulation time is still equal to 0 but some “delta cycles” may have occurred."}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "Components implement behavior that is exhibited for the entire run-time, across the various run-time phases. Backward compatibility with OVM."}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "The DUT no longer needs to be simulated, and The uvm_post_shutdown_phase is ready to end"}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "The run phase terminates in one of two ways."}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "1. All run_phase objections are dropped"}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "When all objections on the run_phase objection have been dropped, the phase ends and all of its threads are killed. If no component raises a run_phase objection immediately upon entering the phase, the phase ends immediately."}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "The phase ends if the timeout expires before all objections are dropped. By default, the timeout is set to 9200 seconds. You may override this via uvm_root::set_timeout."}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "If a timeout occurs in your simulation, or if simulation never ends despite completion of your test stimulus, then it usually indicates that a component continues to object to the end of a phase."}
{"type": "text", "page_from": 162, "page_to": 162, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=162", "section_title": "UVM Common Phases", "content": "class uvm_run_phase extends uvm_task_phase"}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "static function uvm_run_phase get()"}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "Extract data from different points of the verification environment."}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "uvm_bottomup_phase that calls the uvm_component::extract_phase method."}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "The DUT no longer needs to be simulated. Simulation time will no longer advance."}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "Extract any remaining data and final state information from scoreboard and testbench components Probe the DUT (via zero-time hierarchical references and/or backdoor accesses) for final state information. Compute statistics and summaries. Display final state information Close files."}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "All data has been collected and summarized."}
{"type": "text", "page_from": 163, "page_to": 163, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=163", "section_title": "UVM Common Phases", "content": "Extract data from different points of the verification environment."}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "class uvm_extract_phase extends uvm_bottomup_phase"}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "static function uvm_extract_phase get()"}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "Check for any unexpected conditions in the verification environment."}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "uvm_bottomup_phase that calls the uvm_component::check_phase method."}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "All data has been collected."}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "Check that no unaccounted-for data remain."}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "Test is known to have passed or failed."}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "Check for any unexpected conditions in the verification environment."}
{"type": "text", "page_from": 164, "page_to": 164, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=164", "section_title": "UVM Common Phases", "content": "class uvm_check_phase extends uvm_bottomup_phase"}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "static function uvm_check_phase get()"}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "Report results of the test."}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "uvm_bottomup_phase that calls the uvm_component::report_phase method."}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "Test is known to have passed or failed."}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "Report test results. Write results to file."}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "Report results of the test."}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "class uvm_report_phase extends uvm_bottomup_phase"}
{"type": "text", "page_from": 165, "page_to": 165, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=165", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "static function uvm_report_phase get()"}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "uvm_topdown_phase that calls the uvm_component::final_phase method."}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "All test-related activity has completed."}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "Close files. Terminate co-simulation engines."}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "Ready to exit simulator."}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "class uvm_final_phase extends uvm_topdown_phase"}
{"type": "text", "page_from": 166, "page_to": 166, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=166", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 167, "page_to": 167, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=167", "section_title": "UVM Common Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 168, "page_to": 168, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=168", "section_title": "UVM Run-Time Phases", "header_path": ["9", "7"], "chapter": "9", "section": "9.7", "content": "9.7 UVM Run-Time Phases"}
{"type": "text", "page_from": 168, "page_to": 168, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=168", "section_title": "UVM Run-Time Phases", "content": "The run-time schedule is the pre-defined phase schedule which runs concurrently to the uvm_run_phase global run phase. By default, all uvm_components using the run-time schedule are synchronized with respect to the pre-defined phases in the schedule. It is possible for components to belong to different domains in which case their schedules can be unsynchronized."}
{"type": "text", "page_from": 168, "page_to": 168, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=168", "section_title": "UVM Run-Time Phases", "content": "The names of the UVM phases (which will be returned by get_name() for a phase instance) match the class names specified below with the “uvm_” and “_phase” removed. For example, the main phase corresponds to the uvm_main_phase class below and has the name “main”, which means that the following can be used to call foo() at the start of main phase:"}
{"type": "text", "page_from": 168, "page_to": 168, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=168", "section_title": "UVM Run-Time Phases", "content": "The run-time phases are executed in the sequence they are specified below."}
{"type": "text", "page_from": 168, "page_to": 168, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=168", "section_title": "UVM Run-Time Phases", "content": "The run-time schedule is the pre-defined phase schedule which runs concurrently to the uvm_run_phase global run phase."}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "Wait for power good. Components connected to virtual interfaces should initialize their output to X’s or Z’s. Initialize the clock signals to a valid value Assign reset signals to X (power-on reset). Wait for reset signal to be asserted if not driven by the verification environment."}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "Reset signal, if driven by the verification environment, is ready to be asserted. Reset signal, if not driven by the verification environment, is asserted."}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "Before reset is asserted."}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "class uvm_pre_reset_phase extends uvm_task_phase"}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "static function uvm_pre_reset_phase get()"}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 169, "page_to": 169, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=169", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::reset_phase method."}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "Indicates that the hardware reset signal is ready to be asserted."}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "Assert reset signals. Components connected to virtual interfaces should drive their output to their specified reset or idle value. Components and environments should initialize their state variables. Clock generators start generating active edges. De-assert the reset signal(s) just before exit. Wait for the reset signal(s) to be de-asserted."}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "Reset signal has just been de-asserted. Main or base clock is working and stable. At least one active clock edge has occurred. Output signals and state variables have been initialized."}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "class uvm_reset_phase extends uvm_task_phase"}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "static function uvm_reset_phase get()"}
{"type": "text", "page_from": 170, "page_to": 170, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=170", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "After reset is de-asserted."}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::post_reset_phase method."}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "Indicates that the DUT reset signal has been de-asserted."}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "Components should start behavior appropriate for reset being inactive. For example, components may start to transmit idle transactions or interface training and rate negotiation. This behavior typically continues beyond the end of this phase."}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "The testbench and the DUT are in a known, active state."}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "uvm_post_reset_phase"}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "After reset is de-asserted."}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "class uvm_post_reset_phase extends uvm_task_phase"}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "static function uvm_post_reset_phase get()"}
{"type": "text", "page_from": 171, "page_to": 171, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=171", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "Before the DUT is configured by the SW."}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::pre_configure_phase method."}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "Indicates that the DUT has been completed reset and is ready to be configured."}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "Procedurally modify the DUT configuration information as described in the environment (and that will be eventually uploaded into the DUT). Wait for components required for DUT configuration to complete training and rate negotiation."}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "DUT configuration information is defined."}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "uvm_pre_configure_phase"}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "Before the DUT is configured by the SW."}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "class uvm_pre_configure_phase extends uvm_task_phase"}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "static function uvm_pre_configure_phase get()"}
{"type": "text", "page_from": 172, "page_to": 172, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=172", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "The SW configures the DUT."}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::configure_phase method."}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "Indicates that the DUT is ready to be configured."}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "Components required for DUT configuration execute transactions normally. Set signals and program the DUT and memories (e.g. read/write operations and sequences) to match the desired configuration for the test and environment."}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "The DUT has been configured and is ready to operate normally."}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "The SW configures the DUT."}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "class uvm_configure_phase extends uvm_task_phase"}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "static function uvm_configure_phase get()"}
{"type": "text", "page_from": 173, "page_to": 173, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=173", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::post_configure_phase method."}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "Indicates that the configuration information has been fully uploaded."}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "Wait for configuration information to fully propagate and take effect. Wait for components to complete training and rate negotiation. Enable the DUT. Sample DUT configuration coverage."}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "The DUT has been fully configured and enabled and is ready to start operating normally."}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "uvm_post_configure_phase"}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "After the SW has configured the DUT."}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "class uvm_post_configure_phase extends uvm_task_phase"}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "static function uvm_post_configure_phase get()"}
{"type": "text", "page_from": 174, "page_to": 174, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=174", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::pre_main_phase method."}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "Indicates that the DUT has been fully configured."}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "Wait for components to complete training and rate negotiation."}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "All components have completed training and rate negotiation. All components are ready to generate and/or observe normal stimulus."}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "Before the primary test stimulus starts."}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "class uvm_pre_main_phase extends uvm_task_phase"}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "static function uvm_pre_main_phase get()"}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "Primary test stimulus."}
{"type": "text", "page_from": 175, "page_to": 175, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=175", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::main_phase method."}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "The stimulus associated with the test objectives is ready to be applied."}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "Components execute transactions normally. Data stimulus sequences are started. Wait for a time-out or certain amount of time, or completion of stimulus sequences."}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "Enough stimulus has been applied to meet the primary stimulus objective of the test."}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "Primary test stimulus."}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "class uvm_main_phase extends uvm_task_phase"}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "static function uvm_main_phase get()"}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "After enough of the primary test stimulus."}
{"type": "text", "page_from": 176, "page_to": 176, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=176", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::post_main_phase method."}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "The primary stimulus objective of the test has been met."}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "Included for symmetry."}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "After enough of the primary test stimulus."}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "class uvm_post_main_phase extends uvm_task_phase"}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "static function uvm_post_main_phase get()"}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "uvm_pre_shutdown_phase"}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "Before things settle down."}
{"type": "text", "page_from": 177, "page_to": 177, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=177", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::pre_shutdown_phase method."}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "Included for symmetry."}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "uvm_pre_shutdown_phase"}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "Before things settle down."}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "class uvm_pre_shutdown_phase extends uvm_task_phase"}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "static function uvm_pre_shutdown_phase get()"}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "Letting things settle down."}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::shutdown_phase method."}
{"type": "text", "page_from": 178, "page_to": 178, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=178", "section_title": "UVM Run-Time Phases", "content": "Wait for all data to be drained out of the DUT. Extract data still buffered in the DUT, usually through read/write operations or"}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "All data has been drained or extracted from the DUT. All interfaces are idle."}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "Letting things settle down."}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "class uvm_shutdown_phase extends uvm_task_phase"}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "static function uvm_shutdown_phase get()"}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "uvm_post_shutdown_phase"}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "After things have settled down."}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "uvm_task_phase that calls the uvm_component::post_shutdown_phase method. The end of this phase is synchronized to the end of the uvm_run_phase phase unless a user defined phase is added after this phase."}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "No more “data” stimulus is applied to the DUT."}
{"type": "text", "page_from": 179, "page_to": 179, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=179", "section_title": "UVM Run-Time Phases", "content": "Perform final checks that require run-time access to the DUT (e.g. read accounting"}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "registers or dump the content of memories)."}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "All run-time checks have been satisfied. The uvm_run_phase phase is ready to end."}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "uvm_post_shutdown_phase"}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "After things have settled down."}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "CLAss Dec LAr At ION"}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "class uvm_post_shutdown_phase extends uvm_task_phase"}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "static function uvm_post_shutdown_phase get()"}
{"type": "text", "page_from": 180, "page_to": 180, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=180", "section_title": "UVM Run-Time Phases", "content": "Returns the singleton phase handle"}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "header_path": ["9", "8"], "chapter": "9", "section": "9.8", "content": "9.8 User-Defined Phases"}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "To define your own custom phase, use the following pattern."}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "1. Extend the appropriate base class for your phase type."}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "2. Optionally, implement your exec_task or exec_func method."}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "If implemented, these methods usually call the related method on the component"}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "3. Since the phase class is a singleton, providing an accessor method allows for easy global use, and protecting the constructor prevents misuse."}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "class my_PHASE_phase extends uvm_topdown_phase; or uvm_task_phase/uvm_bottomum_phase static local my_PHASE_phase m_inst; Local reference to global IMP protected function new(string name $=$ \"PHASE\"); Protected constructor for singleton super.new(name); endfunction : new static function my_PHASE_phase get(); Static method for accessing singleton if (m_imp $= =$ null) m_imp $=$ new(); return m_imp; endfunction : get Optionally implement exec_func/exec_task endclass : my_PHASE_phase"}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "4. Insert the phase in a phase schedule or domain using the uvm_phase::add method:"}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "my_schedule.add(my_PHASE_class::get());"}
{"type": "text", "page_from": 181, "page_to": 181, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=181", "section_title": "User-Defined Phases", "content": "To define your own custom phase, use the following pattern."}
{"type": "text", "page_from": 182, "page_to": 182, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=182", "section_title": "Configuration and Resource Classes", "content": "10. Configuration and Resource Classes"}
{"type": "text", "page_from": 182, "page_to": 182, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=182", "section_title": "Configuration and Resource Classes", "content": "The configuration and resources classes provide access to a centralized database where type specific information can be stored and received. The uvm_resource_db is the low level resource database which users can write to or read from. The uvm_config_db is layered on top of the resoure database and provides a typed interface for configuration setting that is consistent with the uvm_component::Configuration Interface."}
{"type": "text", "page_from": 182, "page_to": 182, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=182", "section_title": "Configuration and Resource Classes", "content": "Information can be read from or written to the database at any time during simulation. A resource may be associated with a specific hierarchical scope of a uvm_component or it may be visible to all components regardless of their hierarchical position."}
{"type": "text", "page_from": 182, "page_to": 182, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=182", "section_title": "Configuration and Resource Classes", "content": "Configuration and Resource Classes"}
{"type": "text", "page_from": 182, "page_to": 182, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=182", "section_title": "Configuration and Resource Classes", "content": "The configuration and resources classes provide access to a centralized database where type specific information can be stored and received."}
{"type": "text", "page_from": 183, "page_to": 183, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=183", "section_title": "uvm_resource", "content": "A resource is a parameterized container that holds arbitrary data. Resources can be used to configure components, supply data to sequences, or enable sharing of information across disparate parts of a testbench. They are stored using scoping information so their visibility can be constrained to certain parts of the testbench. Resource containers can hold any type of data, constrained only by the data types available in SystemVerilog. Resources can contain scalar objects, class handles, queues, lists, or even virtual interfaces."}
{"type": "text", "page_from": 183, "page_to": 183, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=183", "section_title": "uvm_resource", "content": "Resources are stored in a resource database so that each resource can be retrieved by name or by type. The database has both a name table and a type table and each resource is entered into both. The database is globally accessible."}
{"type": "text", "page_from": 183, "page_to": 183, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=183", "section_title": "uvm_resource", "content": "Each resource has a set of scopes over which it is visible. The set of scopes is represented as a regular expression. When a resource is looked up the scope of the entity doing the looking up is supplied to the lookup function. This is called the current scope. If the current scope is in the set of scopes over which a resource is visible then the resource can be retuned in the lookup."}
{"type": "text", "page_from": 183, "page_to": 183, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=183", "section_title": "uvm_resource", "content": "Resources can be looked up by name or by type. To support type lookup each resource has a static type handle that uniquely identifies the type of each specialized resource container."}
{"type": "text", "page_from": 183, "page_to": 183, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=183", "section_title": "uvm_resource", "content": "Multiple resources that have the same name are stored in a queue. Each resource is pushed into a queue with the first one at the front of the queue and each subsequent one behind it. The same happens for multiple resources that have the same type. The resource queues are searched front to back, so those placed earlier in the queue have precedence over those placed later."}
{"type": "text", "page_from": 183, "page_to": 183, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=183", "section_title": "uvm_resource", "content": "The precedence of resources with the same name or same type can be altered. One way is to set the precedence member of the resource container to any arbitrary value. The search algorithm will return the resource with the highest precedence. In the case where there are multiple resources that match the search criteria and have the same (highest) precedence, the earliest one located in the queue will be one returned. Another way to change the precedence is to use the set_priority function to move a resource to either the front or back of the queue."}
{"type": "text", "page_from": 183, "page_to": 183, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=183", "section_title": "uvm_resource", "content": "The classes defined here form the low level layer of the resource database. The classes include the resource container and the database that holds the containers. The following set of classes are defined here:"}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "uvm_resource_types: A class without methods or members, only typedefs and enums. These types and enums are used throughout the resources facility. Putting the types in a class keeps them confined to a specific name space."}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "uvm_resource_options: policy class for setting options, such as auditing, which effect resources."}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "uvm_resource_base: the base (untyped) resource class living in the resource database. This class includes the interface for setting a resource as read-only, notification, scope management, altering search priority, and managing auditing."}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "uvm_resource#(T): parameterized resource container. This class includes the interfaces for reading and writing each resource. Because the class is parameterized, all the access functions are type safe."}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "uvm_resource_pool: the resource database. This is a singleton class object."}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "Provides typedefs and enums used throughout the resources facility. This class has no members or methods, only typedefs. It’s used in lieu of package-scope types. When needed, other classes can use these types by prefixing their usage with uvm_resource_types::. E.g."}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "Provides typedefs and enums used throughout the resources facility."}
{"type": "text", "page_from": 184, "page_to": 184, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=184", "section_title": "uvm_resource", "content": "class uvm_resource_types"}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "turn_on_auditing turn_off_auditing is_auditing"}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "Turn auditing on for the resource database. Turn auditing off for the resource database. Returns 1 if the auditing facility is on and 0 if it is off."}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "static function void turn_on_auditing()"}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "Turn auditing on for the resource database. This causes all reads and writes to the database to store information about the accesses. Auditing is turned on by default."}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "static function void turn_off_auditing()"}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "Turn auditing off for the resource database. If auditing is turned off, it is not possible to get extra information about resource database accesses."}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "static function bit is_auditing()"}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "Returns 1 if the auditing facility is on and 0 if it is off."}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "Non-parameterized base class for resources. Supports interfaces for scope matching, and virtual functions for printing the resource and for printing the accessor list"}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "Non-parameterized base class for resources."}
{"type": "text", "page_from": 185, "page_to": 185, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=185", "section_title": "uvm_resource", "content": "virtual class uvm_resource_base extends uvm_object"}
{"type": "text", "page_from": 186, "page_to": 186, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=186", "section_title": "uvm_resource", "content": "int unsigned precedence"}
{"type": "text", "page_from": 186, "page_to": 186, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=186", "section_title": "uvm_resource", "content": "This variable is used to associate a precedence that a resource has with respect to other resources which match the same scope and name. Resources are set to the default_precedence initially, and may be set to a higher or lower precedence as desired."}
{"type": "text", "page_from": 186, "page_to": 186, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=186", "section_title": "uvm_resource", "content": "static int unsigned default_precedence $=$ 1000"}
{"type": "text", "page_from": 186, "page_to": 186, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=186", "section_title": "uvm_resource", "content": "The default precedence for an resource that has been created. When two resources have the same precedence, the first resource found has precedence."}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "string name \"\", string s )"}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "constructor for uvm_resource_base. The constructor takes two arguments, the name of the resource and a regular expression which represents the set of scopes over which this resource is visible."}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "pure virtual function uvm_resource_base get_type_handle()"}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "Pure virtual function that returns the type handle of the resource container."}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "function void set_read_only()"}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "Establishes this resource as a read-only resource. An attempt to call uvm_resource#(T)::write on the resource will cause an error."}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "function bit is_read_only()"}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "Returns one if this resource has been set to read-only, zero otherwise"}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "task wait_modified()"}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "This task blocks until the resource has been modified -- that is, a uvm_resource#(T)::write operation has been performed. When a uvm_resource#(T)::write is performed the modified bit is set which releases the block. Wait_modified() then clears the modified bit so it can be called repeatedly."}
{"type": "text", "page_from": 187, "page_to": 187, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=187", "section_title": "uvm_resource", "content": "Each resource has a name, a value and a set of scopes over which it is visible. A scope is a hierarchical entity or a context. A scope name is a multi-element string that identifies a scope. Each element refers to a scope context and the elements are separated by dots (.)."}
{"type": "text", "page_from": 188, "page_to": 188, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=188", "section_title": "uvm_resource", "content": "Consider the example above of a scope name. It consists of four elements: “top”, “env”, “agent”, and “monitor”. The elements are strung together with a dot separating each element. top.env.agent is the parent of top.env.agent.monitor, top.env is the parent of top.env.agent, and so on. A set of scopes can be represented by a set of scope name strings. A very straightforward way to represent a set of strings is to use regular expressions. A regular expression is a special string that contains placeholders which can be substituted in various ways to generate or recognize a particular set of strings. Here are a few simple examples:"}
{"type": "text", "page_from": 188, "page_to": 188, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=188", "section_title": "uvm_resource", "content": "u4, or u5, and any of their subscopes."}
{"type": "text", "page_from": 188, "page_to": 188, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=188", "section_title": "uvm_resource", "content": "The examples above use POSIX regular expression notation. This is a very general and expressive notation. It is not always the case that so much expressiveness is required. Sometimes an expression syntax that is easy to read and easy to write is useful, even if the syntax is not as expressive as the full power of POSIX regular expressions. A popular substitute for regular expressions is globs. A glob is a simplified regular expression. It only has three metacharacters -- $^ * , + ,$ and ?. Character ranges are not allowed and dots are not a metacharacter in globs as they are in regular expressions. The following table shows glob metacharacters."}
{"type": "text", "page_from": 188, "page_to": 188, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=188", "section_title": "uvm_resource", "content": "Of the examples above, the first three can easily be translated into globs. The last one cannot. It relies on notation that is not available in glob syntax."}
{"type": "text", "page_from": 188, "page_to": 188, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=188", "section_title": "uvm_resource", "content": "The resource facility supports both regular expression and glob syntax. Regular expressions are identified as such when they surrounded by $\\setminus / ^ { \\prime }$ characters. For example, $\\sim \\lceil \\sim t o p \\rceil . ^ { \\ast } /$ is interpreted as the regular expression $\\sim t o p | . { ^ \\ast } ,$ where the surrounding $\\setminus / ^ { \\prime }$ characters have been removed. All other expressions are treated as glob expressions. They are converted from glob notation to regular expression notation internally. Regular expression compilation and matching as well as glob-to-regular expression conversion are handled by two DPI functions:"}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "uvm_re_match both compiles and matches the regular expression. All of the matching is done using regular expressions, so globs are converted to regular expressions and then processed."}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "function void set_scope( string s"}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "Set the value of the regular expression that identifies the set of scopes over which this resource is visible. If the supplied argument is a glob it will be converted to a regular expression before it is stored."}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "function string get_scope()"}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "Retrieve the regular expression string that identifies the set of scopes over which this resource is visible."}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "function bit match_scope( string s"}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "Using the regular expression facility, determine if this resource is visible in a scope. Return one if it is, zero otherwise."}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "Functions for manipulating the search priority of resources. The function definitions here are pure virtual and are implemented in derived classes. The definitions serve as a priority management interface."}
{"type": "text", "page_from": 189, "page_to": 189, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=189", "section_title": "uvm_resource", "content": "Change the search priority of the resource based on the value of the priority enum argument."}
{"type": "text", "page_from": 190, "page_to": 190, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=190", "section_title": "uvm_resource", "content": "Implementation of do_print which is called by print()."}
{"type": "text", "page_from": 190, "page_to": 190, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=190", "section_title": "uvm_resource", "content": "To find out what is happening as the simulation proceeds, an audit trail of each read and write is kept. The uvm_resource#(T)::read and uvm_resource#(T)::write methods each take an accessor argument. This is a handle to the object that performed that resource access."}
{"type": "text", "page_from": 190, "page_to": 190, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=190", "section_title": "uvm_resource", "content": "The accessor can by anything as long as it is derived from uvm_object. The accessor object can be a component or a sequence or whatever object from which a read or write was invoked. Typically the this handle is used as the accessor. For example:"}
{"type": "text", "page_from": 190, "page_to": 190, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=190", "section_title": "uvm_resource", "content": "The accessor’s get_full_name() is stored as part of the audit trail. This way you can find out what object performed each resource access. Each audit record also includes the time of the access (simulation time) and the particular operation performed (read or write)."}
{"type": "text", "page_from": 190, "page_to": 190, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=190", "section_title": "uvm_resource", "content": "Auditing is controlled through the uvm_resource_options class."}
{"type": "text", "page_from": 190, "page_to": 190, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=190", "section_title": "uvm_resource", "content": "function void record_read_access( uvm_object accessor $=$ nu"}
{"type": "text", "page_from": 191, "page_to": 191, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=191", "section_title": "uvm_resource", "content": "Initialize a new access record"}
{"type": "text", "page_from": 191, "page_to": 191, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=191", "section_title": "uvm_resource", "content": "The global (singleton) resource database."}
{"type": "text", "page_from": 191, "page_to": 191, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=191", "section_title": "uvm_resource", "content": "Each resource is stored both by primary name and by type handle. The resource pool contains two associative arrays, one with name as the key and one with the type handle as the key. Each associative array contains a queue of resources. Each resource has a regular expression that represents the set of scopes over which it is visible."}
{"type": "text", "page_from": 191, "page_to": 191, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=191", "section_title": "uvm_resource", "content": "The above diagrams illustrates how a resource whose name is A and type is $\\top$ is stored in the pool. The pool contains an entry in the type map for type T and an entry in the name map for name A. The queues in each of the arrays each contain an entry for the resource A whose type is T. The name map can contain in its queue other resources whose name is A which may or may not have the same type as our resource A. Similarly, the type map can contain in its queue other resources whose type is T and whose name may or may not be A."}
{"type": "text", "page_from": 191, "page_to": 191, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=191", "section_title": "uvm_resource", "content": "Resources are added to the pool by calling set; they are retrieved from the pool by calling get_by_name or get_by_type. When an object creates a new resource and calls set the resource is made available to be retrieved by other objects outside of itself; an object gets a resource when it wants to access a resource not currently available in its scope."}
{"type": "text", "page_from": 191, "page_to": 191, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=191", "section_title": "uvm_resource", "content": "The scope is stored in the resource itself (not in the pool) so whether you get by name or by type the resource’s visibility is the same."}
{"type": "text", "page_from": 191, "page_to": 191, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=191", "section_title": "uvm_resource", "content": "As an auditing capability, the pool contains a history of gets. A record of each get, whether by get_by_type or get_by_name, is stored in the audit record. Both successful and failed gets are recorded. At the end of simulation, or any time for that matter, you can dump the history list. This will tell which resources were successfully located and which were not. You can use this information to determine if there is some error in name, type, or scope that has caused a resource to not be located or to be incorrectly located (i.e. the wrong resource is located)."}
{"type": "text", "page_from": 192, "page_to": 192, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=192", "section_title": "uvm_resource", "content": "The global (singleton) resource database."}
{"type": "text", "page_from": 193, "page_to": 193, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=193", "section_title": "uvm_resource", "content": "Returns the singleton handle to the resource pool function bit spell_check( string s"}
{"type": "text", "page_from": 193, "page_to": 193, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=193", "section_title": "uvm_resource", "content": "Invokes the spell checker for a string s. The universe of correctly spelled strings -- i.e. the dictionary -- is the name map. function void set ( uvm_resource_base rsrc, uvm_resource_types::override_t override = 0 )"}
{"type": "text", "page_from": 193, "page_to": 193, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=193", "section_title": "uvm_resource", "content": "Add a new resource to the resource pool. The resource is inserted into both the name map and type map so it can be located by either."}
{"type": "text", "page_from": 193, "page_to": 193, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=193", "section_title": "uvm_resource", "content": "An object creates a resources and sets it into the resource pool. Later, other objects that want to access the resource must get it from the pool"}
{"type": "text", "page_from": 193, "page_to": 193, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=193", "section_title": "uvm_resource", "content": "Overrides can be specified using this interface. Either a name override, a type override or both can be specified. If an override is specified then the resource is entered at the front of the queue instead of at the back. It is not recommended that users specify the override parameter directly, rather they use the set_override, set_name_override, or set_type_override functions."}
{"type": "text", "page_from": 193, "page_to": 193, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=193", "section_title": "uvm_resource", "content": "function void set_override( uvm_resource_base rsrc"}
{"type": "text", "page_from": 193, "page_to": 193, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=193", "section_title": "uvm_resource", "content": "The resource provided as an argument will be entered into the pool and will override both by name and type."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "The resource provided as an argument will be entered into the pool using normal precedence in the name map and will override the type."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "This group of functions is for finding resources in the resource database."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "lookup_name and lookup_type locate the set of resources that matches the name or type (respectively) and is visible in the current scope. These functions return a queue of resources."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "get_highest_precedence traverse a queue of resources and returns the one with the highest precedence -- i.e. the one whose precedence member has the highest value."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "get_by_name and get_by_type use lookup_name and lookup_type (respectively) and get_highest_precedence to find the resource with the highest priority that matches the other search criteria."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "function uvm_resource_types::rsrc_q_t lookup_name( string scope 三 string name, uvm_resource_base type_handle $=$ null, bit rpterr = 1 ）"}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "Lookup resources by name. Returns a queue of resources that match the name, scope, and type_handle. If no resources match the queue is returned empty. If rpterr is set then a warning is issued if no matches are found, and the spell checker is invoked on name. If type_handle is null then a type check is not made and resources are returned that match only name and scope."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "get_highest_precedence"}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "function uvm_resource_base get_highest_precedence( ref uvm_resource_types::rsrc_q_t q"}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "Traverse a queue, $q$ , of resources and return the one with the highest precedence. In the case where there exists more than one resource with the highest precedence value, the first one that has that precedence will be the one that is returned."}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "static function void sort_by_precedence( ref uvm_resource_types::rsrc_q_t q"}
{"type": "text", "page_from": 194, "page_to": 194, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=194", "section_title": "uvm_resource", "content": "Given a list of resources, obtained for example from lookup_scope, sort the resources in precedence order. The highest precedence resource will be first in the list and the lowest precedence will be last. Resources that have the same precedence and the same name"}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "will be ordered by most recently set first."}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "function uvm_resource_base get_by_name( string scope , string name, uvm_resource_base type_handle, bit rpterr = 1 )"}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "Lookup a resource by name, scope, and type_handle. Whether the get succeeds or fails, save a record of the get attempt. The rpterr flag indicates whether to report errors or not. Essentially, it serves as a verbose flag. If set then the spell checker will be invoked and warnings about multiple resources will be produced."}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "function uvm_resource_types::rsrc_q_t lookup_type( string scope uvm_resource_base type_handle )"}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "Lookup resources by type. Return a queue of resources that match the type_handle and scope. If no resources match then the returned queue is empty."}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "function uvm_resource_base get_by_type( string scope 11 , uvm_resource_base type_handle )"}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "Lookup a resource by type_handle and scope. Insert a record into the get history list whether or not the get succeeded."}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "function uvm_resource_types::rsrc_q_t lookup_regex_names( string scope, string name, uvm_resource_base type_handle $=$ null"}
{"type": "text", "page_from": 195, "page_to": 195, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=195", "section_title": "uvm_resource", "content": "This utility function answers the question, for a given name, scope, and type_handle, what are all of the resources with requested name, a matching scope (where the resource scope may be a regular expression), and a matching type? name and scope are explicit values."}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "Looks for all the resources whose name matches the regular expression argument and whose scope matches the current scope."}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "function uvm_resource_types::rsrc_q_t lookup_scope( string scope"}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "This is a utility function that answers the question: For a given scope, what resources are visible to it? Locate all the resources that are visible to a particular scope. This operation could be quite expensive, as it has to traverse all of the resources in the database."}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "Functions for altering the search priority of resources. Resources are stored in queues in the type and name maps. When retrieving resources, either by type or by name, the resource queue is search from front to back. The first one that matches the search criteria is the one that is returned. The set_priority functions let you change the order in which resources are searched. For any particular resource, you can set its priority to UVM_HIGH, in which case the resource is moved to the front of the queue, or to UVM_LOW in which case the resource is moved to the back of the queue."}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "function void set_priority_type( uvm_resource_base rsrc, uvm_resource_types::priority_e pri )"}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "Change the priority of the rsrc based on the value of $p r i$ , the priority enum argument. This function changes the priority only in the type map, leaving the name map untouched."}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "function void set_priority_name( uvm_resource_base rsrc, uvm_resource_types::priority_e pri )"}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "Change the priority of the rsrc based on the value of $p r i$ , the priority enum argument. This function changes the priority only in the name map, leaving the type map untouched."}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "function void set_priority ( uvm_resource_base rsrc, uvm_resource_types::priority_e pri )"}
{"type": "text", "page_from": 196, "page_to": 196, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=196", "section_title": "uvm_resource", "content": "Change the search priority of the rsrc based on the value of pri, the priority enum argument. This function changes the priority in both the name and type maps."}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "find_unused_resources"}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "function uvm_resource_types::rsrc_q_t find_unused_resources()"}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "Locate all the resources that have at least one write and no reads"}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "function void print_resources( uvm_resource_types::rsrc_q_t rq, bit audit = 0 )"}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "Print the resources that are in a single queue, rq. This is a utility function that can be used to print any collection of resources stored in a queue. The audit flag determines whether or not the audit trail is printed for each resource along with the name, value, and scope regular expression."}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "dump the entire resource pool. The resource pool is traversed and each resource is printed. The utility function print_resources() is used to initiate the printing. If the audit bit is set then the audit trail is dumped for each resource."}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "Parameterized resource. Provides essential access methods to read from and write to the resource database."}
{"type": "text", "page_from": 197, "page_to": 197, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=197", "section_title": "uvm_resource", "content": "Parameterized resource."}
{"type": "text", "page_from": 198, "page_to": 198, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=198", "section_title": "uvm_resource", "content": "Resources can be identified by type using a static type handle. The parent class provides the virtual function interface get_type_handle. Here we implement it by returning the static type handle."}
{"type": "text", "page_from": 198, "page_to": 198, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=198", "section_title": "uvm_resource", "content": "static function this_type get_type()"}
{"type": "text", "page_from": 198, "page_to": 198, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=198", "section_title": "uvm_resource", "content": "Static function that returns the static type handle. The return type is this_type, which is the type of the parameterized class."}
{"type": "text", "page_from": 198, "page_to": 198, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=198", "section_title": "uvm_resource", "content": "function uvm_resource_base get_type_handle()"}
{"type": "text", "page_from": 198, "page_to": 198, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=198", "section_title": "uvm_resource", "content": "Returns the static type handle of this resource in a polymorphic fashion. The return type of get_type_handle() is uvm_resource_base. This function is not static and therefore can only be used by instances of a parameterized resource."}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "uvm_resource#(T) provides an interface for setting and getting a resources. Specifically, a resource can insert itself into the resource pool. It doesn’t make sense for a resource to get itself, since you can’t call a function on a handle you don’t have. However, a static get interface is provided as a convenience. This obviates the need for the user to get a handle to the global resource pool as this is done for him here."}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "Simply put this resource into the global resource pool"}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "function void set_override("}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "Put a resource into the global resource pool as an override. This means it gets put at the head of the list and is searched before other existing resources that occupy the same position in the name map or the type map. The default is to override both the name and type maps. However, using the override argument you can specify that either the name map or type map is overridden."}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "static function this_type get_by_name( string scope, string name, bit rpterr = 1 )"}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "looks up a resource by name in the name map. The first resource with the specified name, whose type is the current type, and is visible in the specified scope is returned, if one exists. The rpterr flag indicates whether or not an error should be reported if the search fails. If rpterr is set to one then a failure message is issued, including suggested spelling alternatives, based on resource names that exist in the database, gathered by the spell checker."}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "static function this_type get_by_type( string scope , uvm_resource_base type_handle )"}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "looks up a resource by type_handle in the type map. The first resource with the specified type_handle that is visible in the specified scope is returned, if one exists. If there is no resource matching the specifications, null is returned."}
{"type": "text", "page_from": 199, "page_to": 199, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=199", "section_title": "uvm_resource", "content": "REAd/Wri TE INTEr FAcE"}
{"type": "text", "page_from": 200, "page_to": 200, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=200", "section_title": "uvm_resource", "content": "read and write provide a type-safe interface for getting and setting the object in the resource container. The interface is type safe because the value argument for write and the return value of read are ${ \\sf T } ,$ the type supplied in the class parameter. If either of these functions is used in an incorrect type context the compiler will complain."}
{"type": "text", "page_from": 200, "page_to": 200, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=200", "section_title": "uvm_resource", "content": "Return the object stored in the resource container. If an accessor object is supplied then also update the accessor record for this resource."}
{"type": "text", "page_from": 200, "page_to": 200, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=200", "section_title": "uvm_resource", "content": "function void write( T t, uvm_object accessor $=$ null ) Modify the object stored in this resource container. If the resource is read-only then issue an error message and return without modifying the object in the container. If the resource is not read-only and an accessor object has been supplied then also update the accessor record. Lastly, replace the object value in the container with the value supplied as the argument, $t ,$ and release any processes blocked on uvm_resource_base::wait_modified. If the value to be written is the same as the value already present in the resource then the write is not done. That also means that the accessor record is not updated and the modified bit is not set."}
{"type": "text", "page_from": 200, "page_to": 200, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=200", "section_title": "uvm_resource", "content": "Functions for manipulating the search priority of resources. These implementations of the interface defined in the base class delegate to the resource pool."}
{"type": "text", "page_from": 200, "page_to": 200, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=200", "section_title": "uvm_resource", "content": "Change the search priority of the resource based on the value of the priority enum argument, pri."}
{"type": "text", "page_from": 200, "page_to": 200, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=200", "section_title": "uvm_resource", "content": "get_highest_precedence"}
{"type": "text", "page_from": 200, "page_to": 200, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=200", "section_title": "uvm_resource", "content": "In a queue of resources, locate the first one with the highest precedence whose type is T. This function is static so that it can be called from anywhere."}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "UVM Resource Database", "header_path": ["10", "2"], "chapter": "10", "section": "10.2", "content": "10.2 UVM Resource Database"}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "UVM Resource Database"}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "The uvm_resource_db class provides a convenience interface for the resources facility. In many cases basic operations such as creating and setting a resource or getting a resource could take multiple lines of code using the interfaces in uvm_resource_base or uvm_resource#(T). The convenience layer in uvm_resource_db reduces many of those operations to a single line of code."}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "If the run-time +UVM_RESOURCE_DB_TRACE command line option is specified, all resource DB accesses (read and write) are displayed."}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "All of the functions in uvm_resource_db#(T) are static, so they must be called using the :: operator. For example:"}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "The parameter value “int” identifies the resource type as uvm_resource#(int). Thus, the type of the object in the resource container is int. This maintains the type-safety characteristics of resource operations."}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "All of the functions in uvm_resource_db#(T) are static, so they must be called using the :: operator."}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "class uvm_resource_db #( type T = uvm_object )"}
{"type": "text", "page_from": 201, "page_to": 201, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=201", "section_title": "uvm_resource_db", "content": "get_by_type Get a resource by type."}
{"type": "text", "page_from": 202, "page_to": 202, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=202", "section_title": "uvm_resource_db", "content": "static function rsrc_t get_by_type( string scope"}
{"type": "text", "page_from": 202, "page_to": 202, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=202", "section_title": "uvm_resource_db", "content": "Get a resource by type. The type is specified in the db class parameter so the only argument to this function is the scope."}
{"type": "text", "page_from": 202, "page_to": 202, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=202", "section_title": "uvm_resource_db", "content": "static function rsrc_t get_by_name( string scope, string name, bit rpterr = 1"}
{"type": "text", "page_from": 202, "page_to": 202, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=202", "section_title": "uvm_resource_db", "content": "Imports a resource by name. The first argument is the current scope of the resource to be retrieved and the second argument is the name. The rpterr flag indicates whether or not to generate a warning if no matching resource is found."}
{"type": "text", "page_from": 202, "page_to": 202, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=202", "section_title": "uvm_resource_db", "content": "static function rsrc_t set_default( string scope, string name"}
{"type": "text", "page_from": 202, "page_to": 202, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=202", "section_title": "uvm_resource_db", "content": "add a new item into the resources database. The item will not be written to so it will have its default value. The resource is created using name and scope as the lookup parameters."}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "Create a new resource, write a val to it, and set it into the database using name and scope as the lookup parameters. The accessor is used for auditing."}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "static function void set_anonymous( input string scope, T val, input uvm_object accessor $=$ null )"}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "Create a new resource, write a val to it, and set it into the database. The resource has no name and therefore will not be entered into the name map. But is does have a scope for lookup purposes. The accessor is used for auditing."}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "locate a resource by name and scope and read its value. The value is returned through the output argument val. The return value is a bit that indicates whether or not the read was successful. The accessor is used for auditing."}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "static function bit read_by_type( input string scope, inout T val, input uvm_object accessor $=$ null )"}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "Read a value by type. The value is returned through the output argument val. The scope is used for the lookup. The return value is a bit that indicates whether or not the read is successful. The accessor is used for auditing."}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "write a val into the resources database. First, look up the resource by name and scope. If it is not located then add a new resource to the database and then write its value."}
{"type": "text", "page_from": 203, "page_to": 203, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=203", "section_title": "uvm_resource_db", "content": "Because the scope is matched to a resource which may be a regular expression, and consequently may target other scopes beyond the scope argument. Care must be taken with this function. If a get_by_name match is found for name and scope then val will be written to that matching resource and thus may impact other scopes which also match the resource."}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "static function bit write_by_type( input string scope, input T val, input uvm_object accessor $=$ null"}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "write a val into the resources database. First, look up the resource by type. If it is not located then add a new resource to the database and then write its value."}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "Because the scope is matched to a resource which may be a regular expression, and consequently may target other scopes beyond the scope argument. Care must be taken with this function. If a get_by_name match is found for name and scope then val will be written to that matching resource and thus may impact other scopes which also match the resource."}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "static function void dump()"}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "Dump all the resources in the resource pool. This is useful for debugging purposes. This function does not use the parameter T, so it will dump the same thing -- the entire database -- no matter the value of the parameter."}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "uvm_resource_db_options"}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "Provides a namespace for managing options for the resources DB facility. The only thing allowed in this class is static local data members and static functions for manipulating and retrieving the value of the data members. The static local data members represent options and settings that control the behavior of the resources DB facility."}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "uvm_resource_db_options"}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "Provides a namespace for managing options for the resources DB facility."}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "turn_on_tracing Turn tracing on for the resource database. turn_off_tracing Turn tracing off for the resource database. is_tracing Returns 1 if the tracing facility is on and 0 if it is off."}
{"type": "text", "page_from": 204, "page_to": 204, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=204", "section_title": "uvm_resource_db", "content": "static function void turn_on_tracing()"}
{"type": "text", "page_from": 205, "page_to": 205, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=205", "section_title": "uvm_resource_db", "content": "Turn tracing on for the resource database. This causes all reads and writes to the database to display information about the accesses. Tracing is off by default."}
{"type": "text", "page_from": 205, "page_to": 205, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=205", "section_title": "uvm_resource_db", "content": "This method is implicitly called by the +UVM_RESOURCE_DB_TRACE."}
{"type": "text", "page_from": 205, "page_to": 205, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=205", "section_title": "uvm_resource_db", "content": "static function void turn_off_tracing()"}
{"type": "text", "page_from": 205, "page_to": 205, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=205", "section_title": "uvm_resource_db", "content": "Turn tracing off for the resource database."}
{"type": "text", "page_from": 205, "page_to": 205, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=205", "section_title": "uvm_resource_db", "content": "static function bit is_tracing()"}
{"type": "text", "page_from": 205, "page_to": 205, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=205", "section_title": "uvm_resource_db", "content": "Returns 1 if the tracing facility is on and 0 if it is off."}
{"type": "text", "page_from": 206, "page_to": 206, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=206", "section_title": "UVM Configuration Database", "header_path": ["10", "3"], "chapter": "10", "section": "10.3", "content": "10.3 UVM Configuration Database"}
{"type": "text", "page_from": 206, "page_to": 206, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=206", "section_title": "uvm_config_db", "content": "The uvm_config_db class provides a convenience interface on top of the uvm_resource_db to simplify the basic interface that is used for configuring uvm_component instances."}
{"type": "text", "page_from": 206, "page_to": 206, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=206", "section_title": "uvm_config_db", "content": "If the run-time +UVM_CONFIG_DB_TRACE command line option is specified, all configuration DB accesses (read and write) are displayed."}
{"type": "text", "page_from": 206, "page_to": 206, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=206", "section_title": "uvm_config_db", "content": "All of the functions in uvm_config_db#(T) are static, so they must be called using the :: operator. For example:"}
{"type": "text", "page_from": 206, "page_to": 206, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=206", "section_title": "uvm_config_db", "content": "The parameter value “int” identifies the configuration type as an int property."}
{"type": "text", "page_from": 206, "page_to": 206, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=206", "section_title": "uvm_config_db", "content": "The set and get methods provide the same API and semantics as the set/get_config_\\* functions in uvm_component."}
{"type": "text", "page_from": 206, "page_to": 206, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=206", "section_title": "uvm_config_db", "content": "All of the functions in uvm_config_db#(T) are static, so they must be called using"}
{"type": "text", "page_from": 207, "page_to": 207, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=207", "section_title": "uvm_config_db", "content": "Get the value for field_name in inst_name, using component cntxt as the starting search point. inst_name is an explicit instance name relative to cntxt and may be an empty string if the cntxt is the instance that the configuration object applies to. field_name is the specific field in the scope that is being searched for."}
{"type": "text", "page_from": 207, "page_to": 207, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=207", "section_title": "uvm_config_db", "content": "The basic get_config_\\* methods from uvm_component are mapped to this function as:"}
{"type": "text", "page_from": 208, "page_to": 208, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=208", "section_title": "uvm_config_db", "content": "information of the setting. field_name is the target field. Both inst_name and field_name may be glob style or regular expression style expressions."}
{"type": "text", "page_from": 208, "page_to": 208, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=208", "section_title": "uvm_config_db", "content": "If a setting is made at build time, the cntxt hierarchy is used to determine the setting’s precedence in the database. Settings from hierarchically higher levels have higher precedence. Settings from the same level of hierarchy have a last setting wins semantic. A precedence setting of uvm_resource_base::default_precedence is used for uvm_top, and each hierarchical level below the top is decremented by 1."}
{"type": "text", "page_from": 208, "page_to": 208, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=208", "section_title": "uvm_config_db", "content": "After build time, all settings use the default precedence and thus have a last wins semantic. So, if at run time, a low level component makes a runtime setting of some field, that setting will have precedence over a setting from the test level that was made earlier in the simulation."}
{"type": "text", "page_from": 208, "page_to": 208, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=208", "section_title": "uvm_config_db", "content": "The basic set_config_\\* methods from uvm_component are mapped to this function as:"}
{"type": "text", "page_from": 208, "page_to": 208, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=208", "section_title": "uvm_config_db", "content": "Check if a value for field_name is available in inst_name, using component cntxt as the starting search point. inst_name is an explicit instance name relative to cntxt and may be an empty string if the cntxt is the instance that the configuration object applies to. field_name is the specific field in the scope that is being searched for. The spell_chk arg can be set to 1 to turn spell checking on if it is expected that the field should exist in the database. The function returns 1 if a config parameter exists and 0 if it doesn’t exist."}
{"type": "text", "page_from": 208, "page_to": 208, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=208", "section_title": "uvm_config_db", "content": "Wait for a configuration setting to be set for field_name in cntxt and inst_name. The task blocks until a new configuration setting is applied that effects the specified field."}
{"type": "text", "page_from": 208, "page_to": 208, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=208", "section_title": "uvm_config_db", "content": "Convenience type for"}
{"type": "text", "page_from": 209, "page_to": 209, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=209", "section_title": "uvm_config_db", "content": "Convenience type for uvm_config_db#(uvm_bitstream_t)"}
{"type": "text", "page_from": 209, "page_to": 209, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=209", "section_title": "uvm_config_db", "content": "Convenience type for uvm_config_db#(string)"}
{"type": "text", "page_from": 209, "page_to": 209, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=209", "section_title": "uvm_config_db", "content": "Convenience type for uvm_config_db#(uvm_object)"}
{"type": "text", "page_from": 209, "page_to": 209, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=209", "section_title": "uvm_config_db", "content": "Convenience type for uvm_config_db#(uvm_object_wrapper)"}
{"type": "text", "page_from": 209, "page_to": 209, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=209", "section_title": "uvm_config_db", "content": "typedef uvm_config_db#(uvm_object_wrapper) uvm_config_wrapper;"}
{"type": "text", "page_from": 209, "page_to": 209, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=209", "section_title": "uvm_config_db", "content": "uvm_config_db_options"}
{"type": "text", "page_from": 209, "page_to": 209, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=209", "section_title": "uvm_config_db", "content": "Provides a namespace for managing options for the configuration DB facility. The only thing allowed in this class is static local data members and static functions for manipulating and retrieving the value of the data members. The static local data members represent options and settings that control the behavior of the configuration DB facility."}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "uvm_config_db_options"}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "Provides a namespace for managing options for the configuration DB facility."}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "turn_on_tracing Turn tracing on for the configuration database. turn_off_tracing Turn tracing off for the configuration database. is_tracing Returns 1 if the tracing facility is on and 0 if it is off."}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "static function void turn_on_tracing()"}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "Turn tracing on for the configuration database. This causes all reads and writes to the database to display information about the accesses. Tracing is off by default."}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "This method is implicitly called by the +UVM_CONFIG_DB_TRACE."}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "static function void turn_off_tracing()"}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "Turn tracing off for the configuration database."}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "static function bit is_tracing()"}
{"type": "text", "page_from": 210, "page_to": 210, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=210", "section_title": "uvm_config_db", "content": "Returns 1 if the tracing facility is on and 0 if it is off."}
{"type": "text", "page_from": 211, "page_to": 211, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=211", "section_title": "Synchronization Classes", "content": "11. Synchronization Classes"}
{"type": "text", "page_from": 211, "page_to": 211, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=211", "section_title": "Synchronization Classes", "content": "The UVM provides event and barrier synchronization classes for managing concurrent processes."}
{"type": "text", "page_from": 211, "page_to": 211, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=211", "section_title": "Synchronization Classes", "content": "uvm_event#(T) - UVM’s event class augments the SystemVerilog event datatype with such services as setting callbacks and data delivery. uvm_barrier - A barrier is used to prevent a pre-configured number of processes from continuing until all have reached a certain point in simulation. uvm_event_pool and uvm_barrier_pool - The event and barrier pool classes are specializations of uvm_object_string_pool #(T) used to store collections of uvm_event#(uvm_object) and uvm_barriers, respectively, indexed by string name. Each pool class contains a static, “global” pool instance for sharing across all processes. uvm_event_callback - The event callback is used to create callback objects that may be attached to uvm_event#(T)."}
{"type": "text", "page_from": 211, "page_to": 211, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=211", "section_title": "Synchronization Classes", "content": "Synchronization Classes"}
{"type": "text", "page_from": 212, "page_to": 212, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=212", "section_title": "uvm_event", "content": "The uvm_event_base class is an abstract wrapper class around the SystemVerilog event construct. It provides some additional services such as setting callbacks and maintaining the number of waiters."}
{"type": "text", "page_from": 212, "page_to": 212, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=212", "section_title": "uvm_event", "content": "uvm_event_base The uvm_event_base class is an abstract wrapper class around the SystemVerilog event construct. uvm_event#(T) The uvm_event class is an extension of the abstract uvm_event_base class."}
{"type": "text", "page_from": 212, "page_to": 212, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=212", "section_title": "uvm_event", "content": "Creates a new event object."}
{"type": "text", "page_from": 212, "page_to": 212, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=212", "section_title": "uvm_event", "content": "Waits for the event to be activated for the first time."}
{"type": "text", "page_from": 212, "page_to": 212, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=212", "section_title": "uvm_event", "content": "If the event has already been triggered, this task returns immediately. If delta is set, the caller will be forced to wait a single delta #0 before returning. This prevents the caller from returning before previously waiting processes have had a chance to resume."}
{"type": "text", "page_from": 212, "page_to": 212, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=212", "section_title": "uvm_event", "content": "Once an event has been triggered, it will be remain $\\ \" { \\mathsf { o } } { \\mathsf { n } } ^ { \\prime \\prime }$ until the event is reset."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "virtual task wait_trigger ()"}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "Waits for the event to be triggered."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "If one process calls wait_trigger in the same delta as another process calls uvm_event#(T)::trigger, a race condition occurs. If the call to wait occurs before the trigger, this method will return in this delta. If the wait occurs after the trigger, this method will not return until the next trigger, which may never occur and thus cause deadlock."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "virtual task wait_ptrigger ()"}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "Waits for a persistent trigger of the event. Unlike wait_trigger, this views the trigger as persistent within a given time-slice and thus avoids certain race conditions. If this method is called after the trigger but within the same time-slice, the caller returns immediately."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "virtual function time get_trigger_time ()"}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "Gets the time that this event was last triggered. If the event has not been triggered, or the event has been reset, then the trigger time will be 0."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "virtual function bit is_on ()"}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "Indicates whether the event has been triggered since it was last reset."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "A return of 1 indicates that the event has triggered."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "virtual function bit is_off ()"}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "Indicates whether the event has been triggered or been reset."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "A return of 1 indicates that the event has not been triggered."}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "virtual function void reset ( bit wakeup $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 213, "page_to": 213, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=213", "section_title": "uvm_event", "content": "Resets the event to its off state. If wakeup is set, then all processes currently waiting for the event are activated before the reset."}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "No callbacks are called during a reset."}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "virtual function void cancel ()"}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "Decrements the number of waiters on the event."}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "This is used if a process that is waiting on an event is disabled or activated by some other means."}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "virtual function int get_num_waiters ()"}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "Returns the number of processes waiting on the event."}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "The uvm_event class is an extension of the abstract uvm_event_base class."}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "The optional parameter $\\tau$ allows the user to define a data type which can be passed during an event trigger."}
{"type": "text", "page_from": 214, "page_to": 214, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=214", "section_title": "uvm_event", "content": "The uvm_event class is an extension of the abstract uvm_event_base class."}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "Creates a new event object."}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "virtual task wait_trigger_data ( output T data"}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "This method calls uvm_event_base::wait_trigger followed by get_trigger_data."}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "virtual task wait_ptrigger_data ( output T data"}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "This method calls uvm_event_base::wait_ptrigger followed by get_trigger_data."}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "virtual function void trigger ( T data $=$ null"}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "Triggers the event, resuming all waiting processes."}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "An optional data argument can be supplied with the enable to provide trigger-specific information."}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "virtual function T get_trigger_data ()"}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "Gets the data, if any, provided by the last call to trigger."}
{"type": "text", "page_from": 215, "page_to": 215, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=215", "section_title": "uvm_event", "content": "virtual function void add_callback ( uvm_event_callback#(T) cb, bit append = 1"}
{"type": "text", "page_from": 216, "page_to": 216, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=216", "section_title": "uvm_event", "content": "Registers a callback object, $c b _ { \\scriptscriptstyle \\perp }$ , with this event. The callback object may include pre_trigger and post_trigger functionality. If append is set to 1, the default, cb is added to the back of the callback list. Otherwise, cb is placed at the front of the callback list."}
{"type": "text", "page_from": 216, "page_to": 216, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=216", "section_title": "uvm_event", "content": "virtual function void delete_callback ( uvm_event_callback#(T) cb"}
{"type": "text", "page_from": 216, "page_to": 216, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=216", "section_title": "uvm_event", "content": "Unregisters the given callback, $c b$ , from this event."}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "header_path": ["11", "2"], "chapter": "11", "section": "11.2", "content": "11.2 uvm_event_callback"}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "content": "The uvm_event_callback class is an abstract class that is used to create callback objects which may be attached to uvm_event#(T)s. To use, you derive a new class and override any or both pre_trigger and post_trigger."}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "content": "Callbacks are an alternative to using processes that wait on events. When a callback is attached to an event, that callback object’s callback function is called each time the event is triggered."}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "content": "The uvm_event_callback class is an abstract class that is used to create callback objects which may be attached to uvm_event#(T)s."}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "content": "new Creates a new callback object. pre_trigger This callback is called just before triggering the associated event. post_trigger This callback is called after triggering the associated event."}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "content": "Creates a new callback object."}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "content": "virtual function bit pre_trigger ( uvm_event#(T) e, T data"}
{"type": "text", "page_from": 217, "page_to": 217, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=217", "section_title": "uvm_event_callback", "content": "This callback is called just before triggering the associated event. In a derived class, override this method to implement any pre-trigger functionality."}
{"type": "text", "page_from": 218, "page_to": 218, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=218", "section_title": "uvm_event_callback", "content": "If your callback returns 1, then the event will not trigger and the post-trigger callback is not called. This provides a way for a callback to prevent the event from triggering."}
{"type": "text", "page_from": 218, "page_to": 218, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=218", "section_title": "uvm_event_callback", "content": "In the function, e is the uvm_event#(T) that is being triggered, and data is the optional data associated with the event trigger."}
{"type": "text", "page_from": 218, "page_to": 218, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=218", "section_title": "uvm_event_callback", "content": "This callback is called after triggering the associated event. In a derived class, override this method to implement any post-trigger functionality."}
{"type": "text", "page_from": 218, "page_to": 218, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=218", "section_title": "uvm_event_callback", "content": "In the function, e is the uvm_event#(T) that is being triggered, and data is the optional data associated with the event trigger."}
{"type": "text", "page_from": 219, "page_to": 219, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=219", "section_title": "uvm_barrier", "content": "The uvm_barrier class provides a multiprocess synchronization mechanism. It enables a set of processes to block until the desired number of processes get to the synchronization point, at which time all of the processes are released."}
{"type": "text", "page_from": 219, "page_to": 219, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=219", "section_title": "uvm_barrier", "content": "The uvm_barrier class provides a multiprocess synchronization mechanism."}
{"type": "text", "page_from": 219, "page_to": 219, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=219", "section_title": "uvm_barrier", "content": "Creates a new barrier object."}
{"type": "text", "page_from": 219, "page_to": 219, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=219", "section_title": "uvm_barrier", "content": "virtual task wait_for()"}
{"type": "text", "page_from": 219, "page_to": 219, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=219", "section_title": "uvm_barrier", "content": "Waits for enough processes to reach the barrier before continuing."}
{"type": "text", "page_from": 219, "page_to": 219, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=219", "section_title": "uvm_barrier", "content": "The number of processes to wait for is set by the set_threshold method."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "virtual function void reset ( bit wakeup $= 1$"}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "Resets the barrier. This sets the waiter count back to zero."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "The threshold is unchanged. After reset, the barrier will force processes to wait for the threshold again."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "If the wakeup bit is set, any currently waiting processes will be activated."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "virtual function void set_auto_reset ( bit value $= 1$"}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "Determines if the barrier should reset itself after the threshold is reached."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "The default is on, so when a barrier hits its threshold it will reset, and new processes will block until the threshold is reached again."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "If auto reset is off, then once the threshold is achieved, new processes pass through without being blocked until the barrier is reset."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "Sets the process threshold."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "This determines how many processes must be waiting on the barrier before the processes may proceed."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "Once the threshold is reached, all waiting processes are activated."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "If threshold is set to a value less than the number of currently waiting processes, then the barrier is reset and waiting processes are activated."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "virtual function int get_threshold ()"}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "Gets the current threshold setting for the barrier."}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "virtual function int get_num_waiters ()"}
{"type": "text", "page_from": 220, "page_to": 220, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=220", "section_title": "uvm_barrier", "content": "Returns the number of processes currently waiting at the barrier."}
{"type": "text", "page_from": 221, "page_to": 221, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=221", "section_title": "uvm_barrier", "content": "virtual function void cancel ()"}
{"type": "text", "page_from": 221, "page_to": 221, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=221", "section_title": "uvm_barrier", "content": "Decrements the waiter count by one. This is used when a process that is waiting on the barrier is killed or activated by some other means."}
{"type": "text", "page_from": 222, "page_to": 222, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=222", "section_title": "Objection Mechanism", "header_path": ["11", "4"], "chapter": "11", "section": "11.4", "content": "11.4 Objection Mechanism"}
{"type": "text", "page_from": 222, "page_to": 222, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=222", "section_title": "uvm_objection", "content": "The following classes define the objection mechanism and end-of-test functionality, which is based on uvm_objection."}
{"type": "text", "page_from": 222, "page_to": 222, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=222", "section_title": "uvm_objection", "content": "Objections provide a facility for coordinating status information between two or more participating components, objects, and even module-based IP."}
{"type": "text", "page_from": 222, "page_to": 222, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=222", "section_title": "uvm_objection", "content": "Tracing of objection activity can be turned on to follow the activity of the objection mechanism. It may be turned on for a specific objection instance with uvm_objection::trace_mode, or it can be set for all objections from the command line using the option $+ \\mathsf { U V } \\mathsf { M }$ _OBJECTION_TRACE."}
{"type": "text", "page_from": 222, "page_to": 222, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=222", "section_title": "uvm_objection", "content": "Objections provide a facility for coordinating status information between two or more participating components, objects, and even module-based IP."}
{"type": "text", "page_from": 223, "page_to": 223, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=223", "section_title": "uvm_objection", "content": "Creates a new objection instance. Accesses the command line argument +UVM_OBJECTION_TRACE to turn tracing on for all objection objects."}
{"type": "text", "page_from": 223, "page_to": 223, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=223", "section_title": "uvm_objection", "content": "function bit trace_mode int mode $\\qquad = \\quad - 1$"}
{"type": "text", "page_from": 223, "page_to": 223, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=223", "section_title": "uvm_objection", "content": "Set or get the trace mode for the objection object. If no argument is specified (or an argument other than 0 or 1) the current trace mode is unaffected. A trace_mode of 0 turns tracing off. A trace mode of 1 turns tracing on. The return value is the mode prior to being reset."}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "we have the following basic component tree:"}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "Any objections raised by ‘child’ would get propagated down to parent, and then to uvm_test_top. Resulting in the following counts and totals:"}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "While propagations such as these can be useful, if they are unused by the testbench then they are simply an unnecessary performance hit. If the testbench is not going to use this functionality, then the performance can be improved by setting the propagation mode to 0."}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "When propagation mode is set to 0, all intermediate callbacks between the source and top will be skipped. This would result in the following counts and totals for the above objection:"}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "Since the propagation mode changes the behavior of the objection, it can only be safely changed if there are no objections raised or draining. Any attempts to change the mode while objections are raised or draining will result in an error."}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "function bit get_propagate_mode()"}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "Returns the propagation mode for this objection."}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "virtual function void raise_objection ( uvm_object obj $\\stackrel { \\cdot } { = }$ null, string int description count $=$ $= 1$ ,"}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "Raises the number of objections for the source object by count, which defaults to 1. The object is usually the this handle of the caller. If object is not specified or null, the implicit top-level component, uvm_root, is chosen."}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "Raising an objection causes the following."}
{"type": "text", "page_from": 224, "page_to": 224, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=224", "section_title": "uvm_objection", "content": "The source and total objection counts for object are increased by count. description is a string that marks a specific objection and is used in tracing/debug. The objection’s raised virtual method is called, which calls the"}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "uvm_component::raised method for all of the components up the hierarchy."}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "Drops the number of objections for the source object by count, which defaults to 1. The object is usually the this handle of the caller. If object is not specified or null, the implicit top-level component, uvm_root, is chosen."}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "Dropping an objection causes the following."}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "The source and total objection counts for object are decreased by count. It is an error to drop the objection count for object below zero. The objection’s dropped virtual method is called, which calls the uvm_component::dropped method for all of the components up the hierarchy. If the total objection count has not reached zero for object, then the drop is propagated up the object hierarchy as with raise_objection. Then, each object in the hierarchy will have updated their source counts--objections that they originated--and total counts--the total number of objections by them and all their descendants."}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "If the total objection count reaches zero, propagation up the hierarchy is deferred until a configurable drain-time has passed and the uvm_component::all_dropped callback for the current hierarchy level has returned. The following process occurs for each instance up the hierarchy from the source caller:"}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "A process is forked in a non-blocking fashion, allowing the drop call to return. The forked process then does the following:"}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "If a drain time was set for the given object, the process waits for that amount of time. The objection’s all_dropped virtual method is called, which calls the uvm_component::all_dropped method (if object is a component). The process then waits for the all_dropped callback to complete. After the drain time has elapsed and all_dropped callback has completed, propagation of the dropped objection to the parent proceeds as described in raise_objection, except as described below."}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "If a new objection for this object or any of its descendants is raised during the drain time or during execution of the all_dropped callback at any point, the hierarchical chain described above is terminated and the dropped callback does not go up the hierarchy. The raised objection will propagate up the hierarchy, but the number of raised propagated up is reduced by the number of drops that were pending waiting for the all_dropped/drain time completion. Thus, if exactly one objection caused the count to go to zero, and during the drain exactly one new objection comes in, no raises or drops are propagated up the hierarchy,"}
{"type": "text", "page_from": 225, "page_to": 225, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=225", "section_title": "uvm_objection", "content": "As an optimization, if the object has no set drain-time and no registered callbacks, the forked process can be skipped and propagation proceeds immediately to the parent as described."}
{"type": "text", "page_from": 226, "page_to": 226, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=226", "section_title": "uvm_objection", "content": "Immediately clears the objection state. All counts are cleared and the any processes waiting on a call to wait_for(UVM_ALL_DROPPED, uvm_top) are released."}
{"type": "text", "page_from": 226, "page_to": 226, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=226", "section_title": "uvm_objection", "content": "The caller, if a uvm_object-based object, should pass its ‘this’ handle to the obj argument to document who cleared the objection. Any drain_times set by the user are not affected."}
{"type": "text", "page_from": 226, "page_to": 226, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=226", "section_title": "uvm_objection", "content": "Sets the drain time on the given object to drain."}
{"type": "text", "page_from": 226, "page_to": 226, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=226", "section_title": "uvm_objection", "content": "The drain time is the amount of time to wait once all objections have been dropped before calling the all_dropped callback and propagating the objection to the parent."}
{"type": "text", "page_from": 226, "page_to": 226, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=226", "section_title": "uvm_objection", "content": "If a new objection for this object or any of its descendants is raised during the drain time or during execution of the all_dropped callbacks, the drain_time/all_dropped execution is terminated."}
{"type": "text", "page_from": 226, "page_to": 226, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=226", "section_title": "uvm_objection", "content": "Objection callback that is called when a raise_objection has reached obj. The default implementation calls uvm_component::raised."}
{"type": "text", "page_from": 226, "page_to": 226, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=226", "section_title": "uvm_objection", "content": "Objection callback that is called when a drop_objection has reached obj. The default implementation calls uvm_component::dropped."}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "Objection callback that is called when a drop_objection has reached obj, and the total count for obj goes to zero. This callback is executed after the drain time associated with obj. The default implementation calls uvm_component::all_dropped."}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "function void get_objectors( ref uvm_object list[\\$]"}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "Returns the current list of objecting objects (objects that raised an objection but have not dropped it)."}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "task wait_for( uvm_objection_event objt_event, uvm_object obj = null )"}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "Waits for the raised, dropped, or all_dropped event to occur in the given obj. The task returns after all corresponding callbacks for that event have been executed."}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "function int get_objection_count ( uvm_object obj $\\stackrel { } { = }$ null"}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "Returns the current number of objections raised by the given object."}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "function int get_objection_total ( uvm_object obj $\\stackrel { } { = }$ null"}
{"type": "text", "page_from": 227, "page_to": 227, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=227", "section_title": "uvm_objection", "content": "Returns the current number of objections raised by the given object and all descendants."}
{"type": "text", "page_from": 228, "page_to": 228, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=228", "section_title": "uvm_objection", "content": "Displays objection information about the given object. If object is not specified or null, the implicit top-level component, uvm_root, is chosen. The show_header argument allows control of whether a header is output."}
{"type": "text", "page_from": 228, "page_to": 228, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=228", "section_title": "uvm_objection", "content": "uvm_objection_callback"}
{"type": "text", "page_from": 228, "page_to": 228, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=228", "section_title": "uvm_objection", "content": "The uvm_objection is the callback type that defines the callback implementations for an objection callback. A user uses the callback type uvm_objection_cbs_t to add callbacks to specific objections."}
{"type": "text", "page_from": 228, "page_to": 228, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=228", "section_title": "uvm_objection", "content": "uvm_objection_callback"}
{"type": "text", "page_from": 228, "page_to": 228, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=228", "section_title": "uvm_objection", "content": "The uvm_objection is the callback type that defines the callback implementations for an objection callback."}
{"type": "text", "page_from": 228, "page_to": 228, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=228", "section_title": "uvm_objection", "content": "class uvm_objection_callback extends uvm_callback"}
{"type": "text", "page_from": 228, "page_to": 228, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=228", "section_title": "uvm_objection", "content": "raised Objection raised callback function. dropped Objection dropped callback function. all_dropped Objection all_dropped callback function."}
{"type": "text", "page_from": 229, "page_to": 229, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=229", "section_title": "uvm_objection", "content": "Objection raised callback function. Called by uvm_objection::raised."}
{"type": "text", "page_from": 229, "page_to": 229, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=229", "section_title": "uvm_objection", "content": "Objection dropped callback function. Called by uvm_objection::dropped."}
{"type": "text", "page_from": 229, "page_to": 229, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=229", "section_title": "uvm_objection", "content": "Objection all_dropped callback function. Called by uvm_objection::all_dropped."}
{"type": "text", "page_from": 230, "page_to": 230, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=230", "section_title": "uvm_heartbeat", "content": "Heartbeats provide a way for environments to easily ensure that their descendants are alive. A uvm_heartbeat is associated with a specific objection object. A component that is being tracked by the heartbeat object must raise (or drop) the synchronizing objection during the heartbeat window."}
{"type": "text", "page_from": 230, "page_to": 230, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=230", "section_title": "uvm_heartbeat", "content": "The uvm_heartbeat object has a list of participating objects. The heartbeat can be configured so that all components (UVM_ALL_ACTIVE), exactly one (UVM_ONE_ACTIVE), or any component (UVM_ANY_ACTIVE) must trigger the objection in order to satisfy the heartbeat condition."}
{"type": "text", "page_from": 230, "page_to": 230, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=230", "section_title": "uvm_heartbeat", "content": "Heartbeats provide a way for environments to easily ensure that their descendants are alive."}
{"type": "text", "page_from": 230, "page_to": 230, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=230", "section_title": "uvm_heartbeat", "content": "function new( string name, uvm_component cntxt, uvm_objection objection $=$ null"}
{"type": "text", "page_from": 230, "page_to": 230, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=230", "section_title": "uvm_heartbeat", "content": "Creates a new heartbeat instance associated with cntxt. The context is the hierarchical location that the heartbeat objections will flow through and be monitored at. The objection associated with the heartbeat is optional, if it is left null but it must be set before the heartbeat monitor will activate."}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "function uvm_heartbeat_modes set_mode ( uvm_heartbeat_modes mode $=$ UVM_NO_HB_MODE"}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "Sets or retrieves the heartbeat mode. The current value for the heartbeat mode is returned. If an argument is specified to change the mode then the mode is changed to the new value."}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "Sets up the heartbeat event and assigns a list of objects to watch. The monitoring is started as soon as this method is called. Once the monitoring has been started with a specific event, providing a new monitor event results in an error. To change trigger events, you must first stop the monitor and then start with a new event trigger."}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "If the trigger event e is null and there was no previously set trigger event, then the monitoring is not started. Monitoring can be started by explicitly calling start."}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "function void add ( uvm_component comp"}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "Add a single component to the set of components to be monitored. This does not cause monitoring to be started. If monitoring is currently active then this component will be immediately added to the list of components and will be expected to participate in the currently active event window."}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "function void remove ( uvm_component comp )"}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "Remove a single component to the set of components being monitored. Monitoring is not stopped, even if the last component has been removed (an explicit stop is required)."}
{"type": "text", "page_from": 231, "page_to": 231, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=231", "section_title": "uvm_heartbeat", "content": "Starts the heartbeat monitor. If e is null then whatever event was previously set is used. If no event was previously set then a warning is issued. It is an error if the monitor is currently running and $e$ is specifying a different trigger event from the current event."}
{"type": "text", "page_from": 232, "page_to": 232, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=232", "section_title": "uvm_heartbeat", "content": "function void stop ()"}
{"type": "text", "page_from": 232, "page_to": 232, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=232", "section_title": "uvm_heartbeat", "content": "Stops the heartbeat monitor. Current state information is reset so that if start is called again the process will wait for the first event trigger to start the monitoring."}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "Callbacks Classes", "header_path": ["11", "6"], "chapter": "11", "section": "11.6", "content": "11.6 Callbacks Classes"}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "uvm_callback", "content": "This section defines the classes used for callback registration, management, and userdefined callbacks."}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "uvm_callback", "content": "uvm_callbacks #(T,CB)"}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "uvm_callback", "content": "The uvm_callbacks class provides a base class for implementing callbacks, which are typically used to modify or augment component behavior without changing the component class. To work effectively, the developer of the component class defines a set of “hook” methods that enable users to customize certain behaviors of the component in a manner that is controlled by the component developer. The integrity of the component’s overall behavior is intact, while still allowing certain customizable actions by the user."}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "uvm_callback", "content": "To enable compile-time type-safety, the class is parameterized on both the user-defined callback interface implementation as well as the object type associated with the callback. The object type-callback type pair are associated together using the \\`uvm_register_cb macro to define a valid pairing; valid pairings are checked when a user attempts to add a callback to an object."}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "uvm_callback", "content": "To provide the most flexibility for end-user customization and reuse, it is recommended that the component developer also define a corresponding set of virtual method hooks in the component itself. This affords users the ability to customize via inheritance/factory overrides as well as callback object registration. The implementation of each virtual method would provide the default traversal algorithm for the particular callback being called. Being virtual, users can define subtypes that override the default algorithm, perform tasks before and/or after calling super.method to execute any registered callbacks, or to not call the base implementation, effectively disabling that particular hook. A demonstration of this methodology is provided in an example included in the kit."}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "uvm_callback", "content": "uvm_callbacks #(T,CB)"}
{"type": "text", "page_from": 233, "page_to": 233, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=233", "section_title": "uvm_callback", "content": "The uvm_callbacks class provides a base class for implementing callbacks, which are typically used to modify or augment component behavior without changing the component class."}
{"type": "text", "page_from": 234, "page_to": 234, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=234", "section_title": "uvm_callback", "content": "This type parameter specifies the base object type with which the CB callback objects will be registered. This object must be a derivative of uvm_object."}
{"type": "text", "page_from": 234, "page_to": 234, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=234", "section_title": "uvm_callback", "content": "This type parameter specifies the base callback type that will be managed by this callback class. The callback type is typically a interface class, which defines one or more virtual method prototypes that users can override in subtypes. This type must be a derivative of uvm_callback."}
{"type": "text", "page_from": 234, "page_to": 234, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=234", "section_title": "uvm_callback", "content": "Add /dELEt E INt ERFAcE"}
{"type": "text", "page_from": 235, "page_to": 235, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=235", "section_title": "uvm_callback", "content": "static function void add( T obj, uvm_callback cb, uvm_apprepend ordering $=$ UVM_APPEND"}
{"type": "text", "page_from": 235, "page_to": 235, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=235", "section_title": "uvm_callback", "content": "Registers the given callback object, cb, with the given obj handle. The obj handle can be null, which allows registration of callbacks without an object context. If ordering is UVM_APPEND (default), the callback will be executed after previously added callbacks, else the callback will be executed ahead of previously added callbacks. The cb is the callback handle; it must be non-null, and if the callback has already been added to the object instance then a warning is issued. Note that the CB parameter is optional. For example, the following are equivalent:"}
{"type": "text", "page_from": 235, "page_to": 235, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=235", "section_title": "uvm_callback", "content": "static function void add_by_name( string name, uvm_callback cb, uvm_component root, uvm_apprepend ordering $=$ UVM_APPEND"}
{"type": "text", "page_from": 235, "page_to": 235, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=235", "section_title": "uvm_callback", "content": "Registers the given callback object, $c b$ , with one or more uvm_components. The components must already exist and must be type T or a derivative. As with add the CB parameter is optional. root specifies the location in the component hierarchy to start the search for name. See uvm_root::find_all for more details on searching by name."}
{"type": "text", "page_from": 235, "page_to": 235, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=235", "section_title": "uvm_callback", "content": "static function void delete( T obj, uvm_callback cb"}
{"type": "text", "page_from": 235, "page_to": 235, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=235", "section_title": "uvm_callback", "content": "Deletes the given callback object, cb, from the queue associated with the given obj handle. The obj handle can be null, which allows de-registration of callbacks without an object context. The cb is the callback handle; it must be non-null, and if the callback has already been removed from the object instance then a warning is issued. Note that the CB parameter is optional. For example, the following are equivalent:"}
{"type": "text", "page_from": 235, "page_to": 235, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=235", "section_title": "uvm_callback", "content": "static function void delete_by_name( string name, uvm_callback cb, uvm_component root )"}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "Removes the given callback object, cb, associated with one or more uvm_component callback queues. As with delete the CB parameter is optional. root specifies the location in the component hierarchy to start the search for name. See uvm_root::find_all for more details on searching by name."}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "It ERAt OR INt ERFAcE"}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "This set of functions provide an iterator interface for callback queues. A facade class, uvm_callback_iter is also available, and is the generally preferred way to iterate over callback queues."}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "static function CB get_first ( ref int itr, input T obj"}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "Returns the first enabled callback of type CB which resides in the queue for obj. If obj is null then the typewide queue for T is searched. itr is the iterator; it will be updated with a value that can be supplied to get_next to get the next callback object."}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "If the queue is empty then null is returned."}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "The iterator class uvm_callback_iter may be used as an alternative, simplified, iterator interface."}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "static function CB get_last ( ref int itr, input T obj )"}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "Returns the last enabled callback of type CB which resides in the queue for obj. If obj is null then the typewide queue for T is searched. itr is the iterator; it will be updated with a value that can be supplied to get_prev to get the previous callback object."}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "If the queue is empty then null is returned."}
{"type": "text", "page_from": 236, "page_to": 236, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=236", "section_title": "uvm_callback", "content": "The iterator class uvm_callback_iter may be used as an alternative, simplified, iterator interface."}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "return null in this case until get_first or get_last has been used to reset the iterator."}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "The iterator class uvm_callback_iter may be used as an alternative, simplified, iterator interface."}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "static function CB get_prev ( ref int itr, input T obj )"}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "Returns the previous enabled callback of type CB which resides in the queue for obj, using itr as the starting point. If obj is null then the typewide queue for T is searched. itr is the iterator; it will be updated with a value that can be supplied to get_prev to get the previous callback object."}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "If no more callbacks exist in the queue, then null is returned. get_prev will continue to return null in this case until get_first or get_last has been used to reset the iterator."}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "The iterator class uvm_callback_iter may be used as an alternative, simplified, iterator interface."}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "static function void display( T obj $=$ null"}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "This function displays callback information for obj. If obj is null, then it displays callback information for all objects of type $T ,$ including typewide callbacks."}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "The uvm_callback_iter class is an iterator class for iterating over callback queues of a specific callback type. The typical usage of the class is:"}
{"type": "text", "page_from": 237, "page_to": 237, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=237", "section_title": "uvm_callback", "content": "The callback iteration macros, \\`uvm_do_callbacks and \\`uvm_do_callbacks_exit_on provide a simple method for iterating callbacks and executing the callback methods."}
{"type": "text", "page_from": 238, "page_to": 238, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=238", "section_title": "uvm_callback", "content": "The uvm_callback_iter class is an iterator class for iterating over callback queues of a specific callback type."}
{"type": "text", "page_from": 238, "page_to": 238, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=238", "section_title": "uvm_callback", "content": "class uvm_callback_iter#( type T $=$ uvm_object, type CB $=$ uvm_callback"}
{"type": "text", "page_from": 238, "page_to": 238, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=238", "section_title": "uvm_callback", "content": "Creates a new callback iterator object. It is required that the object context be provided."}
{"type": "text", "page_from": 238, "page_to": 238, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=238", "section_title": "uvm_callback", "content": "Returns the first valid (enabled) callback of the callback type (or a derivative) that is in the queue of the context object. If the queue is empty then null is returned."}
{"type": "text", "page_from": 238, "page_to": 238, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=238", "section_title": "uvm_callback", "content": "Returns the last valid (enabled) callback of the callback type (or a derivative) that is in the queue of the context object. If the queue is empty then null is returned."}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "Returns the previous valid (enabled) callback of the callback type (or a derivative) that is in the queue of the context object. If there are no more valid callbacks in the queue, then null is returned."}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "function CB get_cb()"}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "Returns the last callback accessed via a first() or next() call."}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "The uvm_callback class is the base class for user-defined callback classes. Typically, the component developer defines an application-specific callback class that extends from this class. In it, he defines one or more virtual methods, called a callback interface, that represent the hooks available for user override."}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "Methods intended for optional override should not be declared pure. Usually, all the callback methods are defined with empty implementations so users have the option of overriding any or all of them."}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "The prototypes for each hook method are completely application specific with no restrictions."}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "The uvm_callback class is the base class for user-defined callback classes."}
{"type": "text", "page_from": 239, "page_to": 239, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=239", "section_title": "uvm_callback", "content": "class uvm_callback extends uvm_object"}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "function new( string name $=$ \"uvm_callback\" )"}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "Creates a new uvm_callback object, giving it an optional name."}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "function bit callback_mode( int on = -1"}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "Enable/disable callbacks (modeled like rand_mode and constraint_mode)."}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "function bit is_enabled()"}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "Returns 1 if the callback is enabled, 0 otherwise."}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "virtual function string get_type_name()"}
{"type": "text", "page_from": 240, "page_to": 240, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=240", "section_title": "uvm_callback", "content": "Returns the type name of this callback object."}
{"type": "text", "page_from": 241, "page_to": 241, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=241", "section_title": "Container Classes", "content": "12. Container Classes"}
{"type": "text", "page_from": 241, "page_to": 241, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=241", "section_title": "Container Classes", "content": "The container classes are type parameterized data structures. The uvm_queue #(T) class implements a queue datastructure similar to the SystemVerilog queue construct. And the uvm_pool #(KEY,T) class implements a pool datastructure similar to the SystemVerilog associative array. The class based data structures allow the objects to be shared by reference; for example, a copy of a uvm_pool #(KEY,T) object will copy just the class handle instead of the entire associative array."}
{"type": "text", "page_from": 241, "page_to": 241, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=241", "section_title": "Container Classes", "content": "The container classes are type parameterized data structures."}
{"type": "text", "page_from": 242, "page_to": 242, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=242", "section_title": "uvm_pool", "content": "This section defines the uvm_pool #(KEY, T) class and derivative."}
{"type": "text", "page_from": 242, "page_to": 242, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=242", "section_title": "uvm_pool", "content": "Implements a class-based dynamic associative array. Allows sparse arrays to be allocated on demand, and passed and stored by reference."}
{"type": "text", "page_from": 242, "page_to": 242, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=242", "section_title": "uvm_pool", "content": "Implements a class-based dynamic associative array."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "Creates a new pool with the given name."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "static function this_type get_global_pool ()"}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "Returns the singleton global pool for the item type, T."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "This allows items to be shared amongst components throughout the verification environment."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "Returns the specified item instance from the global item pool."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "Returns the item with the given key."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "If no item exists by that key, a new item is created with that key and returned."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "virtual function void add ( KEY key, T item"}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "Adds the given (key, item) pair to the pool. If an item already exists at the given key it is overwritten with the new item."}
{"type": "text", "page_from": 243, "page_to": 243, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=243", "section_title": "uvm_pool", "content": "virtual function int num ()"}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "Returns the number of uniquely keyed items stored in the pool."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "virtual function void delete ( KEY key"}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "Removes the item with the given key from the pool."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "virtual function int exists ( KEY key"}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "Returns 1 if an item with the given key exists in the pool, 0 otherwise."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "virtual function int first ( ref KEY key"}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "Returns the key of the first item stored in the pool."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "If the pool is empty, then key is unchanged and 0 is returned."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "If the pool is not empty, then key is key of the first item and 1 is returned."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "virtual function int last ( ref KEY key"}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "Returns the key of the last item stored in the pool."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "If the pool is empty, then 0 is returned and key is unchanged."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "If the pool is not empty, then key is set to the last key in the pool and 1 is returned."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "virtual function int next ( ref KEY key"}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "Returns the key of the next item in the pool."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "If the input key is the last key in the pool, then key is left unchanged and 0 is returned."}
{"type": "text", "page_from": 244, "page_to": 244, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=244", "section_title": "uvm_pool", "content": "If a next key is found, then key is updated with that key and 1 is returned."}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "virtual function int prev ( ref KEY key"}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "Returns the key of the previous item in the pool."}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "If the input key is the first key in the pool, then key is left unchanged and 0 is returned."}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "If a previous key is found, then key is updated with that key and 1 is returned."}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "uvm_object_string_pool #(T)"}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "This provides a specialization of the generic uvm_pool #(KEY,T) class for an associative array of uvm_object-based objects indexed by string. Specializations of this class include the uvm_event_pool (a uvm_object_string_pool storing uvm_event#(uvm_object)) and uvm_barrier_pool (a uvm_obejct_string_pool storing uvm_barrier)."}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "uvm_object_string_pool #(T)"}
{"type": "text", "page_from": 245, "page_to": 245, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=245", "section_title": "uvm_pool", "content": "This provides a specialization of the generic uvm_pool #(KEY,T) class for an associative array of uvm_object-based objects indexed by string."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "Creates a new pool with the given name."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "virtual function string get_type_name()"}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "Returns the type name of this object."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "static function this_type get_global_pool ()"}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "Returns the singleton global pool for the item type, T."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "This allows items to be shared amongst components throughout the verification environment."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "static function T get_global ( string key"}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "Returns the specified item instance from the global item pool."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "virtual function T get ( string key"}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "Returns the object item at the given string key."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "If no item exists by the given $k e y$ , a new item is created for that key and returned."}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "virtual function void delete ( string key"}
{"type": "text", "page_from": 246, "page_to": 246, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=246", "section_title": "uvm_pool", "content": "Removes the item with the given string key from the pool."}
{"type": "text", "page_from": 247, "page_to": 247, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=247", "section_title": "uvm_queue", "content": "Implements a class-based dynamic queue. Allows queues to be allocated on demand, and passed and stored by reference."}
{"type": "text", "page_from": 247, "page_to": 247, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=247", "section_title": "uvm_queue", "content": "Implements a class-based dynamic queue."}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "Returns the singleton global queue for the item type, T."}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "This allows items to be shared amongst components throughout the verification environment."}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "static function T get_global ( int index"}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "Returns the specified item instance from the global item queue."}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "Returns the item at the given index."}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "If no item exists by that key, a new item is created with that key and returned."}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "virtual function int size ()"}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "Returns the number of items stored in the queue."}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "virtual function void insert ( int index, T item"}
{"type": "text", "page_from": 248, "page_to": 248, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=248", "section_title": "uvm_queue", "content": "Inserts the item at the given index in the queue."}
{"type": "text", "page_from": 249, "page_to": 249, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=249", "section_title": "uvm_queue", "content": "virtual function T pop_back()"}
{"type": "text", "page_from": 249, "page_to": 249, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=249", "section_title": "uvm_queue", "content": "Returns the last element in the queue (index $=$ size()-1), or null if the queue is empty."}
{"type": "text", "page_from": 249, "page_to": 249, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=249", "section_title": "uvm_queue", "content": "virtual function void push_front( T item"}
{"type": "text", "page_from": 249, "page_to": 249, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=249", "section_title": "uvm_queue", "content": "Inserts the given item at the front of the queue."}
{"type": "text", "page_from": 249, "page_to": 249, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=249", "section_title": "uvm_queue", "content": "virtual function void push_back( T item"}
{"type": "text", "page_from": 249, "page_to": 249, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=249", "section_title": "uvm_queue", "content": "Inserts the given item at the back of the queue."}
{"type": "text", "page_from": 250, "page_to": 250, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=250", "section_title": "TLM Interfaces", "content": "The UVM TLM library defines several abstract, transaction-level interfaces and the ports and exports that facilitate their use. Each TLM interface consists of one or more methods used to transport data, typically whole transactions (objects) at a time. Component designs that use TLM ports and exports to communicate are inherently more reusable, interoperable, and modular."}
{"type": "text", "page_from": 250, "page_to": 250, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=250", "section_title": "TLM Interfaces", "content": "The UVM TLM library specifies the required behavior (semantic) of each interface method. Classes (components) that implement a TLM interface must meet the specified semantic."}
{"type": "text", "page_from": 250, "page_to": 250, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=250", "section_title": "TLM Interfaces", "content": "The UVM TLM library defines several abstract, transaction-level interfaces and the ports and exports that facilitate their use."}
{"type": "text", "page_from": 250, "page_to": 250, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=250", "section_title": "TLM Interfaces", "content": "The TLM1 ports provide blocking and non-blocking pass-by-value transaction-level interfaces. The semantics of these interfaces are limited to message passing."}
{"type": "text", "page_from": 250, "page_to": 250, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=250", "section_title": "TLM Interfaces", "content": "The TLM2 sockets provide blocking and non-blocking transaction-level interfaces with well-defined completion semantics."}
{"type": "text", "page_from": 250, "page_to": 250, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=250", "section_title": "TLM Interfaces", "content": "A push or pull port, with well-defined completion semantics. It is used to connect sequencers with drivers and layering sequences."}
{"type": "text", "page_from": 250, "page_to": 250, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=250", "section_title": "TLM Interfaces", "content": "The analysis interface is used to perform non-blocking broadcasts of transactions to connected components. It is typically used by such components as monitors to publish transactions observed on a bus to its subscribers, which are typically scoreboards and response/coverage collectors."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "14. TLM1 Interfaces, Ports, Exports and TransportInterfaces"}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "Each TLM1 interface is either blocking, non-blocking, or a combination of these two."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "A blocking interface conveys transactions in blocking fashion; its methods do not return until the transaction has been successfully sent or retrieved. Because delivery may consume time to complete, the methods in such an interface are declared as tasks."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "A non-blocking interface attempts to convey a transaction without consuming simulation time. Its methods are declared as functions. Because delivery may fail (e.g. the target component is busy and cannot accept the request), the methods may return with failed status."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "A combination interface contains both the blocking and nonblocking variants. In SystemC, combination interfaces are defined through multiple inheritance. Because SystemVerilog does not support multiple inheritance, the UVM emulates hierarchical interfaces via a common base class and interface mask."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "Like their SystemC counterparts, the UVM’s TLM port and export implementations allow connections between ports whose interfaces are not an exact match. For example, a uvm_blocking_get_port can be connected to any port, export or imp port that provides at the least an implementation of the blocking_get interface, which includes the uvm_get_\\* ports and exports, uvm_blocking_get_peek_\\* ports and exports, and uvm_get_peek_\\* ports and exports."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "The sections below provide and overview of the unidirectional and bidirectional TLM interfaces, ports, and exports."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "TLM1 Interfaces, Ports, Exports and Transport Interfaces"}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "Each TLM1 interface is either blocking, non-blocking, or a combination of these two."}
{"type": "text", "page_from": 251, "page_to": 251, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=251", "section_title": "TLM1", "content": "The unidirectional TLM interfaces consist of blocking, nonblocking, and combined blocking and non-blocking variants of the put, get and peek interfaces, plus a non-blocking analysis interface."}
{"type": "text", "page_from": 252, "page_to": 252, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=252", "section_title": "TLM1", "content": "UNi Di ReCti ONAl INte RFACes & PORts"}
{"type": "text", "page_from": 252, "page_to": 252, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=252", "section_title": "TLM1", "content": "The unidirectional TLM interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the put, get and peek interfaces, plus a nonblocking analysis interface."}
{"type": "text", "page_from": 252, "page_to": 252, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=252", "section_title": "TLM1", "content": "The put interfaces are used to send, or put, transactions to other components. Successful completion of a put guarantees its delivery, not execution."}
{"type": "text", "page_from": 252, "page_to": 252, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=252", "section_title": "TLM1", "content": "The get interfaces are used to retrieve transactions from other components. The peek interfaces are used for the same purpose, except the retrieved transaction is not consumed; successive calls to peek will return the same object. Combined get_peek interfaces are also defined."}
{"type": "text", "page_from": 253, "page_to": 253, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=253", "section_title": "TLM1", "content": "Ports, Exports, and Imps"}
{"type": "text", "page_from": 253, "page_to": 253, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=253", "section_title": "TLM1", "content": "The UVM provides unidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces."}
{"type": "text", "page_from": 253, "page_to": 253, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=253", "section_title": "TLM1", "content": "Ports instantiated in components that require, or use, the associate interface to initiate transaction requests. Exports instantiated by components that forward an implementation of the methods defined in the associated interface. The implementation is typically provided by an imp port in a child component. Imps instantiated by components that provide or implement an implementation of the methods defined in the associated interface."}
{"type": "text", "page_from": 254, "page_to": 254, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=254", "section_title": "TLM1", "content": "A summary of port, export, and imp declarations are"}
{"type": "text", "page_from": 254, "page_to": 254, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=254", "section_title": "TLM1", "content": "where the asterisk can be any of"}
{"type": "text", "page_from": 254, "page_to": 254, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=254", "section_title": "TLM1", "content": "The bidirectional interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the transport, master, and slave interfaces."}
{"type": "text", "page_from": 254, "page_to": 254, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=254", "section_title": "TLM1", "content": "Bidirectional interfaces involve both a transaction request and response."}
{"type": "text", "page_from": 254, "page_to": 254, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=254", "section_title": "TLM1", "content": "The transport interface sends a request transaction and returns a response transaction in a single task call, thereby enforcing an in-order execution semantic. The request and response transactions can be different types."}
{"type": "text", "page_from": 254, "page_to": 254, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=254", "section_title": "TLM1", "content": "The primitive, unidirectional put, get, and peek interfaces are combined to form bidirectional master and slave interfaces. The master puts requests and gets or peeks responses. The slave gets or peeks requests and puts responses. Because the put and the get come from different function interface methods, the requests and responses are not coupled as they are with the transport interface."}
{"type": "text", "page_from": 255, "page_to": 255, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=255", "section_title": "TLM1", "content": "Ports, Exports, and Imps"}
{"type": "text", "page_from": 255, "page_to": 255, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=255", "section_title": "TLM1", "content": "The UVM provides bidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces."}
{"type": "text", "page_from": 256, "page_to": 256, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=256", "section_title": "TLM1", "content": "A summary of port, export, and imp declarations are class uvm \\*_port #(type REQ $^ { 1 = }$ int, RSP $=$ int) extends uvm_port_base #(tlm_if_base #(REQ, RSP)); class uvm \\*_export #(type REQ=int, RSP=int) extends uvm_port_base #(tlm_if_base #(REQ, RSP)); class uvm_\\*_imp #(type REQ=int, RSP=int) extends uvm_port_base #(tlm_if_base #(REQ, RSP));"}
{"type": "text", "page_from": 256, "page_to": 256, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=256", "section_title": "TLM1", "content": "where the asterisk can be any of"}
{"type": "text", "page_from": 256, "page_to": 256, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=256", "section_title": "TLM1", "content": "This example illustrates basic TLM connectivity using the blocking put interface."}
{"type": "text", "page_from": 257, "page_to": 257, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=257", "section_title": "TLM1", "content": "port-to-port leaf1’s out port is connected to its parent’s (comp1) out port port-to-export comp1’s out port is connected to comp2’s in export export-to-export comp2’s in export is connected to its child’s (subcomp2) in export export-to-imp subcomp2’s in export is connected leaf2’s in imp port. imp-to-implementation leaf2’s in imp port is connected to its implementation, leaf2"}
{"type": "text", "page_from": 257, "page_to": 257, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=257", "section_title": "TLM1", "content": "Hierarchical port connections are resolved and optimized just before uvm_component::end_of_elaboration_phase. After optimization, calling any port’s interface method (e.g. leaf1.out.put(trans)) incurs a single hop to get to the implementation (e.g. leaf2’s put task), no matter how far up and down the hierarchy the implementation resides."}
{"type": "text", "page_from": 259, "page_to": 259, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=259", "section_title": "uvm_tlm_if_base #(T1,T2)", "header_path": ["14", "1"], "chapter": "14", "section": "14.1", "content": "14.1 uvm_tlm_if_base #(T1,T2)"}
{"type": "text", "page_from": 259, "page_to": 259, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=259", "section_title": "Interfaces", "content": "This class declares all of the methods of the TLM API."}
{"type": "text", "page_from": 259, "page_to": 259, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=259", "section_title": "Interfaces", "content": "Various subsets of these methods are combined to form primitive TLM interfaces, which are then paired in various ways to form more abstract “combination” TLM interfaces. Components that require a particular interface use ports to convey that requirement. Components that provide a particular interface use exports to convey its availability."}
{"type": "text", "page_from": 259, "page_to": 259, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=259", "section_title": "Interfaces", "content": "Communication between components is established by connecting ports to compatible exports, much like connecting module signal-level output ports to compatible input ports. The difference is that UVM ports and exports bind interfaces (groups of methods), not signals and wires. The methods of the interfaces so bound pass data as whole transactions (e.g. objects). The set of primitive and combination TLM interfaces afford many choices for designing components that communicate at the transaction level."}
{"type": "text", "page_from": 259, "page_to": 259, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=259", "section_title": "Interfaces", "content": "uvm_tlm_if_base #(T1,T2)"}
{"type": "text", "page_from": 259, "page_to": 259, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=259", "section_title": "Interfaces", "content": "This class declares all of the methods of the TLM API."}
{"type": "text", "page_from": 259, "page_to": 259, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=259", "section_title": "Interfaces", "content": "virtual class uvm_tlm_if_base #( type T1 $=$ int,"}
{"type": "text", "page_from": 260, "page_to": 260, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=260", "section_title": "Interfaces", "content": "Sends a user-defined transaction of type T."}
{"type": "text", "page_from": 260, "page_to": 260, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=260", "section_title": "Interfaces", "content": "Components implementing the put method will block the calling thread if it cannot immediately accept delivery of the transaction."}
{"type": "text", "page_from": 260, "page_to": 260, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=260", "section_title": "Interfaces", "content": "Provides a new transaction of type T."}
{"type": "text", "page_from": 260, "page_to": 260, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=260", "section_title": "Interfaces", "content": "The calling thread is blocked if the requested transaction cannot be provided immediately. The new transaction is returned in the provided output argument."}
{"type": "text", "page_from": 260, "page_to": 260, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=260", "section_title": "Interfaces", "content": "The implementation of get must regard the transaction as consumed. Subsequent calls to get must return a different transaction instance."}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "virtual function bit try_put( input T1 t"}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "Sends a transaction of type T, if possible."}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "If the component is ready to accept the transaction argument, then it does so and returns 1, otherwise it returns 0."}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "virtual function bit can_put()"}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "Returns 1 if the component is ready to accept the transaction; 0 otherwise."}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "virtual function bit try_get( output T2 t"}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "Provides a new transaction of type T."}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "If a transaction is immediately available, then it is written to the output argument and 1 is returned. Otherwise, the output argument is not modified and 0 is returned."}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "virtual function bit can_get()"}
{"type": "text", "page_from": 261, "page_to": 261, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=261", "section_title": "Interfaces", "content": "Returns 1 if a new transaction can be provided immediately upon request, 0 otherwise."}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "subsequent peek or get will return the same transaction. If a transaction is not available, then the argument is unmodified and 0 is returned."}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "virtual function bit can_peek()"}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "Returns 1 if a new transaction is available; 0 otherwise."}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "virtual task transport( input T1 req , output T2 rsp )"}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "Executes the given request and returns the response in the given output argument. The calling thread may block until the operation is complete."}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "NON-bLOcKING t RANsPORt"}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "virtual function bit nb_transport( input T1 req, output T2 rsp"}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "Executes the given request and returns the response in the given output argument. Completion of this operation must occur without blocking."}
{"type": "text", "page_from": 262, "page_to": 262, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=262", "section_title": "Interfaces", "content": "If for any reason the operation could not be executed immediately, then a 0 must be returned; otherwise 1."}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "TLM Export Classes", "header_path": ["14", "2"], "chapter": "14", "section": "14.2", "content": "14.2 TLM Export Classes"}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "The following classes define the TLM export classes."}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "The following classes define the TLM export classes."}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "uvm_\\*_export The unidirectional uvm_\\*_export is a port that forwards or #(T) promotes an interface implementation from a child component to its parent. uvm_\\*_export The bidirectional uvm_\\*_export is a port that forwards or #(REQ,RSP) promotes an interface implementation from a child component to its parent."}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "The unidirectional uvm_\\*_export is a port that forwards or promotes an interface implementation from a child component to its parent. An export can be connected to any compatible child export or imp port. It must ultimately be connected to at least one implementation of its associated interface."}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "The interface type represented by the asterisk is any of the following"}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "The type of transaction to be communicated by the export"}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "Exports are connected to interface implementations directly via uvm_\\*_imp #(T,IMP) ports or indirectly via other uvm_\\*_export #(T) exports."}
{"type": "text", "page_from": 263, "page_to": 263, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=263", "section_title": "Exports", "content": "The unidirectional uvm_\\*_export is a port that forwards or promotes an interface implementation from a child component to its parent."}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "The name and parent are the standard uvm_component constructor arguments. The min_size and max_size specify the minimum and maximum number of interfaces that must have been supplied to this port by the end of elaboration."}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "uvm_\\*_export #(REQ,RSP)"}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "The bidirectional uvm_\\*_export is a port that forwards or promotes an interface implementation from a child component to its parent. An export can be connected to any compatible child export or imp port. It must ultimately be connected to at least one implementation of its associated interface."}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "The interface type represented by the asterisk is any of the following"}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "REQ The type of request transaction to be communicated by the export RSP The type of response transaction to be communicated by the export"}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "Exports are connected to interface implementations directly via uvm_\\*_imp #(REQ, RSP, IMP, REQ_IMP, RSP_IMP) ports or indirectly via other uvm_\\*_export #(REQ,RSP) exports."}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "uvm_\\*_export #(REQ,RSP)"}
{"type": "text", "page_from": 264, "page_to": 264, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=264", "section_title": "Exports", "content": "The bidirectional uvm_\\*_export is a port that forwards or promotes an interface"}
{"type": "text", "page_from": 265, "page_to": 265, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=265", "section_title": "Exports", "content": "implementation from a child component to its parent."}
{"type": "text", "page_from": 265, "page_to": 265, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=265", "section_title": "Exports", "content": "The name and parent are the standard uvm_component constructor arguments."}
{"type": "text", "page_from": 265, "page_to": 265, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=265", "section_title": "Exports", "content": "The name and parent are the standard uvm_component constructor arguments. The min_size and max_size specify the minimum and maximum number of interfaces that must have been supplied to this port by the end of elaboration."}
{"type": "text", "page_from": 265, "page_to": 265, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=265", "section_title": "Exports", "content": "function new (string name, uvm_component parent, int min_size=1, int max_size=1)"}
{"type": "text", "page_from": 266, "page_to": 266, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=266", "section_title": "TLM Port Classes", "header_path": ["14", "3"], "chapter": "14", "section": "14.3", "content": "14.3 TLM Port Classes"}
{"type": "text", "page_from": 266, "page_to": 266, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=266", "section_title": "Ports", "content": "The following classes define the TLM port classes."}
{"type": "text", "page_from": 266, "page_to": 266, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=266", "section_title": "Ports", "content": "These unidirectional ports are instantiated by components that require, or use, the associated interface to convey transactions. A port can be connected to any compatible port, export, or imp port. Unless its min_size is 0, a port must be connected to at least one implementation of its associated interface."}
{"type": "text", "page_from": 266, "page_to": 266, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=266", "section_title": "Ports", "content": "The asterisk in uvm_\\*_port is any of the following"}
{"type": "text", "page_from": 266, "page_to": 266, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=266", "section_title": "Ports", "content": "T The type of transaction to be communicated by the export. The type T is not restricted to class handles and may be a value type such as int,enum,struct or similar."}
{"type": "text", "page_from": 266, "page_to": 266, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=266", "section_title": "Ports", "content": "Ports are connected to interface implementations directly via uvm_\\*_imp #(T,IMP) ports or indirectly via hierarchical connections to uvm_\\*_port #(T) and uvm_\\*_export #(T) ports."}
{"type": "text", "page_from": 266, "page_to": 266, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=266", "section_title": "Ports", "content": "These unidirectional ports are instantiated by components that require, or use, the associated interface to convey transactions."}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "The name and parent are the standard uvm_component constructor arguments."}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "The name and parent are the standard uvm_component constructor arguments. The min_size and max_size specify the minimum and maximum number of interfaces that must have been connected to this port by the end of elaboration."}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "uvm_\\*_port #(REQ,RSP)"}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "These bidirectional ports are instantiated by components that require, or use, the associated interface to convey transactions. A port can be connected to any compatible port, export, or imp port. Unless its min_size is 0, a port must be connected to at least one implementation of its associated interface."}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "The asterisk in uvm_\\*_port is any of the following"}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "Ports are connected to interface implementations directly via uvm_\\*_imp #(REQ,RSP,IMP,REQ_IMP,RSP_IMP) ports or indirectly via hierarchical connections to uvm_\\*_port #(REQ,RSP) and uvm_\\*_export #(REQ,RSP) ports."}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "REQ The type of request transaction to be communicated by the export RSP The type of response transaction to be communicated by the export"}
{"type": "text", "page_from": 267, "page_to": 267, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=267", "section_title": "Ports", "content": "uvm_\\*_port #(REQ,RSP)"}
{"type": "text", "page_from": 268, "page_to": 268, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=268", "section_title": "Ports", "content": "These bidirectional ports are instantiated by components that require, or use, the associated interface to convey transactions."}
{"type": "text", "page_from": 268, "page_to": 268, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=268", "section_title": "Ports", "content": "The name and parent are the standard uvm_component constructor arguments."}
{"type": "text", "page_from": 268, "page_to": 268, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=268", "section_title": "Ports", "content": "The name and parent are the standard uvm_component constructor arguments. The min_size and max_size specify the minimum and maximum number of interfaces that must have been supplied to this port by the end of elaboration."}
{"type": "text", "page_from": 268, "page_to": 268, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=268", "section_title": "Ports", "content": "function new (string name, uvm_component parent, int min_size $= 1$ , int max_size $= 1$ )"}
{"type": "text", "page_from": 269, "page_to": 269, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=269", "section_title": "Implementation Classes", "content": "The following defines the TLM implementation (imp) classes."}
{"type": "text", "page_from": 269, "page_to": 269, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=269", "section_title": "Implementation Classes", "content": "Unidirectional implementation (imp) port classes--An imp port provides access to an implementation of the associated interface to all connected ports and exports. Each imp port instance must be connected to the component instance that implements the associated interface, typically the imp port’s parent. All other connections-- e.g. to other ports and exports-- are prohibited."}
{"type": "text", "page_from": 269, "page_to": 269, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=269", "section_title": "Implementation Classes", "content": "The asterisk in uvm_\\*_imp may be any of the following"}
{"type": "text", "page_from": 269, "page_to": 269, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=269", "section_title": "Implementation Classes", "content": "T The type of transaction to be communicated by the imp IMP The type of the component implementing the interface. That is, the class to which this imp will delegate."}
{"type": "text", "page_from": 269, "page_to": 269, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=269", "section_title": "Implementation Classes", "content": "The interface methods are implemented in a component of type IMP, a handle to which is passed in a constructor argument. The imp port delegates all interface calls to this component."}
{"type": "text", "page_from": 270, "page_to": 270, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=270", "section_title": "Implementation Classes", "content": "Unidirectional implementation (imp) port classes--An imp port provides access to an implementation of the associated interface to all connected ports and exports."}
{"type": "text", "page_from": 270, "page_to": 270, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=270", "section_title": "Implementation Classes", "content": "Creates a new unidirectional imp port with the given name and parent."}
{"type": "text", "page_from": 270, "page_to": 270, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=270", "section_title": "Implementation Classes", "content": "Creates a new unidirectional imp port with the given name and parent. The parent must implement the interface associated with this port. Its type must be the type specified in the imp’s type-parameter, IMP."}
{"type": "text", "page_from": 270, "page_to": 270, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=270", "section_title": "Implementation Classes", "content": "uvm \\* imp #(REQ, RSP, IMP, REQ_IMP,RSP _IMP)"}
{"type": "text", "page_from": 270, "page_to": 270, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=270", "section_title": "Implementation Classes", "content": "Bidirectional implementation (imp) port classes--An imp port provides access to an implementation of the associated interface to all connected ports and exports. Each imp port instance must be connected to the component instance that implements the associated interface, typically the imp port’s parent. All other connections-- e.g. to other ports and exports-- are prohibited."}
{"type": "text", "page_from": 270, "page_to": 270, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=270", "section_title": "Implementation Classes", "content": "The interface represented by the asterisk is any of the following"}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "Component type that implements the response side of the interface. Defaults to IMP. For master and slave imps only."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "The interface methods are implemented in a component of type IMP, a handle to which is passed in a constructor argument. The imp port delegates all interface calls to this component."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "The master and slave imps have two modes of operation."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "A single component of type IMP implements the entire interface for both requests and responses. Two sibling components of type REQ_IMP and RSP_IMP implement the request and response interfaces, respectively. In this case, the IMP parent instantiates this imp port and the REQ_IMP and RSP_IMP components."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "The second mode is needed when a component instantiates more than one imp port, as in the uvm_tlm_req_rsp_channel #(REQ,RSP) channel."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "uvm_\\*_imp #(REQ, RSP, IMP, REQ_IMP, RSP_IMP)"}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "Bidirectional implementation (imp) port classes--An imp port provides access to an implementation of the associated interface to all connected ports and exports."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "Creates a new bidirectional imp port with the given name and parent."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "Creates a new bidirectional imp port with the given name and parent. The parent, whose type is specified by IMP type parameter, must implement the interface associated with this port."}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "Transport imp constructor"}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "Master and slave imp constructor"}
{"type": "text", "page_from": 271, "page_to": 271, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=271", "section_title": "Implementation Classes", "content": "The optional req_imp and rsp_imp arguments, available to master and slave imp ports, allow the requests and responses to be handled by different subcomponents. If they are specified, they must point to the underlying component that implements the request and response methods, respectively."}
{"type": "text", "page_from": 272, "page_to": 272, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=272", "section_title": "FIFOs", "content": "This section defines TLM-based FIFO classes."}
{"type": "text", "page_from": 272, "page_to": 272, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=272", "section_title": "FIFOs", "content": "This class provides storage of transactions between two independently running processes. Transactions are put into the FIFO via the put_export. transactions are fetched from the FIFO in the order they arrived via the get_peek_export. The put_export and get_peek_export are inherited from the uvm_tlm_fifo_base #(T) super class, and the interface methods provided by these exports are defined by the uvm_tlm_if_base #(T1,T2) class."}
{"type": "text", "page_from": 272, "page_to": 272, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=272", "section_title": "FIFOs", "content": "This class provides storage of transactions between two independently running processes."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "The name and parent are the normal uvm_component constructor arguments. The parent should be null if the uvm_tlm_fifo#(T) is going to be used in a statically elaborated construct (e.g., a module). The size indicates the maximum size of the FIFO; a value of zero indicates no upper bound."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "virtual function int size()"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "Returns the capacity of the FIFO-- that is, the number of entries the FIFO is capable of holding. A return value of 0 indicates the FIFO capacity has no limit."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "virtual function int used()"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "Returns the number of entries put into the FIFO."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "virtual function bit is_empty()"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "Returns 1 when there are no entries in the FIFO, 0 otherwise."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "virtual function bit is_full()"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "Returns 1 when the number of entries in the FIFO is equal to its size, 0 otherwise."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "virtual function void flush()"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "Removes all entries from the FIFO, after which used returns 0 and is_empty returns 1."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "uvm_tlm_analysis_fifo#(T)"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "An analysis_fifo is a uvm_tlm_fifo#(T) with an unbounded size and a write interface. It can be used any place a uvm_analysis_imp is used. Typical usage is as a buffer between a uvm_analysis_port in an initiator component and TLM1 target component."}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "uvm_tlm_analysis_fifo#(T)"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "An analysis_fifo is a uvm_tlm_fifo#(T) with an unbounded size and a write"}
{"type": "text", "page_from": 273, "page_to": 273, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=273", "section_title": "FIFOs", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "analysis_export #(T)"}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "The analysis_export provides the write method to all connected analysis ports and parent exports:"}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "This is the standard uvm_component constructor."}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "analysis_export #(T)"}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "The analysis_export provides the write method to all connected analysis ports and parent exports:"}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "Access via ports bound to this export is the normal mechanism for writing to an analysis FIFO. See write method of uvm_tlm_if_base #(T1,T2) for more information."}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "function new( string name ,uvm_component parent $=$ null )"}
{"type": "text", "page_from": 274, "page_to": 274, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=274", "section_title": "FIFOs", "content": "This is the standard uvm_component constructor. name is the local name of this component. The parent should be left unspecified when this component is instantiated in statically elaborated constructs and must be specified when this component is a child of another UVM component."}
{"type": "text", "page_from": 275, "page_to": 275, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=275", "section_title": "uvm_tlm_fifo_base #(T)", "header_path": ["14", "6"], "chapter": "14", "section": "14.6", "content": "14.6 uvm_tlm_fifo_base #(T)"}
{"type": "text", "page_from": 275, "page_to": 275, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=275", "section_title": "FIFO Base", "content": "This class is the base for uvm_tlm_fifo#(T). It defines the TLM exports through which all transaction-based FIFO operations occur. It also defines default implementations for each interface method provided by these exports."}
{"type": "text", "page_from": 275, "page_to": 275, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=275", "section_title": "FIFO Base", "content": "The interface methods provided by the put_export and the get_peek_export are defined and described by uvm_tlm_if_base #(T1,T2). See the TLM Overview section for a general discussion of TLM interface definition and usage."}
{"type": "text", "page_from": 275, "page_to": 275, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=275", "section_title": "FIFO Base", "content": "T The type of transactions to be stored by this FIFO."}
{"type": "text", "page_from": 275, "page_to": 275, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=275", "section_title": "FIFO Base", "content": "uvm_tlm_fifo_base #(T)"}
{"type": "text", "page_from": 275, "page_to": 275, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=275", "section_title": "FIFO Base", "content": "This class is the base for uvm_tlm_fifo#(T)."}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "The put_export provides both the blocking and non-blocking put interface methods to any attached port:"}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "Any put port variant can connect and send transactions to the FIFO via this export, provided the transaction types match. See uvm_tlm_if_base #(T1,T2) for more information on each of the above interface methods."}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "The get_peek_export provides all the blocking and non-blocking get and peek interface methods:"}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "Any get or peek port variant can connect to and retrieve transactions from the FIFO via this export, provided the transaction types match. See uvm_tlm_if_base #(T1,T2) for more information on each of the above interface methods."}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "Transactions passed via put or try_put (via any port connected to the put_export) are sent out this port via its write method."}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "All connected analysis exports and imps will receive put transactions. See uvm_tlm_if_base #(T1,T2) for more information on the write interface method."}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "Transactions passed via get, try_get, peek, or try_peek (via any port connected to the get_peek_export) are sent out this port via its write method."}
{"type": "text", "page_from": 276, "page_to": 276, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=276", "section_title": "FIFO Base", "content": "All connected analysis exports and imps will receive get transactions. See uvm_tlm_if_base #(T1,T2) for more information on the write method."}
{"type": "text", "page_from": 277, "page_to": 277, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=277", "section_title": "FIFO Base", "content": "The name and parent are the normal uvm_component constructor arguments. The parent should be null if the uvm_tlm_fifo is going to be used in a statically elaborated construct (e.g., a module). The size indicates the maximum size of the FIFO. A value of zero indicates no upper bound."}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "TLM Channel Classes", "header_path": ["14", "7"], "chapter": "14", "section": "14.7", "content": "14.7 TLM Channel Classes"}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "This section defines built-in TLM channel classes."}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "This section defines built-in TLM channel classes."}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "uvm_tlm_req_rsp_channel #(REQ,RSP) uvm_tlm_transport_channel #(REQ,RSP)"}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "The uvm_tlm_req_rsp_channel contains a request FIFO of type REQ and a response FIFO of type RSP. A uvm_tlm_transport_channel is a uvm_tlm_req_rsp_channel #(REQ,RSP) that implements the transport interface."}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "uvm_tlm_req_rsp_channel #(REQ,RSP)"}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "The uvm_tlm_req_rsp_channel contains a request FIFO of type REQ and a response FIFO of type RSP. These FIFOs can be of any size. This channel is particularly useful for dealing with pipelined protocols where the request and response are not tightly coupled."}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "REQ Type of the request transactions conveyed by this channel. RSP Type of the response transactions conveyed by this channel."}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "uvm_tlm_req_rsp_channel #(REQ,RSP)"}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "The uvm_tlm_req_rsp_channel contains a request FIFO of type REQ and a response FIFO of type RSP."}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "Cl Ass Decl Ar At ION"}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "The put_export provides both the blocking and non-blocking put interface methods to the request FIFO: The get_peek_response_export provides all the blocking and non-blocking get and peek"}
{"type": "text", "page_from": 278, "page_to": 278, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=278", "section_title": "Channel Classes", "content": "get_peek_response_export"}
{"type": "text", "page_from": 279, "page_to": 279, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=279", "section_title": "Channel Classes", "content": "The put_export provides both the blocking and non-blocking put interface methods to the request FIFO:"}
{"type": "text", "page_from": 279, "page_to": 279, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=279", "section_title": "Channel Classes", "content": "Any put port variant can connect and send transactions to the request FIFO via this export, provided the transaction types match."}
{"type": "text", "page_from": 279, "page_to": 279, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=279", "section_title": "Channel Classes", "content": "get_peek_response_export"}
{"type": "text", "page_from": 279, "page_to": 279, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=279", "section_title": "Channel Classes", "content": "The get_peek_response_export provides all the blocking and non-blocking get and peek interface methods to the response FIFO:"}
{"type": "text", "page_from": 279, "page_to": 279, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=279", "section_title": "Channel Classes", "content": "Any get or peek port variant can connect to and retrieve transactions from the response FIFO via this export, provided the transaction types match."}
{"type": "text", "page_from": 280, "page_to": 280, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=280", "section_title": "Channel Classes", "content": "The get_peek_export provides all the blocking and non-blocking get and peek interface methods to the response FIFO:"}
{"type": "text", "page_from": 280, "page_to": 280, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=280", "section_title": "Channel Classes", "content": "Any get or peek port variant can connect to and retrieve transactions from the response FIFO via this export, provided the transaction types match."}
{"type": "text", "page_from": 280, "page_to": 280, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=280", "section_title": "Channel Classes", "content": "The put_export provides both the blocking and non-blocking put interface methods to the response FIFO:"}
{"type": "text", "page_from": 280, "page_to": 280, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=280", "section_title": "Channel Classes", "content": "Any put port variant can connect and send transactions to the response FIFO via this export, provided the transaction types match."}
{"type": "text", "page_from": 280, "page_to": 280, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=280", "section_title": "Channel Classes", "content": "Transactions passed via put or try_put (via any port connected to the put_request_export) are sent out this port via its write method."}
{"type": "text", "page_from": 280, "page_to": 280, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=280", "section_title": "Channel Classes", "content": "All connected analysis exports and imps will receive these transactions."}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "responses. It is a combination of the put_request_export and get_peek_response_export."}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "Exports a single interface that allows a slave to get or peek requests and to put responses. It is a combination of the get_peek_request_export and put_response_export."}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "The name and parent are the standard uvm_component constructor arguments. The parent must be null if this component is defined within a static component such as a module, program block, or interface. The last two arguments specify the request and response FIFO sizes, which have default values of 1."}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "uvm_tlm_transport_channel #(REQ,RSP)"}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "A uvm_tlm_transport_channel is a uvm_tlm_req_rsp_channel #(REQ,RSP) that implements the transport interface. It is useful when modeling a non-pipelined bus at the transaction level. Because the requests and responses have a tightly coupled oneto-one relationship, the request and response FIFO sizes are both set to one."}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "uvm_tlm_transport_channel #(REQ,RSP)"}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "A uvm_tlm_transport_channel is a uvm_tlm_req_rsp_channel #(REQ,RSP) that implements the transport interface."}
{"type": "text", "page_from": 281, "page_to": 281, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=281", "section_title": "Channel Classes", "content": "Cl Ass Decl Ar At ION"}
{"type": "text", "page_from": 282, "page_to": 282, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=282", "section_title": "Channel Classes", "content": "class uvm_tlm_transport_channel #( type REQ = int, type RSP = REQ ) extends uvm_tlm_req_rsp_channel #(REQ, RSP)"}
{"type": "text", "page_from": 282, "page_to": 282, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=282", "section_title": "Channel Classes", "content": "The put_export provides both the blocking and nonblocking transport interface methods to the response FIFO:"}
{"type": "text", "page_from": 282, "page_to": 282, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=282", "section_title": "Channel Classes", "content": "The name and parent are the standard uvm_component constructor arguments."}
{"type": "text", "page_from": 282, "page_to": 282, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=282", "section_title": "Channel Classes", "content": "The put_export provides both the blocking and non-blocking transport interface methods to the response FIFO:"}
{"type": "text", "page_from": 282, "page_to": 282, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=282", "section_title": "Channel Classes", "content": "Any transport port variant can connect to and send requests and retrieve responses via this export, provided the transaction types match. Upon return, the response argument carries the response to the request."}
{"type": "text", "page_from": 282, "page_to": 282, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=282", "section_title": "Channel Classes", "content": "function new ( string name, uvm_component parent $=$ null )"}
{"type": "text", "page_from": 282, "page_to": 282, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=282", "section_title": "Channel Classes", "content": "The name and parent are the standard uvm_component constructor arguments. The parent must be null if this component is defined within a statically elaborated construct such as a module, program block, or interface."}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "header_path": ["14", "8"], "chapter": "14", "section": "14.8", "content": "14.8 Sequence Item Pull Ports"}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "This section defines the port, export, and imp port classes for communicating sequence items between uvm_sequencer #(REQ,RSP) and uvm_driver #(REQ,RSP)."}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "uvm_seq_item_pull_port #(REQ,RSP)"}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "UVM provides a port, export, and imp connector for use in sequencer-driver communication. All have standard port connector constructors, except that uvm_seq_item_pull_port’s default min_size argument is 0; it can be left unconnected."}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "uvm_seq_item_pull_port #(REQ,RSP)"}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "UVM provides a port, export, and imp connector for use in sequencer-driver communication."}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "CLAss Dec LAr ATi ON"}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "uvm_seq_item_pull_export #(REQ,RSP)"}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "This export type is used in sequencer-driver communication. It has the standard constructor for exports."}
{"type": "text", "page_from": 283, "page_to": 283, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=283", "section_title": "Sequence Item Pull Ports", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "uvm_seq_item_pull_export #(REQ,RSP)"}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "This export type is used in sequencer-driver communication."}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "CLAss Dec LAr ATi ON"}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "This imp type is used in sequencer-driver communication. It has the standard constructor for imp-type ports."}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "uvm_seq_item_pull_imp #(REQ,RSP,IMP)"}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "This imp type is used in sequencer-driver communication."}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "CLAss Dec LAr ATi ON"}
{"type": "text", "page_from": 284, "page_to": 284, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=284", "section_title": "Sequence Item Pull Ports", "content": "class uvm_seq_item_pull_imp #( type REQ = int, type RSP $=$ REQ, type IMP $=$ int ) extends uvm_port_base #(uvm_sqr_if_base #(REQ, RSP))"}
{"type": "text", "page_from": 285, "page_to": 285, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=285", "section_title": "uvm_sqr_if_base #(REQ,RSP)", "header_path": ["14", "9"], "chapter": "14", "section": "14.9", "content": "14.9 uvm_sqr_if_base #(REQ,RSP)"}
{"type": "text", "page_from": 285, "page_to": 285, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=285", "section_title": "Sequencer Base", "content": "This class defines an interface for sequence drivers to communicate with sequencers. The driver requires the interface via a port, and the sequencer implements it and provides it via an export."}
{"type": "text", "page_from": 285, "page_to": 285, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=285", "section_title": "Sequencer Base", "content": "uvm_sqr_if_base #(REQ,RSP)"}
{"type": "text", "page_from": 285, "page_to": 285, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=285", "section_title": "Sequencer Base", "content": "This class defines an interface for sequence drivers to communicate with sequencers."}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "mode. If no sequence is available, wait for a requesting unlocked relevant sequence, then re-arbitrate."}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "The chosen sequence will return from wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called 6 Return with a reference to the item", "header_path": ["2"], "chapter": "2", "content": "2 The chosen sequence will return from wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called 6 Return with a reference to the item"}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "Once get_next_item is called, item_done must be called to indicate the completion of the request to the sequencer. This will remove the request item from the sequencer FIFO."}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "virtual task try_next_item(output T1 t ）"}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "Retrieves the next available item from a sequence if one is available. Otherwise, the function returns immediately with request set to null. The following steps occur on this call:"}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Arbitrate among requesting, unlocked, relevant sequences - choose the highest priority sequence based on the current sequencer arbitration mode. If no sequence is available, return null. 2 The chosen sequence will return from wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called 6 Return with a reference to the item", "header_path": ["1"], "chapter": "1", "content": "1 Arbitrate among requesting, unlocked, relevant sequences - choose the highest priority sequence based on the current sequencer arbitration mode. If no sequence is available, return null. 2 The chosen sequence will return from wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called 6 Return with a reference to the item"}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "Once try_next_item is called, item_done must be called to indicate the completion of the request to the sequencer. This will remove the request item from the sequencer FIFO."}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "virtual function void item_done( input T2 t $=$ null )"}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "Indicates that the request is completed to the sequencer. Any uvm_sequence_base::wait_for_item_done calls made by a sequence for this item will return."}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "The current item is removed from the sequencer FIFO."}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "If a response item is provided, then it will be sent back to the requesting sequence. The response item must have its sequence ID and transaction ID set correctly, using the uvm_sequence_item::set_id_info method:"}
{"type": "text", "page_from": 286, "page_to": 286, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=286", "section_title": "Sequencer Base", "content": "Before item_done is called, any calls to peek will retrieve the current item that was"}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "obtained by get_next_item. After item_done is called, peek will cause the sequencer to arbitrate for a new item."}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "virtual task wait_for_sequences()"}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "Waits for a sequence to have a new item available. The default implementation in the sequencer calls uvm_wait_for_nba_region. User-derived sequencers may override its wait_for_sequences implementation to perform some other application-specific implementation."}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "virtual function bit has_do_available()"}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "Indicates whether a sequence item is available for immediate processing. Implementations should return 1 if an item is available, 0 otherwise."}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "Retrieves the next available item from a sequence. The call blocks until an item is available. The following steps occur on this call:"}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Arbitrate among requesting, unlocked, relevant sequences - choose the highest priority sequence based on the current sequencer arbitration mode. If no sequence is available, wait for a requesting unlocked relevant sequence, then re-arbitrate. 2 The chosen sequence will return from uvm_sequence_base::wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called 6 Indicate item_done to the sequencer 7 Return with a reference to the item", "header_path": ["1"], "chapter": "1", "content": "1 Arbitrate among requesting, unlocked, relevant sequences - choose the highest priority sequence based on the current sequencer arbitration mode. If no sequence is available, wait for a requesting unlocked relevant sequence, then re-arbitrate. 2 The chosen sequence will return from uvm_sequence_base::wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called 6 Indicate item_done to the sequencer 7 Return with a reference to the item"}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "When get is called, item_done may not be called. A new item can be obtained by calling get again, or a response may be sent using either put, or uvm_driver::rsp_port.write()."}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Sequencer Base", "content": "Returns the current request item if one is in the sequencer FIFO. If no item is in the FIFO, then the call will block until the sequencer has a new request. The following steps will occur if the sequencer FIFO is empty:"}
{"type": "text", "page_from": 287, "page_to": 287, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=287", "section_title": "Arbitrate among requesting, unlocked, relevant sequences - choose the highest priority sequence based on the current sequencer arbitration mode. If no sequence is available, wait for a requesting unlocked relevant sequence, then re-arbitrate.", "header_path": ["1"], "chapter": "1", "content": "1 Arbitrate among requesting, unlocked, relevant sequences - choose the highest priority sequence based on the current sequencer arbitration mode. If no sequence is available, wait for a requesting unlocked relevant sequence, then re-arbitrate."}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "The chosen sequence will return from uvm_sequence_base::wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called", "header_path": ["2"], "chapter": "2", "content": "2 The chosen sequence will return from uvm_sequence_base::wait_for_grant 3 The chosen sequence uvm_sequence_base::pre_do is called 4 The chosen sequence item is randomized 5 The chosen sequence uvm_sequence_base::post_do is called"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "Once a request item has been retrieved and is in the sequencer FIFO, subsequent calls to peek will return the same item. The item will stay in the FIFO until either get or item_done is called."}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "Sends a response back to the sequence that issued the request. Before the response is put, it must have its sequence ID and transaction ID set to match the request. This can be done using the uvm_sequence_item::set_id_info call:"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "rsp.set_id_info(req);"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "While this is a task, it will not consume time (including delta cycles). The response will be put into the sequence response queue or it will be sent to the sequence response handler."}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "virtual function void put_response( input T2 t"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "Sends a response back to the sequence that issued the request. Before the response is put, it must have its sequence ID and transaction ID set to match the request. This can be done using the uvm_sequence_item::set_id_info call:"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "rsp.set_id_info(req);"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "disable_auto_item_recording"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "virtual function void disable_auto_item_recording()"}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "By default, item recording is performed automatically when get_next_item() and item_done() are called. However, this works only for simple, in-order, blocking transaction execution. For pipelined and out-of-order transaction execution, the driver must turn off this automatic recording and call uvm_transaction::accept_tr, uvm_transaction::begin_tr and uvm_transaction::end_tr explicitly at appropriate points in time."}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "This methods be called at the beginning of the driver’s run_phase() method. Once disabled, automatic recording cannot be re-enabled."}
{"type": "text", "page_from": 288, "page_to": 288, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=288", "section_title": "Sequencer Base", "content": "For backward-compatibility, automatic item recording can be globally turned off at"}
{"type": "text", "page_from": 289, "page_to": 289, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=289", "section_title": "Sequencer Base", "content": "is_auto_item_recording_enabled"}
{"type": "text", "page_from": 289, "page_to": 289, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=289", "section_title": "Sequencer Base", "content": "virtual function bit is_auto_item_recording_enabled()"}
{"type": "text", "page_from": 289, "page_to": 289, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=289", "section_title": "Sequencer Base", "content": "Return TRUE if automatic item recording is enabled for this port instance."}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "15. TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset"}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "Sockets group together all the necessary core interfaces for transportation and binding, allowing more generic usage models than just TLM core interfaces."}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "A socket is like a port or export; in fact it is derived from the same base class as ports and export, namely uvm_port_base #(IF). However, unlike a port or export a socket provides both a forward and backward path. Thus you can enable asynchronous (pipelined) bi-directional communication by connecting sockets together. To enable this, a socket contains both a port and an export. Components that initiate transactions are called initiators, and components that receive transactions sent by an initiator are called targets. Initiators have initiator sockets and targets have target sockets. Initiator sockets can connect to target sockets. You cannot connect initiator sockets to other initiator sockets and you cannot connect target sockets to target sockets."}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "The UVM TLM2 subset provides the following two transport interfaces"}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "Blocking (b_transport)"}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "completes the entire transaction within a single method call"}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "Non-blocking (nb_transport)"}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "describes the progress of a transaction using multiple nb_transport() method calls going backand-forth between initiator and target"}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "In general, any component might modify a transaction object during its lifetime (subject to the rules of the protocol). Significant timing points during the lifetime of a transaction (for example: start of response- phase) are indicated by calling nb_transport() in either forward or backward direction, the specific timing point being given by the phase argument. Protocol-specific rules for reading or writing the attributes of a transaction can be expressed relative to the phase. The phase can be used for flow control, and for that reason might have a different value at each hop taken by a transaction; the phase is not an attribute of the transaction object."}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "A call to nb_transport() always represents a phase transition. However, the return from nb_transport() might or might not do so, the choice being indicated by the value returned from the function (UVM_TLM_ACCEPTED versus UVM_TLM_UPDATED)."}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "Generally, you indicate the completion of a transaction over a particular hop using the value of the phase argument. As a shortcut, a target might indicate the completion of the transaction by returning a special value of UVM_TLM_COMPLETED. However, this is an option, not a necessity."}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "The transaction object itself does not contain any timing information by design. Or even events and status information concerning the API. You can pass the delays as arguments to b_transport()/ nb_transport() and push the actual realization of any delay in the simulator kernel downstream and defer (for simulation speed)."}
{"type": "text", "page_from": 290, "page_to": 290, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=290", "section_title": "TLM2", "content": "Since sockets are derived from uvm_port_base #(IF) they are created and connected in the same way as port, and exports. Create them in the build phase and connect them in the connect phase by calling connect(). Initiator and target termination sockets are on the ends of any connection. There can be an arbitrary number of pass-through sockets in the path between initiator and target. Some socket types must be bound to imps implementations of the transport tasks and functions. Blocking terminator sockets must be bound to an implementation of b_transport(), for example. Nonblocking initiator sockets must be bound to an implementation of nb_transport_bw() and nonblocking target sockets must be bound to an implementation of nb_transport_fw(). Typically, the task or function is implemented in the component in which the socket is instantiated and the component type and instance are provided to complete the binding."}
{"type": "text", "page_from": 291, "page_to": 291, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=291", "section_title": "TLM2", "content": "Consider for example a consumer component with a blocking target socket."}
{"type": "text", "page_from": 291, "page_to": 291, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=291", "section_title": "TLM2", "content": "class consumer extends uvm_component; tlm2_b_target_socket #(consumer, trans) target_socket; function new(string name, uvm_component parent); super.new(name, parent); endfunction function void build(); target_socket $=$ new(\"target_socket\", this, this); endfunction task b_transport(trans t, uvm_tlm_time delay); #5; uvm_report_info(\"consumer\", t.convert2string()); endtask endclass"}
{"type": "text", "page_from": 291, "page_to": 291, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=291", "section_title": "TLM2", "content": "The interface task b_transport() is implemented in the consumer component. The consumer component type is used in the declaration of the target socket. This informs the socket object the type of the object that contains the interface task, in this case b_transport(). When the socket is instantiated “this” is passed in twice, once as the parent just like any other component instantiation and again to identify the object that holds the implementation of b_transport(). Finally, in order to complete the binding, an implementation of b_transport() must be present in the consumer component. Any component that has either a blocking termination socket, a nonblocking initiator socket, or a nonblocking termination socket must provide implementations of the relevant components. This includes initiator and target components as well as interconnect components that have these kinds of sockets. Components with pass-through sockets do not need to provide implementations of any sort. Of course, they must ultimately be connected to sockets that do that the necessary implementations."}
{"type": "text", "page_from": 291, "page_to": 291, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=291", "section_title": "TLM2", "content": "Call to b_transport() start-of-life of transaction Return from b_transport() end-of-life of transaction Phase argument to nb_transport() timing point within lifetime of transaction Return value of nb_transport() whether return path is being used (also shortcut to final phase) Response status within transaction object protocol-specific status, success/failure of transaction"}
{"type": "text", "page_from": 291, "page_to": 291, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=291", "section_title": "TLM2", "content": "On top of this, TLM-2.0 defines a generic payload and base protocol to enhance interoperability for models with a memory-mapped bus interface."}
{"type": "text", "page_from": 291, "page_to": 291, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=291", "section_title": "TLM2", "content": "It is possible to use the interfaces described above with user-defined transaction types and protocols for the sake of interoperability. However, TLM-2.0 strongly recommends either using the base protocol off-the-shelf or creating models of specific protocols on top of the base protocol."}
{"type": "text", "page_from": 291, "page_to": 291, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=291", "section_title": "TLM2", "content": "The UVM 1.2 standard only defines and supports this TLM2 style interface for SystemVerilog to SystemVerilog communication. Mixed language TLM communication is saved for future extension."}
{"type": "text", "page_from": 292, "page_to": 292, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=292", "section_title": "TLM2", "content": "TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset"}
{"type": "text", "page_from": 292, "page_to": 292, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=292", "section_title": "TLM2", "content": "Sockets group together all the necessary core interfaces for transportation and binding, allowing more generic usage models than just TLM core interfaces."}
{"type": "text", "page_from": 293, "page_to": 293, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=293", "section_title": "Interface Masks", "header_path": ["15", "1"], "chapter": "15", "section": "15.1", "content": "15.1 Interface Masks"}
{"type": "text", "page_from": 293, "page_to": 293, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=293", "section_title": "Interface Masks", "content": "Each of the following macros is a mask that identifies which interfaces a particular port requires or export provides. The interfaces are identified by bit position and can be OR’ed together for combination ports/exports. The mask is used to do run-time interface type checking of port/export connections."}
{"type": "text", "page_from": 293, "page_to": 293, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=293", "section_title": "Interface Masks", "content": "Each of the following macros is a mask that identifies which interfaces a particular port requires or export provides."}
{"type": "text", "page_from": 293, "page_to": 293, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=293", "section_title": "Interface Masks", "content": "\\`UVM_TLM_NB_FW_MASK"}
{"type": "text", "page_from": 293, "page_to": 293, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=293", "section_title": "Interface Masks", "content": "Define Non blocking Forward mask onehot assignment $= { \\cdot } { \\mathsf { b } } 0 0 1$"}
{"type": "text", "page_from": 293, "page_to": 293, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=293", "section_title": "Interface Masks", "content": "Define Non blocking backward mask onehot assignment $= { \\dot { \\mathsf { b } } } 0 1 0$"}
{"type": "text", "page_from": 293, "page_to": 293, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=293", "section_title": "Interface Masks", "content": "Define blocking mask onehot assignment $= { \\cdot } { \\mathsf { b } } 1 0 0$"}
{"type": "text", "page_from": 294, "page_to": 294, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=294", "section_title": "Types", "content": "\\`UVM_TLM_TASK_ERROR\\`UVM_TLM_FUNCTION_ERROR"}
{"type": "text", "page_from": 294, "page_to": 294, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=294", "section_title": "Types", "content": "Nonblocking transport synchronization state values between an initiator and a target."}
{"type": "text", "page_from": 294, "page_to": 294, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=294", "section_title": "Types", "content": "UNINITIALIZED_PHASE Defaults for constructor BEGIN_REQ Beginning of request phase END_REQ End of request phase BEGIN_RESP Beginning of response phase END_RESP End of response phase"}
{"type": "text", "page_from": 294, "page_to": 294, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=294", "section_title": "Types", "content": "Pre-defined phase state values for the nonblocking transport Base Protocol between an initiator and a target."}
{"type": "text", "page_from": 294, "page_to": 294, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=294", "section_title": "Types", "content": "UVM_TLM_ACCEPTED Transaction has been accepted UVM_TLM_UPDATED Transaction has been modified UVM_TLM_COMPLETED Execution of transaction is complete"}
{"type": "text", "page_from": 294, "page_to": 294, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=294", "section_title": "Types", "content": "Defines Not-Yet-Implemented TLM tasks"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Defines Not-Yet-Implemented TLM functions"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Base class type to define the transport functions."}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "nb_transport_fw nb_transport_bw b_transport"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Base class type to define the transport functions."}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Cl Ass DeCl ARAt ION"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "class uvm_tlm_if #( type T $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e )"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "tlm t RANsPORtmet HOds"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Each of the interface methods take a handle to the transaction to be transported and a reference argument for the delay."}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "nb_transport_fw nb_transport_bw b_transport"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Forward path call. Implementation of the backward path. Execute a blocking transaction."}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "tlm t RANsPORt met HOds"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Each of the interface methods take a handle to the transaction to be transported and a reference argument for the delay. In addition, the nonblocking interfaces take a reference argument for the phase."}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "virtual function uvm_tlm_sync_e nb_transport_fw(T t,ref P p,input uvm_tlm_time delay ）"}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "Forward path call. The first call to this method for a transaction marks the initial timing point. Every call to this method may mark a timing point in the execution of the transaction. The timing annotation argument allows the timing points to be offset from the simulation times at which the forward path is used. The final timing point of a transaction may be marked by a call to nb_transport_bw or a return from this or subsequent call to nb_transport_fw."}
{"type": "text", "page_from": 295, "page_to": 295, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=295", "section_title": "Types", "content": "See TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset for more details on the semantics and rules of the nonblocking transport interface."}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "virtual function uvm_tlm_sync_e nb_transport_bw( T t, ref P p, input uvm_tlm_time delay"}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "Implementation of the backward path. This function MUST be implemented in the INITIATOR component class."}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "Every call to this method may mark a timing point, including the final timing point, in the execution of the transaction. The timing annotation argument allows the timing point to be offset from the simulation times at which the backward path is used. The final timing point of a transaction may be marked by a call to nb_transport_fw or a return from this or subsequent call to nb_transport_bw."}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "See TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset for more details on the semantics and rules of the nonblocking transport interface."}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "uvm_tlm_nb_initiator_socket #(trans, uvm_tlm_phase_e, this_t) initiator_socket;"}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "initiator_socket $=$ new(“initiator_socket”, this, this);"}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "virtual task b_transport( T t, uvm_tlm_time delay )"}
{"type": "text", "page_from": 296, "page_to": 296, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=296", "section_title": "Types", "content": "Execute a blocking transaction. Once this method returns, the transaction is assumed to have been executed. Whether that execution is successful or not must be indicated by"}
{"type": "text", "page_from": 297, "page_to": 297, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=297", "section_title": "Types", "content": "the transaction itself."}
{"type": "text", "page_from": 297, "page_to": 297, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=297", "section_title": "Types", "content": "The callee may modify or update the transaction object, subject to any constraints imposed by the transaction class. The initiator may re-use a transaction object from one call to the next and across calls to b_transport()."}
{"type": "text", "page_from": 297, "page_to": 297, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=297", "section_title": "Types", "content": "The call to b_transport shall mark the first timing point of the transaction. The return from b_transport shall mark the final timing point of the transaction. The timing annotation argument allows the timing points to be offset from the simulation times at which the task call and return are executed."}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "TLM Generic Payload & Extensions", "header_path": ["15", "3"], "chapter": "15", "section": "15.3", "content": "15.3 TLM Generic Payload & Extensions"}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "The Generic Payload transaction represents a generic bus read/write access. It is used as the default transaction in TLM2 blocking and nonblocking transport interfaces."}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "Defines, Constants, enums."}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "Command attribute type definitionUVM_TLM_READ_COMMAND Bus read operationUVM_TLM_WRITE_COMMAND Bus write operationUVM_TLM_IGNORE_COMMAND No bus operation."}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "uvm_tlm_response_status_e"}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "Response status attribute type definition UVM_TLM_OK_RESPONSE"}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "UVM_TLM_INCOMPLETE_RESPONSE"}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "Bus operation completed successfully Transaction was not delivered to target Bus operation had an error Invalid address specified Invalid command specified Invalid burst specified Invalid byte enabling specified"}
{"type": "text", "page_from": 298, "page_to": 298, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=298", "section_title": "Generic Payload & Extensions", "content": "UVM_TLM_GENERIC_ERROR_RESPONSEUVM_TLM_ADDRESS_ERROR_RESPONSEUVM_TLM_COMMAND_ERROR_RESPONSEUVM_TLM_BURST_ERROR_RESPONSEUVM_TLM_BYTE_ENABLE_ERROR_RESPONSE"}
{"type": "text", "page_from": 299, "page_to": 299, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=299", "section_title": "Generic Payload & Extensions", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 299, "page_to": 299, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=299", "section_title": "Generic Payload & Extensions", "content": "This class provides a transaction definition commonly used in memory-mapped bus-based systems. It’s intended to be a general purpose transaction class that lends itself to many applications. The class is derived from uvm_sequence_item which enables it to be generated in sequences and transported to drivers through sequencers."}
{"type": "text", "page_from": 299, "page_to": 299, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=299", "section_title": "Generic Payload & Extensions", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 299, "page_to": 299, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=299", "section_title": "Generic Payload & Extensions", "content": "This class provides a transaction definition commonly used in memory-mapped bus-based systems."}
{"type": "text", "page_from": 299, "page_to": 299, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=299", "section_title": "Generic Payload & Extensions", "content": "Cl ASS Decl ARAt ION"}
{"type": "text", "page_from": 300, "page_to": 300, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=300", "section_title": "Generic Payload & Extensions", "content": "rand bit [63:0] m_address"}
{"type": "text", "page_from": 300, "page_to": 300, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=300", "section_title": "Generic Payload & Extensions", "content": "Address for the bus operation. Should be set or read using the set_address and get_address methods. The variable should be used only when constraining."}
{"type": "text", "page_from": 300, "page_to": 300, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=300", "section_title": "Generic Payload & Extensions", "content": "For a read command or a write command, the target shall interpret the current value of the address attribute as the start address in the system memory map of the contiguous block of data being read or written. The address associated with any given byte in the data array is dependent upon the address attribute, the array index, the streaming width attribute, the endianness and the width of the physical bus."}
{"type": "text", "page_from": 300, "page_to": 300, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=300", "section_title": "Generic Payload & Extensions", "content": "If the target is unable to execute the transaction with the given address attribute (because the address is out-of-range, for example) it shall generate a standard error response. The recommended response status is UVM_TLM_ADDRESS_ERROR_RESPONSE."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "rand uvm_tlm_command_e m_command"}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "Bus operation type. Should be set using the set_command, set_read or set_write methods and read using the get_command, is_read or is_write methods. The variable should be used only when constraining."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "If the target is unable to execute a read or write command, it shall generate a standard error response. The recommended response status is UVM_TLM_COMMAND_ERROR_RESPONSE."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "On receipt of a generic payload transaction with the command attribute equal to UVM_TLM_IGNORE_COMMAND, the target shall not execute a write command or a read command not modify any data. The target may, however, use the value of any attribute in the generic payload, including any extensions."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "The command attribute shall be set by the initiator, and shall not be overwritten by any interconnect"}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "rand byte unsigned m_data[]"}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "Data read or to be written. Should be set and read using the set_data or get_data methods The variable should be used only when constraining."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "For a read command or a write command, the target shall copy data to or from the data array, respectively, honoring the semantics of the remaining attributes of the generic payload."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "For a write command or UVM_TLM_IGNORE_COMMAND, the contents of the data array shall be set by the initiator, and shall not be overwritten by any interconnect component or target. For a read command, the contents of the data array shall be overwritten by the target (honoring the semantics of the byte enable) but by no other component."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "Unlike the OSCI TLM-2.0 LRM, there is no requirement on the endiannes of multi-byte data in the generic payload to match the host endianness. Unlike $\\mathsf { C } + + ,$ it is not possible in SystemVerilog to cast an arbitrary data type as an array of bytes. Therefore, matching the host endianness is not necessary. In contrast, arbitrary data types may be converted to and from a byte array using the streaming operator and uvm_object objects may be further converted using the uvm_object::pack_bytes() and uvm_object::unpack_bytes() methods. All that is required is that a consistent mechanism is used to fill the payload data array and later extract data from it."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "Should a generic payload be transferred to/from a SystemC model, it will be necessary for any multi-byte data in that generic payload to use/be interpreted using the host endianness. However, this process is currently outside the scope of this standard."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "rand int unsigned m_length"}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "The number of bytes to be copied to or from the m_data array, inclusive of any bytes disabled by the m_byte_enable attribute."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "The data length attribute shall be set by the initiator, and shall not be overwritten by any interconnect component or target."}
{"type": "text", "page_from": 301, "page_to": 301, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=301", "section_title": "Generic Payload & Extensions", "content": "The data length attribute shall not be set to 0. In order to transfer zero bytes, the"}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "m_command attribute should be set to UVM_TLM_IGNORE_COMMAND."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "rand uvm_tlm_response_status_e m_response_status"}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "Status of the bus operation. Should be set using the set_response_status method and read using the get_response_status, get_response_string, is_response_ok or is_response_error methods. The variable should be used only when constraining."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "The response status attribute shall be set to UVM_TLM_INCOMPLETE_RESPONSE by the initiator, and may be overwritten by the target. The response status attribute should not be overwritten by any interconnect component, because the default value UVM_TLM_INCOMPLETE_RESPONSE indicates that the transaction was not delivered to the target."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "The target may set the response status attribute to UVM_TLM_OK_RESPONSE to indicate that it was able to execute the command successfully, or to one of the five error responses to indicate an error. The target should choose the appropriate error response depending on the cause of the error. If a target detects an error but is unable to select a specific error response, it may set the response status to UVM_TLM_GENERIC_ERROR_RESPONSE."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "The target shall be responsible for setting the response status attribute at the appropriate point in the lifetime of the transaction. In the case of the blocking transport interface, this means before returning control from b_transport. In the case of the nonblocking transport interface and the base protocol, this means before sending the BEGIN_RESP phase or returning a value of UVM_TLM_COMPLETED."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "It is recommended that the initiator should always check the response status attribute on receiving a transition to the BEGIN_RESP phase or after the completion of the transaction. An initiator may choose to ignore the response status if it is known in advance that the value will be UVM_TLM_OK_RESPONSE, perhaps because it is known in advance that the initiator is only connected to targets that always return UVM_TLM_OK_RESPONSE, but in general this will not be the case. In other words, the initiator ignores the response status at its own risk."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "DMI mode is not yet supported in the UVM TLM2 subset. This variable is provided for completeness and interoperability with SystemC."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "rand byte unsigned m_byte_enable[]"}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "Indicates valid m_data array elements. Should be set and read using the set_byte_enable or get_byte_enable methods The variable should be used only when constraining."}
{"type": "text", "page_from": 302, "page_to": 302, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=302", "section_title": "Generic Payload & Extensions", "content": "The elements in the byte enable array shall be interpreted as follows. A value of $\\mathtt { 8 ^ { \\prime } h 0 0 }$ shall indicate that that corresponding byte is disabled, and a value of 8’hFF shall indicate that the corresponding byte is enabled."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "Byte enables may be used to create burst transfers where the address increment between each beat is greater than the number of significant bytes transferred on each beat, or to place words in selected byte lanes of a bus. At a more abstract level, byte enables may be used to create “lacy bursts” where the data array of the generic payload has an arbitrary pattern of holes punched in it."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "The byte enable mask may be defined by a small pattern applied repeatedly or by a large pattern covering the whole data array. The byte enable array may be empty, in which case byte enables shall not be used for the current transaction."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "The byte enable array shall be set by the initiator and shall not be overwritten by any interconnect component or target."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "If the byte enable pointer is not empty, the target shall either implement the semantics of the byte enable as defined below or shall generate a standard error response. The recommended response status is UVM_TLM_BYTE_ENABLE_ERROR_RESPONSE."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "In the case of a write command, any interconnect component or target should ignore the values of any disabled bytes in the m_data array. In the case of a read command, any interconnect component or target should not modify the values of disabled bytes in the m_data array."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "m_byte_enable_length"}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "rand int unsigned m_byte_enable_length"}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "The number of elements in the m_byte_enable array."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "It shall be set by the initiator, and shall not be overwritten by any interconnect component or target."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "rand int unsigned m_streaming_width"}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "Number of bytes transferred on each beat. Should be set and read using the set_streaming_width or get_streaming_width methods The variable should be used only when constraining."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "Streaming affects the way a component should interpret the data array. A stream consists of a sequence of data transfers occurring on successive notional beats, each beat having the same start address as given by the generic payload address attribute. The streaming width attribute shall determine the width of the stream, that is, the number of bytes transferred on each beat. In other words, streaming affects the local address associated with each byte in the data array. In all other respects, the organization of the data array is unaffected by streaming."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "The bytes within the data array have a corresponding sequence of local addresses within the component accessing the generic payload transaction. The lowest address is given by the value of the address attribute. The highest address is given by the formula address_attribute $^ +$ streaming_width - 1. The address to or from which each byte is being copied in the target shall be set to the value of the address attribute at the start of each beat."}
{"type": "text", "page_from": 303, "page_to": 303, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=303", "section_title": "Generic Payload & Extensions", "content": "With respect to the interpretation of the data array, a single transaction with a streaming width shall be functionally equivalent to a sequence of transactions each having the same address as the original transaction, each having a data length attribute equal to the streaming width of the original, and each with a data array that is a different subset of the original data array on each beat. This subset effectively steps down the original data array maintaining the sequence of bytes."}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "A streaming width of 0 indicates that a streaming transfer is not required. it is equivalent to a streaming width value greater than or equal to the size of the m_data array."}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "Streaming may be used in conjunction with byte enables, in which case the streaming width would typically be equal to the byte enable length. It would also make sense to have the streaming width a multiple of the byte enable length. Having the byte enable length a multiple of the streaming width would imply that different bytes were enabled on each beat."}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "If the target is unable to execute the transaction with the given streaming width, it shall generate a standard error response. The recommended response status is TLM_BURST_ERROR_RESPONSE."}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "Create a new instance of the generic payload. Initialize all the members to their default values."}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "The accessor functions let you set and get each of the members of the generic payload. All of the accessor methods are virtual. This implies a slightly different use model for the generic payload than in SystemC. The way the generic payload is defined in SystemC does not encourage you to create new transaction types derived from uvm_tlm_generic_payload. Instead, you would use the extensions mechanism. Thus in SystemC none of the accessors are virtual."}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "virtual function uvm_tlm_command_e get_command()"}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "Get the value of the m_command variable"}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_command( uvm_tlm_command_e command"}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "Set the value of the m_command variable"}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "virtual function bit is_read()"}
{"type": "text", "page_from": 304, "page_to": 304, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=304", "section_title": "Generic Payload & Extensions", "content": "Returns true if the current value of the m_command variable is"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_read()"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "Set the current value of the m_command variable to UVM_TLM_READ_COMMAND."}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "virtual function bit is_write()"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "Returns true if the current value of the m_command variable isUVM_TLM_WRITE_COMMAND."}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_write()"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "Set the current value of the m_command variable to UVM_TLM_WRITE_COMMAND."}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_address( bit [63:0] addr"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "Set the value of the m_address variable"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "virtual function bit [63:0] get_address()"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "Get the value of the m_address variable"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "virtual function void get_data ( output byte unsigned p []"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "Return the value of the m_data array"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_data( ref byte unsigned p []"}
{"type": "text", "page_from": 305, "page_to": 305, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=305", "section_title": "Generic Payload & Extensions", "content": "Set the value of the m_data array"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "virtual function int unsigned get_data_length()"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "Return the current size of the m_data array"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_data_length( int unsigned length )"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "Set the value of the m_length"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "virtual function int unsigned get_streaming_width()"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "Get the value of the m_streaming_width array"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_streaming_width( int unsigned width"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "Set the value of the m_streaming_width array"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "virtual function void get_byte_enable( output byte unsigned p[]"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "Return the value of the m_byte_enable array"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_byte_enable( ref byte unsigned p[]"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "Set the value of the m_byte_enable array"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "get_byte_enable_length"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "virtual function int unsigned get_byte_enable_length()"}
{"type": "text", "page_from": 306, "page_to": 306, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=306", "section_title": "Generic Payload & Extensions", "content": "Return the current size of the m_byte_enable array"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "set_byte_enable_length"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_byte_enable_length( int unsigned length"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "Set the size m_byte_enable_length of the m_byte_enable array i.e. m_byte_enable.size()"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_dmi_allowed( bit dmi"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "DMI hint. Set the internal flag m_dmi to allow dmi access"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "virtual function bit is_dmi_allowed()"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "DMI hint. Query the internal flag m_dmi if allowed dmi access"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "virtual function uvm_tlm_response_status_e get_response_status()"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "Return the current value of the m_response_status variable"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "virtual function void set_response_status( uvm_tlm_response_status_e status"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "Set the current value of the m_response_status variable"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "virtual function bit is_response_ok()"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "Return TRUE if the current value of the m_response_status variable is UVM_TLM_OK_RESPONSE"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "virtual function bit is_response_error()"}
{"type": "text", "page_from": 307, "page_to": 307, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=307", "section_title": "Generic Payload & Extensions", "content": "Return TRUE if the current value of the m_response_status variable is not UVM_TLM_OK_RESPONSE"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "virtual function string get_response_string()"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "Return the current value of the m_response_status variable as a string"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "function uvm_tlm_extension_base set_extension( uvm_tlm_extension_base ext"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "Add an instance-specific extension. Only one instance of any given extension type is allowed. If there is an existing extension instance of the type of $e x t$ , ext replaces it and its handle is returned. Otherwise, null is returned."}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "function int get_num_extensions()"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "Return the current number of instance specific extensions."}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "function uvm_tlm_extension_base get_extension( uvm_tlm_extension_base ext_handle"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "Return the instance specific extension bound under the specified key. If no extension is bound under that key, null is returned."}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "function void clear_extension( uvm_tlm_extension_base ext_handle"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "Remove the instance-specific extension bound under the specified key."}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "function void clear_extensions()"}
{"type": "text", "page_from": 308, "page_to": 308, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=308", "section_title": "Generic Payload & Extensions", "content": "Remove all instance-specific extensions"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "function void pre_randomize()"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "Prepare this class instance for randomization"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "function void post_randomize()"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "Clean-up this class instance after randomization"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "This typedef provides a short, more convenient name for the uvm_tlm_generic_payload type."}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "This typedef provides a short, more convenient name for the uvm_tlm_generic_payload type."}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "Cl ASS Decl ARAt ION"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "typedef uvm_tlm_generic_payload uvm_tlm_gp"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "The class uvm_tlm_extension_base is the non-parameterized base class for all generic payload extensions. It includes the utility do_copy() and create(). The pure virtual function get_type_handle() allows you to get a unique handle that represents the derived type. This is implemented in derived classes."}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "This class is never used directly by users. The uvm_tlm_extension class is used instead."}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "uvm_tlm_extension_base"}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "The class uvm_tlm_extension_base is the non-parameterized base class for all generic payload extensions."}
{"type": "text", "page_from": 309, "page_to": 309, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=309", "section_title": "Generic Payload & Extensions", "content": "Cl ASS Decl ARAt ION"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "virtual class uvm_tlm_extension_base extends uvm_object"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "function new( string name"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "pure virtual function uvm_tlm_extension_base get_type_handle()"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "An interface to polymorphically retrieve a handle that uniquely identifies the type of the sub-class"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "get_type_handle_name"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "pure virtual function string get_type_handle_name()"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "An interface to polymorphically retrieve the name that uniquely identifies the type of the sub-class"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "virtual function uvm_object create ( string name $=$"}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "TLM extension class. The class is parameterized with arbitrary type which represents the type of the extension. An instance of the generic payload can contain one extension object of each type; it cannot contain two instances of the same extension type."}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "The extension type can be identified using the ID() method."}
{"type": "text", "page_from": 310, "page_to": 310, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=310", "section_title": "Generic Payload & Extensions", "content": "To implement a generic payload extension, simply derive a new class from this class and specify the name of the derived class as the extension parameter."}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "class my_ID extends uvm_tlm_extension#(my_ID); int ID; \\`uvm_object_utils_begin(my_ID) \\`uvm_field_int(ID, UVM_ALL_ON) \\`uvm_object_utils_end function new(string name $=$ \"my_ID\"); super.new(name); endfunction endclass"}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "TLM extension class."}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "Cl ASS Decl ARAt ION"}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "class uvm_tlm_extension #( type int ) extends uvm_tlm_extension_base"}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "new creates a new extension object. ID() Return the unique ID of this TLM extension type."}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "function new( string name"}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "creates a new extension object."}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "static function this_type ID()"}
{"type": "text", "page_from": 311, "page_to": 311, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=311", "section_title": "Generic Payload & Extensions", "content": "Return the unique ID of this TLM extension type. This method is used to identify the type of the extension to retrieve from a uvm_tlm_generic_payload instance, using the uvm_tlm_generic_payload::get_extension() method."}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "TLM Socket Base Classes", "header_path": ["15", "4"], "chapter": "15", "section": "15.4", "content": "15.4 TLM Socket Base Classes"}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "A collection of base classes, one for each socket type. The reason for having a base class for each socket is that all the socket (base) types must be known before connect is defined. Socket connection semantics are provided in the derived classes, which are user visible."}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "A termination socket must be the terminus of every TLM path. A transaction originates with an initiator socket and ultimately ends up in a target socket. There may be zero or more pass-through sockets between initiator and target."}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "Pass-through Sockets"}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "Pass-through initiators are ports and contain exports for instance IS-A port and HAS-A export. Passthrough targets are the opposite, they are exports and contain ports."}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "IS-A forward imp; has no backward path except via the payload contents."}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "uvm_tlm_b_target_socket_base"}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "IS-A forward imp; has no backward path except via the payload contents."}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "uvm_port_base#(uvm_tlm_if#(T))"}
{"type": "text", "page_from": 312, "page_to": 312, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=312", "section_title": "Socket Base Classes", "content": "uvm_tlm_b_target_socket_base"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "class uvm_tlm_b_target_socket_base #( type T $=$ uvm_tlm_generic_payload ) extends uvm_port_base #(uvm_tlm_if #(T))"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "IS-A forward port; has no backward path except via the payload contents"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "uvm_tlm_b_initiator_socket_base"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "IS-A forward port; has no backward path except via the payload contents"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "uvm_port_base#(uvm_tlm_if#(T)) uvm_tlm_b_initiator_socket_base"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "class uvm_tlm_b_initiator_socket_base #( type T $=$ uvm_tlm_generic_payload ) extends uvm_port_base #(uvm_tlm_if #(T))"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "IS-A forward imp; HAS-A backward port"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "uvm_tlm_nb_target_socket_base"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "IS-A forward imp; HAS-A backward port"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "uvm_port_base#(uvm_tlm_if#(T,P))"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "uvm_tlm_nb_target_socket_base"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 313, "page_to": 313, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=313", "section_title": "Socket Base Classes", "content": "class uvm_tlm_nb_target_socket_base #( type T $=$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e ) extends uvm_port_base #(uvm_tlm_if #(T,P))"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "IS-A forward port; HAS-A backward imp"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "uvm_tlm_nb_initiator_socket_base"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "IS-A forward port; HAS-A backward imp"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "uvm_port_base#(uvm_tlm_if#(T,P)) uvm_tlm_nb_initiator_socket_base"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "class uvm_tlm_nb_initiator_socket_base #( type T $=$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e ) extends uvm_port_base #(uvm_tlm_if #(T,P))"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "IS-A forward port; HAS-A backward export"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "uvm_tlm_nb_passthrough_initiator_socket_base"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "IS-A forward port; HAS-A backward export"}
{"type": "text", "page_from": 314, "page_to": 314, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=314", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "uvm_tlm_nb_passthrough_target_socket_base"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "IS-A forward export; HAS-A backward port"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "uvm_tlm_b_passthrough_initiator_socket_base"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "class uvm_tlm_b_passthrough_initiator_socket_base #( type T $=$ uvm_tlm_generic_payload ) extends uvm_port_base #(uvm_tlm_if #(T))"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "uvm_tlm_b_passthrough_target_socket_base"}
{"type": "text", "page_from": 315, "page_to": 315, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=315", "section_title": "Socket Base Classes", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 316, "page_to": 316, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=316", "section_title": "Socket Base Classes", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 316, "page_to": 316, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=316", "section_title": "Socket Base Classes", "content": "class uvm_tlm_b_passthrough_target_socket_base #( type T $=$ uvm_tlm_generic_payload ) extends uvm_port_base #(uvm_tlm_if #(T))"}
{"type": "text", "page_from": 317, "page_to": 317, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=317", "section_title": "Sockets", "content": "Each uvm_tlm_\\*_socket class is derived from a corresponding uvm_tlm_\\*_socket_base class. The base class contains most of the implementation of the class, The derived classes (in this file) contain the connection semantics."}
{"type": "text", "page_from": 317, "page_to": 317, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=317", "section_title": "Sockets", "content": "Sockets come in several flavors: Each socket is either an initiator or a target, a passthrough or a terminator. Further, any particular socket implements either the blocking interfaces or the nonblocking interfaces. Terminator sockets are used on initiators and targets as well as interconnect components as shown in the figure above. Pass-through sockets are used to enable connections to cross hierarchical boundaries."}
{"type": "text", "page_from": 317, "page_to": 317, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=317", "section_title": "Sockets", "content": "There are eight socket types: the cross of blocking and nonblocking, pass-through and termination, target and initiator"}
{"type": "text", "page_from": 317, "page_to": 317, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=317", "section_title": "Sockets", "content": "Sockets are specified based on what they are (IS-A) and what they contains (HAS-A). IS-A and HAS-A are types of object relationships. IS-A refers to the inheritance relationship and HAS-A refers to the ownership relationship. For example if you say D is a B that means that D is derived from base B. If you say object A HAS-A B that means that B is a member of A."}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "uvm_tlm_b_initiator_socket"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "class uvm_tlm_b_initiator_socket #( type T $=$ uvm_tlm_generic_payload ) extends uvm_tlm_b_initiator_socket_base #(T)"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "new Construct a new instance of this socket Connect Connect this socket to the specified uvm_tlm_b_target_socket"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "function new( string name, uvm_component parent )"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "Construct a new instance of this socket"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "Connect this socket to the specified uvm_tlm_b_target_socket"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "uvm_tlm_b_target_socket"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "IS-A forward imp; has no backward path except via the payload contents."}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "The component instantiating this socket must implement a b_transport() method with the following signature"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "task b_transport(T t, uvm_tlm_time delay);"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "uvm_tlm_b_target_socket"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "IS-A forward imp; has no backward path except via the payload contents."}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "uvm_tlm_b_target_socket_base#(T)"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "uvm_tlm_b_target_socket"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 318, "page_to": 318, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=318", "section_title": "Sockets", "content": "class uvm_tlm_b_target_socket #("}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "new Construct a new instance of this socket imp is a reference to the class implementing the b_transport() method. Connect Connect this socket to the specified uvm_tlm_b_initiator_socket"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "function new ( string name, uvm_component parent, IMP imp = null )"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "Construct a new instance of this socket imp is a reference to the class implementing the b_transport() method. If not specified, it is assume to be the same as parent."}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "Connect this socket to the specified uvm_tlm_b_initiator_socket"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "IS-A forward port; HAS-A backward imp"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "The component instantiating this socket must implement a nb_transport_bw() method with the following signature"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "IS-A forward port; HAS-A backward imp"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "uvm_tlm_nb_initiator_socket_base#(T,P) uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 319, "page_to": 319, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=319", "section_title": "Sockets", "content": "class uvm_tlm_nb_initiator_socket #("}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "new Construct a new instance of this socket imp is a reference to the class implementing the nb_transport_bw() method. Connect Connect this socket to the specified uvm_tlm_nb_target_socket"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "function new( string name, uvm_component parent, IMP imp = null"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "Construct a new instance of this socket imp is a reference to the class implementing the nb_transport_bw() method. If not specified, it is assume to be the same as parent."}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "Connect this socket to the specified uvm_tlm_nb_target_socket"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "IS-A forward imp; HAS-A backward port"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "The component instantiating this socket must implement a nb_transport_fw() method with the following signature"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "uvm_tlm_nb_target_socket"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "IS-A forward imp; HAS-A backward port"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "uvm_tlm_nb_target_socket_base#(T,P) uvm_tlm_nb_target_socket"}
{"type": "text", "page_from": 320, "page_to": 320, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=320", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "new Construct a new instance of this socket imp is a reference to the class implementing the nb_transport_fw() method. connect Connect this socket to the specified uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "function new string ( name, uvm_component parent, IMP imp = null"}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "Construct a new instance of this socket imp is a reference to the class implementing the nb_transport_fw() method. If not specified, it is assume to be the same as parent."}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "function void connect( this_type provider"}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "Connect this socket to the specified uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "uvm_tlm_b_passthrough_initiator_socket"}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "uvm_tlm_b_passthrough_initiator_socket"}
{"type": "text", "page_from": 321, "page_to": 321, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=321", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "IS-A forward export;"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "uvm_tlm_b_passthrough_target_socket"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "IS-A forward export;"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "class uvm_tlm_b_passthrough_target_socket #( type T $=$ uvm_tlm_generic_payload ) extends uvm_tlm_b_passthrough_target_socket_base #(T)"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "IS-A forward port; HAS-A backward export"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "uvm_tlm_nb_passthrough_initiator_socket"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "IS-A forward port; HAS-A backward export"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 322, "page_to": 322, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=322", "section_title": "Sockets", "content": "class uvm_tlm_nb_passthrough_initiator_socket #( type T $\\mathop { \\ b { = } }$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e extends uvm_tlm_nb_passthrough_initiator_socket_base #(T,P)"}
{"type": "text", "page_from": 323, "page_to": 323, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=323", "section_title": "Sockets", "content": "uvm_tlm_nb_passthrough_target_socket"}
{"type": "text", "page_from": 323, "page_to": 323, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=323", "section_title": "Sockets", "content": "IS-A forward export; HAS-A backward port"}
{"type": "text", "page_from": 323, "page_to": 323, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=323", "section_title": "Sockets", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 323, "page_to": 323, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=323", "section_title": "Sockets", "content": "class uvm_tlm_nb_passthrough_target_socket #( type T $=$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e ) extends uvm_tlm_nb_passthrough_target_socket_base #(T,P)"}
{"type": "text", "page_from": 323, "page_to": 323, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=323", "section_title": "Sockets", "content": "connect Connect this socket to the specified uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 323, "page_to": 323, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=323", "section_title": "Sockets", "content": "function void connect( this_type provider"}
{"type": "text", "page_from": 323, "page_to": 323, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=323", "section_title": "Sockets", "content": "Connect this socket to the specified uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "TLM2 Export Classes", "header_path": ["15", "6"], "chapter": "15", "section": "15.6", "content": "15.6 TLM2 Export Classes"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "This section defines the export classes for connecting TLM2 interfaces."}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "Blocking transport export class."}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "uvm_tlm_b_transport_export"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "Blocking transport export class."}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "uvm_port_base#(uvm_tlm_if#(T))"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "uvm_tlm_b_transport_export"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "Cl Ass Decl ARAt ION"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "class uvm_tlm_b_transport_export #( type T = uvm_tlm_generic_payload ) extends uvm_port_base #(uvm_tlm_if #(T))"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "Non-blocking forward transport export class"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "uvm_tlm_nb_transport_fw_export"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "Non-blocking forward transport export class"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "uvm_port_base#(uvm_tlm_if#(T,P))"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "uvm_tlm_nb_transport_fw_export"}
{"type": "text", "page_from": 324, "page_to": 324, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=324", "section_title": "Export Classes", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "Cl Ass Decl ARAt ION"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "class uvm_tlm_nb_transport_fw_export #( type T $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e ) extends uvm_port_base #(uvm_tlm_if #(T,P))"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "uvm_tlm_nb_transport_bw_export"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "Non-blocking backward transport export class"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "uvm_tlm_nb_transport_bw_export"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "Non-blocking backward transport export class"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "uvm_port_base#(uvm_tlm_if#(T,P))"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "uvm_tlm_nb_transport_bw_export"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "Cl Ass Decl ARAt ION"}
{"type": "text", "page_from": 325, "page_to": 325, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=325", "section_title": "Export Classes", "content": "class uvm_tlm_nb_transport_bw_export #( type T $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e ) extends uvm_port_base #(uvm_tlm_if #(T,P))"}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "TLM2 imps (interface implementations)", "header_path": ["15", "7"], "chapter": "15", "section": "15.7", "content": "15.7 TLM2 imps (interface implementations)"}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "This section defines the implementation classes for connecting TLM2 interfaces."}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "TLM imps bind a TLM interface with the object that contains the interface implementation. In addition to the transaction type and the phase type, the imps are parameterized with the type of the object that will provide the implementation. Most often this will be the type of the component where the imp resides. The constructor of the imp takes as an argument an object of type IMP and installs it as the implementation object. Most often the imp constructor argument is “this”."}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "\\`UVM_TLM_NB _TRANS POR T_FW_IMP"}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "The macro wraps the forward path call function nb_transport_fw()"}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "The first call to this method for a transaction marks the initial timing point. Every call to this method may mark a timing point in the execution of the transaction. The timing annotation argument allows the timing points to be offset from the simulation times at which the forward path is used. The final timing point of a transaction may be marked by a call to nb_transport_bw() within \\`UVM_TLM_NB_TRANSPORT_BW_IMP or a return from this or subsequent call to nb_transport_fw()."}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "See TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset for more details on the semantics and rules of the nonblocking transport interface."}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "UVM_TLM_NB _TRANS POR T_BW_IMP"}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "Implementation of the backward path. The macro wraps the function called"}
{"type": "text", "page_from": 326, "page_to": 326, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=326", "section_title": "Interface Implementations", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "nb_transport_bw(). This function MUST be implemented in the INITIATOR component class."}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "Every call to this method may mark a timing point, including the final timing point, in the execution of the transaction. The timing annotation argument allows the timing point to be offset from the simulation times at which the backward path is used. The final timing point of a transaction may be marked by a call to nb_transport_fw() within \\`UVM_TLM_NB_TRANSPORT_FW_IMP or a return from this or subsequent call to nb_transport_bw()."}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "See TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset for more details on the semantics and rules of the nonblocking transport interface."}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "\\`UVM_TLM_B_TRANS POR T_IMP"}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "The macro wraps the function b_transport() Execute a blocking transaction. Once this method returns, the transaction is assumed to have been executed. Whether that execution is successful or not must be indicated by the transaction itself."}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "The callee may modify or update the transaction object, subject to any constraints imposed by the transaction class. The initiator may re-use a transaction object from one call to the next and across calls to b_transport()."}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "The call to b_transport shall mark the first timing point of the transaction. The return from b_transport() shall mark the final timing point of the transaction. The timing annotation argument allows the timing points to be offset from the simulation times at which the task call and return are executed."}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "uvm_tlm_b_transport_imp"}
{"type": "text", "page_from": 327, "page_to": 327, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=327", "section_title": "Interface Implementations", "content": "Used like exports, except an additional class parameter specifies the type of the implementation object. When the imp is instantiated the implementation object is bound."}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "uvm_tlm_b_transport_imp"}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "Used like exports, except an additional class parameter specifies the type of the implementation object."}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "uvm_port_base#(uvm_tlm_if#(T))"}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "uvm_tlm_b_transport_imp"}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "Cl ASS DEcl ARAti ON"}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "Used like exports, except an additional class parameter specifies the type of the implementation object. When the imp is instantiated the implementation object is bound."}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "uvm_tlm_nb_transport_fw_imp"}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "Used like exports, except an additional class parameter specifies the type of the implementation object."}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "Cl ASS DEcl ARAti ON"}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "uvm_tlm_nb_transport_bw_imp"}
{"type": "text", "page_from": 328, "page_to": 328, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=328", "section_title": "Interface Implementations", "content": "Used like exports, except an additional class parameter specifies the type of the implementation object. When the imp is instantiated the implementation object is bound."}
{"type": "text", "page_from": 329, "page_to": 329, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=329", "section_title": "Interface Implementations", "content": "uvm_tlm_nb_transport_bw_imp"}
{"type": "text", "page_from": 329, "page_to": 329, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=329", "section_title": "Interface Implementations", "content": "Used like exports, except an additional class parameter specifies the type of the implementation object."}
{"type": "text", "page_from": 329, "page_to": 329, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=329", "section_title": "Interface Implementations", "content": "Cl ASS DEcl ARAti ON"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "The following defines TLM2 port classes."}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "uvm_tlm_b_transport_port"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "Class providing the blocking transport port. The port can be bound to one export. There is no backward path for the blocking transport."}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "uvm_tlm_b_transport_port"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "Class providing the blocking transport port."}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "uvm_port_base#(uvm_tlm_if#(T))"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "uvm_tlm_b_transport_port"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "class uvm_tlm_b_transport_port #( type T $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ uvm_tlm_generic_payload ) extends uvm_port_base #(uvm_tlm_if #(T))"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "uvm_tlm_nb_transport_fw_port"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "Class providing the non-blocking backward transport port. Transactions received from the producer, on the forward path, are sent back to the producer on the backward path using this non-blocking transport port. The port can be bound to one export."}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "uvm_tlm_nb_transport_fw_port"}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "Class providing the non-blocking backward transport port."}
{"type": "text", "page_from": 330, "page_to": 330, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=330", "section_title": "Ports", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "uvm_port_base#(uvm_tlm_if#(T,P))"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "uvm_tlm_nb_transport_fw_port"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "class uvm_tlm_nb_transport_fw_port #( type T $=$ uvm_tlm_generic_payload, type P = uvm_tlm_phase_e ) extends uvm_port_base #(uvm_tlm_if #(T,P))"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "uvm_tlm_nb_transport_bw_port"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "Class providing the non-blocking backward transport port. Transactions received from the producer, on the forward path, are sent back to the producer on the backward path using this non-blocking transport port The port can be bound to one export."}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "uvm_tlm_nb_transport_bw_port"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "Class providing the non-blocking backward transport port."}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "uvm_port_base#(uvm_tlm_if#(T,P)) uvm_tlm_nb_transport_bw_port"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 331, "page_to": 331, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=331", "section_title": "Ports", "content": "class uvm_tlm_nb_transport_bw_port #( type T $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ uvm_tlm_generic_payload, type P $=$ uvm_tlm_phase_e ) extends uvm_port_base #(uvm_tlm_if #(T,P))"}
{"type": "text", "page_from": 332, "page_to": 332, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=332", "section_title": "uvm_tlm2_time", "content": "Canonical time type that can be used in different timescales"}
{"type": "text", "page_from": 332, "page_to": 332, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=332", "section_title": "uvm_tlm2_time", "content": "This time type is used to represent time values in a canonical form that can bridge initiators and targets located in different timescales and time precisions."}
{"type": "text", "page_from": 332, "page_to": 332, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=332", "section_title": "uvm_tlm2_time", "content": "For a detailed explanation of the purpose for this class, see Why is this necessary."}
{"type": "text", "page_from": 332, "page_to": 332, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=332", "section_title": "uvm_tlm2_time", "content": "Canonical time type that can be used in different timescales"}
{"type": "text", "page_from": 332, "page_to": 332, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=332", "section_title": "uvm_tlm2_time", "content": "Set the default canonical time resolution."}
{"type": "text", "page_from": 332, "page_to": 332, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=332", "section_title": "uvm_tlm2_time", "content": "Must be a power of 10. When co-simulating with SystemC, it is recommended that default canonical time resolution be set to the SystemC time resolution."}
{"type": "text", "page_from": 332, "page_to": 332, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=332", "section_title": "uvm_tlm2_time", "content": "By default, the default resolution is 1.0e-12 (ps)"}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "Create a new canonical time value."}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "The new value is initialized to 0. If a resolution is not specified, the default resolution, as specified by set_time_resolution(), is used."}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "function string get_name()"}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "Return the name of this instance function void reset()"}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "Reset the value to 0 function real get_realtime( time scaled, real secs = 1.0e-9"}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "Return the current canonical time value, scaled for the caller’s timescale scaled must be a time literal value that corresponds to the number of seconds specified in secs (1ns by default). It must be a time literal value that is greater or equal to the current timescale."}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "function void incr( real t, time scaled, real secs = 1.0e-9 )"}
{"type": "text", "page_from": 333, "page_to": 333, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=333", "section_title": "uvm_tlm2_time", "content": "Increment the time value by the specified number of scaled time unit $t$ is a time value expressed in the scale and precision of the caller. scaled must be a time literal value that corresponds to the number of seconds specified in secs (1ns by default). It must be a time literal value that is greater or equal to the current timescale."}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "function void decr(real t,time scaled,real secs ）"}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "Decrement the time value by the specified number of scaled time unit $t$ is a time value expressed in the scale and precision of the caller. scaled must be a time literal value that corresponds to the number of seconds specified in secs (1ns by default). It must be a time literal value that is greater or equal to the current timescale."}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "function real get_abstime( real secs"}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "Return the current canonical time value, in the number of specified time unit, regardless of the current timescale of the caller."}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "secs is the number of seconds in the desired time unit e.g. 1e-9 for nanoseconds."}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "function void set_abstime( real t, real secs"}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "Set the current canonical time value, to the number of specified time unit, regardless of the current timescale of the caller."}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "secs is the number of seconds in the time unit in the value t e.g. 1e-9 for nanoseconds."}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "WHY Is THIs NEcEss ARY"}
{"type": "text", "page_from": 334, "page_to": 334, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=334", "section_title": "uvm_tlm2_time", "content": "Integers are not sufficient, on their own, to represent time without any ambiguity: you need to know the scale of that integer value. That scale is information conveyed outside of that integer. In SystemVerilog, it is based on the timescale that was active when the code was compiled. SystemVerilog properly scales time literals, but not integer values."}
{"type": "text", "page_from": 335, "page_to": 335, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=335", "section_title": "uvm_tlm2_time", "content": "That’s because it does not know the difference between an integer that carries an integer value and an integer that carries a time value. The ‘time’ variables are simply 64-bit integers, they are not scaled back and forth to the underlying precision."}
{"type": "text", "page_from": 335, "page_to": 335, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=335", "section_title": "uvm_tlm2_time", "content": "Within SystemVerilog, we have to worry about different time scale different time precision"}
{"type": "text", "page_from": 335, "page_to": 335, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=335", "section_title": "uvm_tlm2_time", "content": "Because each endpoint in a socket could be coded in different packages and thus be executing under different timescale directives, a simple integer cannot be used to exchange time information across a socket."}
{"type": "text", "page_from": 336, "page_to": 336, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=336", "section_title": "uvm_tlm2_time", "content": "Scaling is needed every time you make a procedural call to code that may interpret a time value in a different timescale."}
{"type": "text", "page_from": 336, "page_to": 336, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=336", "section_title": "uvm_tlm2_time", "content": "Using the uvm_tlm_time type"}
{"type": "text", "page_from": 336, "page_to": 336, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=336", "section_title": "uvm_tlm2_time", "content": "A similar procedure is required when crossing any simulator or language boundary, such as interfacing between SystemVerilog and SystemC."}
{"type": "text", "page_from": 337, "page_to": 337, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=337", "section_title": "Analysis Ports", "content": "This section defines the port, export, and imp classes used for transaction analysis."}
{"type": "text", "page_from": 337, "page_to": 337, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=337", "section_title": "Analysis Ports", "content": "Broadcasts a value to all subscribers implementing a uvm_analysis_imp."}
{"type": "text", "page_from": 337, "page_to": 337, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=337", "section_title": "Analysis Ports", "content": "class mon extends uvm_component; uvm_analysis_port#(trans) ap; function new(string name $=$ \"sb\", uvm_component parent $=$ null); super.new(name, parent); ap $=$ new(\"ap\", this); endfunction task run_phase(uvm_phase phase); trans t; ap.write(t); endfunction endclass"}
{"type": "text", "page_from": 337, "page_to": 337, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=337", "section_title": "Analysis Ports", "content": "Broadcasts a value to all subscribers implementing a uvm_analysis_imp."}
{"type": "text", "page_from": 337, "page_to": 337, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=337", "section_title": "Analysis Ports", "content": "class uvm_analysis_port # ( type T = int ) extends uvm_port_base # (uvm_tlm_if_base #(T,T))"}
{"type": "text", "page_from": 337, "page_to": 337, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=337", "section_title": "Analysis Ports", "content": "Send specified value to all connected interface"}
{"type": "text", "page_from": 338, "page_to": 338, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=338", "section_title": "Analysis Ports", "content": "function void write input T t )"}
{"type": "text", "page_from": 338, "page_to": 338, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=338", "section_title": "Analysis Ports", "content": "Send specified value to all connected interface"}
{"type": "text", "page_from": 338, "page_to": 338, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=338", "section_title": "Analysis Ports", "content": "Receives all transactions broadcasted by a uvm_analysis_port. It serves as the termination point of an analysis port/export/imp connection. The component attached to the imp class--called a subscriber-- implements the analysis interface."}
{"type": "text", "page_from": 338, "page_to": 338, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=338", "section_title": "Analysis Ports", "content": "Will invoke the write $^ { \\prime \\tau ) }$ method in the parent component. The implementation of the write $( T )$ method must not modify the value passed to it."}
{"type": "text", "page_from": 338, "page_to": 338, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=338", "section_title": "Analysis Ports", "content": "Receives all transactions broadcasted by a uvm_analysis_port."}
{"type": "text", "page_from": 338, "page_to": 338, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=338", "section_title": "Analysis Ports", "content": "class uvm_analysis_imp #( type T $=$ int, type IMP $=$ int ) extends uvm_port_base #(uvm_tlm_if_base #(T,T))"}
{"type": "text", "page_from": 339, "page_to": 339, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=339", "section_title": "Analysis Ports", "content": "Exports a lower-level uvm_analysis_imp to its parent."}
{"type": "text", "page_from": 339, "page_to": 339, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=339", "section_title": "Analysis Ports", "content": "Exports a lower-level uvm_analysis_imp to its parent."}
{"type": "text", "page_from": 339, "page_to": 339, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=339", "section_title": "Analysis Ports", "content": "class uvm_analysis_export #( type int ) extends uvm_port_base #(uvm_tlm_if_base #(T,T))"}
{"type": "text", "page_from": 339, "page_to": 339, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=339", "section_title": "Analysis Ports", "content": "new Instantiate the export."}
{"type": "text", "page_from": 339, "page_to": 339, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=339", "section_title": "Analysis Ports", "content": "function new ( string name, uvm_component parent $=$ null )"}
{"type": "text", "page_from": 339, "page_to": 339, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=339", "section_title": "Analysis Ports", "content": "Instantiate the export."}
{"type": "text", "page_from": 340, "page_to": 340, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=340", "section_title": "Components", "content": "Components form the foundation of the UVM. They encapsulate behavior of drivers, scoreboards, and other objects in a testbench. The UVM library provides a set of predefined component types, all derived directly or indirectly from uvm_component."}
{"type": "text", "page_from": 340, "page_to": 340, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=340", "section_title": "Components", "content": "Predefined Components"}
{"type": "text", "page_from": 340, "page_to": 340, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=340", "section_title": "Components", "content": "Predefined Component Classes"}
{"type": "text", "page_from": 340, "page_to": 340, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=340", "section_title": "Components", "content": "Components form the foundation of the UVM."}
{"type": "text", "page_from": 341, "page_to": 341, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=341", "section_title": "uvm_component", "content": "The uvm_component class is the root base class for UVM components. In addition to the features inherited from uvm_object and uvm_report_object, uvm_component provides the following interfaces:"}
{"type": "text", "page_from": 341, "page_to": 341, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=341", "section_title": "uvm_component", "content": "The uvm_component is automatically seeded during construction using UVM seeding, if enabled. All other objects must be manually reseeded, if appropriate. See uvm_object::reseed for more information."}
{"type": "text", "page_from": 341, "page_to": 341, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=341", "section_title": "uvm_component", "content": "The uvm_component class is the root base class for UVM components."}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "function new ( string name, uvm_component parent )"}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "Creates a new component with the given leaf instance name and handle to its parent. If the component is a top-level component (i.e. it is created in a static module or interface), parent should be null."}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "The component will be inserted as a child of the parent object, if any. If parent already has a child by the given name, an error is produced."}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "If parent is null, then the component will become a child of the implicit top-level component, uvm_top."}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "All classes derived from uvm_component must call super.new(name,parent)."}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "HIERARch Y INTERFAcE"}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "These methods provide user access to information about the component hierarchy, i.e., topology."}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "virtual function uvm_component get_parent ()"}
{"type": "text", "page_from": 345, "page_to": 345, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=345", "section_title": "uvm_component", "content": "Returns a handle to this component’s parent, or null if it has no parent."}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "virtual function string get_full_name ()"}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "Returns the full hierarchical name of this object. The default implementation concatenates the hierarchical name of the parent, if any, with the leaf name of this object, as given by uvm_object::get_name."}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "function void get_children(ref uvm_component children[\\$]）"}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "This function populates the end of the children array with the list of this component’s children."}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "function uvm_component get_child ( string name ) function int get_next_child ( ref string name )"}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "function int get_first_child ( ref string name"}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "These methods are used to iterate through this component’s children, if any. For example, given a component with an object handle, comp, the following code calls uvm_object::print for each child:"}
{"type": "text", "page_from": 346, "page_to": 346, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=346", "section_title": "uvm_component", "content": "string name; uvm_component child; if (comp.get_first_child(name)) do begin child $=$ comp.get_child(name); child.print(); end while (comp.get_next_child(name));"}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "function int get_num_children ()"}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "Returns the number of this component’s children."}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "function int has_child ( string name"}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "Returns 1 if this component has a child with the given name, 0 otherwise."}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "function uvm_component lookup ( string name"}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "Looks for a component with the given hierarchical name relative to this component. If the given name is preceded with a ‘.’ (dot), then the search begins relative to the top level (absolute lookup). The handle of the matching component is returned, else null. The name must not contain wildcards."}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "function int unsigned get_depth()"}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "Returns the component’s depth from the root level. uvm_top has a depth of 0. The test and any other top level components have a depth of 1, and so on."}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "These methods implement an interface which allows all components to step through a standard schedule of phases, or a customized schedule, and also an API to allow independent phase domains which can jump like state machines to reflect behavior e.g. power domains on the DUT in different portions of the testbench. The phase tasks and functions are the phase name with the _phase suffix. For example, the build phase function is build_phase."}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "All processes associated with a task-based phase are killed when the phase ends. See uvm_task_phase for more details."}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "virtual function void build_phase( uvm_phase phase"}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "The uvm_build_phase phase implementation method."}
{"type": "text", "page_from": 347, "page_to": 347, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=347", "section_title": "uvm_component", "content": "Any override should call super.build_phase(phase) to execute the automatic configuration of fields registered in the component by calling apply_config_settings. To turn off automatic configuration for a component, do not call super.build_phase(phase)."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "virtual function void connect_phase( uvm_phase phase"}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "The uvm_connect_phase phase implementation method."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "end_of_elaboration_phase"}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "virtual function void end_of_elaboration_phase( uvm_phase phase"}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "The uvm_end_of_elaboration_phase phase implementation method."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "start_of_simulation_phase"}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "virtual function void start_of_simulation_phase( uvm_phase phase"}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "The uvm_start_of_simulation_phase phase implementation method."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "The uvm_run_phase phase implementation method."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. Thus the phase will automatically end once all objections are dropped using phase.drop_objection()."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "The run_phase task should never be called directly."}
{"type": "text", "page_from": 348, "page_to": 348, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=348", "section_title": "uvm_component", "content": "virtual task pre_reset_phase( uvm_phase phase )"}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "The uvm_pre_reset_phase phase implementation method."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "The uvm_reset_phase phase implementation method."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "The uvm_post_reset_phase phase implementation method."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "virtual task pre_configure_phase( uvm_phase phase"}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "The uvm_pre_configure_phase phase implementation method."}
{"type": "text", "page_from": 349, "page_to": 349, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=349", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to"}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "virtual task configure_phase( uvm_phase phase"}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "The uvm_configure_phase phase implementation method."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "post_configure_phase"}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "The uvm_post_configure_phase phase implementation method."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 350, "page_to": 350, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=350", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "killed once the phase ends."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "The uvm_main_phase phase implementation method."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "virtual task post_main_phase( uvm_phase phase"}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "The uvm_post_main_phase phase implementation method."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "The uvm_pre_shutdown_phase phase implementation method."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 351, "page_to": 351, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=351", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "virtual task shutdown_phase( uvm_phase phase"}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "The uvm_shutdown_phase phase implementation method."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "The uvm_post_shutdown_phase phase implementation method."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "This task returning or not does not indicate the end or persistence of this phase. It is necessary to raise an objection using phase.raise_objection() to cause the phase to persist. Once all components have dropped their respective objection using phase.drop_objection(), or if no components raises an objection, the phase is ended."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "Any processes forked by this task continue to run after the task returns, but they will be killed once the phase ends."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "This method should not be called directly."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "virtual function void extract_phase( uvm_phase phase"}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "The uvm_extract_phase phase implementation method."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "virtual function void check_phase( uvm_phase phase"}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "The uvm_check_phase phase implementation method."}
{"type": "text", "page_from": 352, "page_to": 352, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=352", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "virtual function void report_phase( uvm_phase phase"}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "The uvm_report_phase phase implementation method."}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "virtual function void final_phase( uvm_phase phase"}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "The uvm_final_phase phase implementation method."}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "This method should never be called directly."}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "virtual function void phase_started ( uvm_phase phase"}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "Invoked at the start of each phase. The phase argument specifies the phase being started. Any threads spawned in this callback are not affected when the phase ends."}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "virtual function void phase_ready_to_end ( uvm_phase phase"}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "Invoked when all objections to ending the given phase and all sibling phases have been dropped, thus indicating that phase is ready to begin a clean exit. Sibling phases are any phases that have a common successor phase in the schedule plus any phases that sync’d to the current phase. Components needing to consume delta cycles or advance time to perform a clean exit from the phase may raise the phase’s objection."}
{"type": "text", "page_from": 353, "page_to": 353, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=353", "section_title": "uvm_component", "content": "It is the responsibility of this component to drop the objection once it is ready for this phase to end (and processes killed). If no objection to the given phase or sibling phases are raised, then phase_ended() is called after a delta cycle. If any objection is raised, then when all objections to ending the given phase and siblings are dropped, another iteration of phase_ready_to_end is called. To prevent endless iterations due to coding error, after 20 iterations, phase_ended() is called regardless of whether previous iteration had any objections raised."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "virtual function void phase_ended ( uvm_phase phase"}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Invoked at the end of each phase. The phase argument specifies the phase that is ending. Any threads spawned in this callback are not affected when the phase ends."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Apply a phase domain to this component and, if hier is set, recursively to all its children."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Calls the virtual define_domain method, which derived components can override to augment or replace the domain definition of its base class."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "function uvm_domain get_domain()"}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Return handle to the phase domain set on this component"}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Builds custom phase schedules into the provided domain handle."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "This method is called by set_domain, which integrators use to specify this component belongs in a domain apart from the default ‘uvm’ domain."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Custom component base classes requiring a custom phasing schedule can augment or replace the domain definition they inherit by overriding their defined_domain. To augment, overrides would call super.define_domain(). To replace, overrides would not call super.define_domain()."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "The default implementation adds a copy of the uvm phasing schedule to the given domain, if one doesn’t already exist, and only if the domain is currently empty."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Calling set_domain with the default uvm domain (i.e. uvm_domain::get_uvm_domain ) on a component with no define_domain override effectively reverts the that component to using the default uvm domain. This may be useful if a branch of the testbench hierarchy defines a custom domain, but some child sub-branch should remain in the default uvm domain, call set_domain with a new domain instance handle with hier set. Then, in the sub-branch, call set_domain with the default uvm domain handle, obtained via uvm_domain::get_uvm_domain."}
{"type": "text", "page_from": 354, "page_to": 354, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=354", "section_title": "uvm_component", "content": "Alternatively, the integrator may define the graph in a new domain externally, then call set_domain to apply it to a component."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "function void set_phase_imp( uvm_phase phase, uvm_phase imp, int hier = 1 )"}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "Override the default implementation for a phase on this component (tree) with a custom one, which must be created as a singleton object extending the default one and implementing required behavior in exec and traverse methods"}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "The hier specifies whether to apply the custom functor to the whole tree or just this component."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "virtual task suspend ()"}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "Suspend this component."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "This method must be implemented by the user to suspend the component according to the protocol and functionality it implements. A suspended component can be subsequently resumed using resume()."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "virtual task resume ()"}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "Resume this component."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "This method must be implemented by the user to resume a component that was previously suspended using suspend(). Some component may start in the suspended state and may need to be explicitly resumed."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "virtual function void resolve_bindings ()"}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "Processes all port, export, and imp connections. Checks whether each port’s min and max connection requirements are met."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "It is called just before the end_of_elaboration phase."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "Users should not call directly."}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "CONFIGURATION INTERFAcE"}
{"type": "text", "page_from": 355, "page_to": 355, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=355", "section_title": "uvm_component", "content": "Components can be designed to be user-configurable in terms of its topology (the type and number of children it has), mode of operation, and run-time parameters (knobs). The configuration interface accommodates this common need, allowing component composition and state to be modified without having to derive new classes or new class hierarchies for every configuration scenario."}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "function void check_config_usage ( bit recurse ="}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "Check all configuration settings in a components configuration table to determine if the setting has been used, overridden or not used. When recurse is 1 (default), configuration for this and all child components are recursively checked. This function is automatically called in the check phase, but can be manually called at any time."}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "To get all configuration information prior to the run phase, do something like this in your top object:"}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "apply_config_settings"}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "virtual function void apply_config_settings ( bit verbose"}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "Searches for all config settings matching this component’s instance path. For each match, the appropriate set_\\*_local method is called using the matching config setting’s field_name and value. Provided the set_\\*_local method is implemented, the component property associated with the field_name is assigned the given value."}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "This function is called by uvm_component::build_phase."}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "The apply_config_settings method determines all the configuration settings targeting this component and calls the appropriate set_\\*_local method to set each one. To work, you must override one or more set_\\*_local methods to accommodate setting of your component’s specific properties. Any properties registered with the optional \\`uvm_\\*_field macros do not require special handling by the set_\\*_local methods; the macros provide the set_\\*_local functionality for you."}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "If you do not want apply_config_settings to be called for a component, then the build_phase() method should be overloaded and you should not call super.build_phase(phase). Likewise, apply_config_settings can be overloaded to customize automated configuration."}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "When the verbose bit is set, all overrides are printed as they are applied. If the component’s print_config_matches property is set, then apply_config_settings is automatically called with verbose $\\ c = 1$ ."}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "print_config_settings"}
{"type": "text", "page_from": 356, "page_to": 356, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=356", "section_title": "uvm_component", "content": "Called without arguments, print_config_settings prints all configuration information for this component, as set by previous calls to uvm_config_db#(T)::set(). The settings are printing in the order of their precedence."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "If field is specified and non-empty, then only configuration settings matching that field, if any, are printed. The field may not contain wildcards."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "If comp is specified and non-null, then the configuration for that component is printed."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "If recurse is set, then configuration information for all comp’s children and below are printed as well."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "This function has been deprecated. Use print_config instead."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "function void print_config( bit recurse $\\begin{array} { r l } { = { } } & { { } 0 , } \\end{array}$ bit audit $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "Print_config_settings prints all configuration information for this component, as set by previous calls to uvm_config_db#(T)::set() and exports to the resources pool. The settings are printing in the order of their precedence."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "If recurse is set, then configuration information for all children and below are printed as well."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "if audit is set then the audit trail for each resource is printed along with the resource name and value"}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "print_config_with_audit"}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "Operates the same as print_config except that the audit bit is forced to 1. This interface makes user code a bit more readable as it avoids multiple arbitrary bit settings in the argument list."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "If recurse is set, then configuration information for all children and below are printed as well."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "print_config_matches"}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "static bit print_config_matches"}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "Setting this static variable causes uvm_config_db#(T)::get() to print info about matching configuration settings as they are being applied."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "These methods provide object level hooks into the uvm_objection mechanism."}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "virtual function void raised ("}
{"type": "text", "page_from": 357, "page_to": 357, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=357", "section_title": "uvm_component", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 358, "page_to": 358, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=358", "section_title": "uvm_component", "content": "The raised callback is called when this or a descendant of this component instance raises the specified objection. The source_obj is the object that originally raised the objection. The description is optionally provided by the source_obj to give a reason for raising the objection. The count indicates the number of objections raised by the source_obj."}
{"type": "text", "page_from": 358, "page_to": 358, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=358", "section_title": "uvm_component", "content": "The dropped callback is called when this or a descendant of this component instance drops the specified objection. The source_obj is the object that originally dropped the objection. The description is optionally provided by the source_obj to give a reason for dropping the objection. The count indicates the number of objections dropped by the source_obj."}
{"type": "text", "page_from": 358, "page_to": 358, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=358", "section_title": "uvm_component", "content": "The all_droppped callback is called when all objections have been dropped by this component and all its descendants. The source_obj is the object that dropped the last objection. The description is optionally provided by the source_obj to give a reason for raising the objection. The count indicates the number of objections dropped by the source_obj."}
{"type": "text", "page_from": 358, "page_to": 358, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=358", "section_title": "uvm_component", "content": "The factory interface provides convenient access to a portion of UVM’s uvm_factory interface. For creating new objects and components, the preferred method of accessing the factory is via the object or component wrapper (see uvm_component_registry #(T,Tname) and uvm_object_registry #(T,Tname)). The wrapper also provides functions for setting type and instance overrides."}
{"type": "text", "page_from": 358, "page_to": 358, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=358", "section_title": "uvm_component", "content": "function uvm_component create_component ( string requested_type_name, string name"}
{"type": "text", "page_from": 358, "page_to": 358, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=358", "section_title": "uvm_component", "content": "A convenience function for uvm_factory::create_component_by_name, this method calls"}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "upon the factory to create a new child component whose type corresponds to the preregistered type name, requested_type_name, and instance name, name. This method is equivalent to:"}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "If the factory determines that a type or instance override exists, the type of the component created may be different than the requested type. See set_type_override and set_inst_override. See also uvm_factory for details on factory operation."}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "function uvm_object create_object ( string requested_type_name, string name"}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "A convenience function for uvm_factory::create_object_by_name, this method calls upon the factory to create a new object whose type corresponds to the preregistered type name, requested_type_name, and instance name, name. This method is equivalent to:"}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "If the factory determines that a type or instance override exists, the type of the object created may be different than the requested type. See uvm_factory for details on factory operation."}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "set_type_override_by_type"}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "static function void set_type_override_by_type ( uvm_object_wrapper original_type, uvm_object_wrapper override_type, bit replace = 1 )"}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "A convenience function for uvm_factory::set_type_override_by_type, this method registers a factory override for components and objects created at this level of hierarchy or below. This method is equivalent to:"}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "The relative_inst_path is relative to this component and may include wildcards. The original_type represents the type that is being overridden. In subsequent calls to uvm_factory::create_object_by_type or uvm_factory::create_component_by_type, if the requested_type matches the original_type and the instance paths match, the factory will produce the override_type."}
{"type": "text", "page_from": 359, "page_to": 359, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=359", "section_title": "uvm_component", "content": "The original and override type arguments are lightweight proxies to the types they represent. See set_inst_override_by_type for information on usage."}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "set_inst_override_by_type"}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "function void set_inst_override_by_type( string relative_inst_path, uvm_object_wrapper original_type, uvm_object_wrapper override_type )"}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "A convenience function for uvm_factory::set_inst_override_by_type, this method registers a factory override for components and objects created at this level of hierarchy or below. In typical usage, this method is equivalent to:"}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "The relative_inst_path is relative to this component and may include wildcards. The original_type represents the type that is being overridden. In subsequent calls to uvm_factory::create_object_by_type or uvm_factory::create_component_by_type, if the requested_type matches the original_type and the instance paths match, the factory will produce the override_type."}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "The original and override types are lightweight proxies to the types they represent. They can be obtained by calling type::get_type(), if implemented by type, or by directly calling type::type_id::get(), where type is the user type and type_id is the name of the typedef to uvm_object_registry #(T,Tname) or uvm_component_registry #(T,Tname)."}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "If you are employing the \\`uvm_\\*_utils macros, the typedef and the get_type method will be implemented for you. For details on the utils macros refer to Utility and Field Macros for Components and Objects."}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "The following example shows \\`uvm_\\*_utils usage"}
{"type": "text", "page_from": 360, "page_to": 360, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=360", "section_title": "uvm_component", "content": "static function void set_type_override( string original_type_name, string override_type_name, bit replace = 1"}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "A convenience function for uvm_factory::set_type_override_by_name, this method configures the factory to create an object of type override_type_name whenever the factory is asked to produce a type represented by original_type_name. This method is equivalent to:"}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "The original_type_name typically refers to a preregistered type in the factory. It may, however, be any arbitrary string. Subsequent calls to create_component or create_object with the same string and matching instance path will produce the type represented by override_type_name. The override_type_name must refer to a preregistered type in the factory."}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "function void set_inst_override( string relative_inst_path, string original_type_name, string override_type_name )"}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "A convenience function for uvm_factory::set_inst_override_by_name, this method registers a factory override for components created at this level of hierarchy or below. In typical usage, this method is equivalent to:"}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "The relative_inst_path is relative to this component and may include wildcards. The original_type_name typically refers to a preregistered type in the factory. It may, however, be any arbitrary string. Subsequent calls to create_component or create_object with the same string and matching instance path will produce the type represented by override_type_name. The override_type_name must refer to a preregistered type in the factory."}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "function void print_override_info( string requested_type_name, string name )"}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "This factory debug method performs the same lookup process as create_object and create_component, but instead of creating an object, it prints information about what type of object would be created given the provided arguments."}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "HIERARch IcAL REpORTING INTERFAcE"}
{"type": "text", "page_from": 361, "page_to": 361, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=361", "section_title": "uvm_component", "content": "This interface provides versions of the set_report_\\* methods in the uvm_report_object"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "base class that are applied recursively to this component and all its children."}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "When a report is issued and its associated action has the LOG bit set, the report will be sent to its associated FILE descriptor."}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "set_report_id_verbosity_hier"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "function void set_report_id_verbosity_hier ( string id, int verbosity"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "set_report_severity_id_verbosity_hier"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "These methods recursively associate the specified verbosity with reports of the given severity, id, or severity-id pair. A verbosity associated with a particular severity-id pair takes precedence over a verbosity associated with id, which takes precedence over a verbosity associated with a severity."}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "For a list of severities and their default verbosities, refer to uvm_report_handler."}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "set_report_severity_action_hier"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "function void set_report_severity_action_hier ( uvm_severity severity, uvm_action action"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "set_report_id_action_hier"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "function void set_report_id_action_hier ( string id, uvm_action action"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "set_report_severity_id_action_hier"}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "These methods recursively associate the specified action with reports of the given severity, id, or severity-id pair. An action associated with a particular severity-id pair takes precedence over an action associated with id, which takes precedence over an action associated with a severity."}
{"type": "text", "page_from": 362, "page_to": 362, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=362", "section_title": "uvm_component", "content": "For a list of severities and their default actions, refer to uvm_report_handler."}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "set_report_default_file_hier"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "function void set_report_default_file_hier ( UVM_FILE file"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "set_report_severity_file_hier"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "function void set_report_severity_file_hier ( uvm_severity severity, UVM_FILE file"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "set_report_id_file_hier"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "function void set_report_id_file_hier ( string id, UVM_FILE file"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "set_report_severity_id_file_hier"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "These methods recursively associate the specified FILE descriptor with reports of the given severity, id, or severity-id pair. A FILE associated with a particular severity-id pair takes precedence over a FILE associated with id, which take precedence over an a FILE associated with a severity, which takes precedence over the default FILE descriptor."}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "For a list of severities and other information related to the report mechanism, refer to uvm_report_handler."}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "set_report_verbosity_level_hier"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "function void set_report_verbosity_level_hier ( int verbosity"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "This method recursively sets the maximum verbosity level for reports for this component and all those below it. Any report from this component subtree whose verbosity exceeds this maximum will be ignored."}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "See uvm_report_handler for a list of predefined message verbosity levels and their meaning."}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "virtual function void pre_abort"}
{"type": "text", "page_from": 363, "page_to": 363, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=363", "section_title": "uvm_component", "content": "This callback is executed when the message system is executing a UVM_EXIT action."}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "The exit action causes an immediate termination of the simulation, but the pre_abort callback hook gives components an opportunity to provide additional information to the user before the termination happens. For example, a test may want to executed the report function of a particular component even when an error condition has happened to force a premature termination you would write a function like:"}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "The pre_abort() callback hooks are called in a bottom-up fashion."}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "These methods comprise the component-based transaction recording interface. The methods can be used to record the transactions that this component “sees”, i.e. produces or consumes."}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "The API and implementation are subject to change once a vendor-independent use-model is determined."}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "function void accept_tr ( uvm_transaction tr, time accept_time = 0 )"}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "This function marks the acceptance of a transaction, tr, by this component. Specifically, it performs the following actions:"}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "Calls the tr’s uvm_transaction::accept_tr method, passing to it the accept_time argument. Calls this component’s do_accept_tr method to allow for any post-begin action in derived classes. Triggers the component’s internal accept_tr event. Any processes waiting on this event will resume in the next delta cycle."}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "virtual protected function void do_accept_tr ( uvm_transaction tr"}
{"type": "text", "page_from": 364, "page_to": 364, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=364", "section_title": "uvm_component", "content": "The accept_tr method calls this function to accommodate any user-defined post-accept action. Implementations should call super.do_accept_tr to ensure correct operation."}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "This function marks the start of a transaction, $t r ,$ by this component. Specifically, it performs the following actions:"}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "Calls tr’s uvm_transaction::begin_tr method, passing to it the begin_time argument. The begin_time should be greater than or equal to the accept time. By default, when begin_time $= 0$ , the current simulation time is used."}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "If recording is enabled (recording_detail $\\mathsf { \\Omega } ! = \\mathsf { U V M \\_ O F F } ,$ ), then a new database-transaction is started on the component’s transaction stream given by the stream argument. No transaction properties are recorded at this time."}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "Calls the component’s do_begin_tr method to allow for any post-begin action in derived classes. Triggers the component’s internal begin_tr event. Any processes waiting on this event will resume in the next delta cycle."}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "A handle to the transaction is returned. The meaning of this handle, as well as the interpretation of the arguments stream_name, label, and desc are vendor specific."}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "This function marks the start of a child transaction, $t r ,$ by this component. Its operation is identical to that of begin_tr, except that an association is made between this transaction and the provided parent transaction. This association is vendor-specific."}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "The begin_tr and begin_child_tr methods call this function to accommodate any userdefined post-begin action. Implementations should call super.do_begin_tr to ensure correct operation."}
{"type": "text", "page_from": 365, "page_to": 365, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=365", "section_title": "uvm_component", "content": "This function marks the end of a transaction, $t r ,$ by this component. Specifically, it performs the following actions:"}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "Calls tr’s uvm_transaction::end_tr method, passing to it the end_time argument. The end_time must at least be greater than the begin time. By default, when end_time $= 0$ , the current simulation time is used."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "The transaction’s properties are recorded to the database-transaction on which it was started, and then the transaction is ended. Only those properties handled by the transaction’s do_record method (and optional \\`uvm_\\*_field macros) are recorded."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "Calls the component’s do_end_tr method to accommodate any post-end action in derived classes. Triggers the component’s internal end_tr event. Any processes waiting on this event will resume in the next delta cycle."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "The free_handle bit indicates that this transaction is no longer needed. The implementation of free_handle is vendor-specific."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "virtual protected function void do_end_tr ( uvm_transaction tr, integer tr_handle ) The end_tr method calls this function to accommodate any user-defined post-end action. Implementations should call super.do_end_tr to ensure correct operation."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "This function marks an error transaction by a component. Properties of the given uvm_object, info, as implemented in its uvm_object::do_record method, are recorded to the transaction database."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "An error_time of 0 indicates to use the current simulation time. The keep_active bit determines if the handle should remain active. If 0, then a zero-length error transaction is recorded. A handle to the database-transaction is returned."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "Interpretation of this handle, as well as the strings stream_name, label, and desc, are vendor-specific."}
{"type": "text", "page_from": 366, "page_to": 366, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=366", "section_title": "uvm_component", "content": "This function marks an event transaction by a component."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "An event_time of 0 indicates to use the current simulation time."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "A handle to the transaction is returned. The keep_active bit determines if the handle may be used for other vendor-specific purposes."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "The strings for stream_name, label, and desc are vendor-specific identifiers for the transaction."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "virtual function uvm_tr_stream get_tr_stream( string name, string stream_type_name = \"\""}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "Returns a tr stream with this component’s full name as a scope."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "Streams which are retrieved via this method will be stored internally, such that later calls to get_tr_stream will return the same stream reference."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "The stream can be removed from the internal storage via a call to free_tr_stream."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "name Name for the stream stream_type_name Type name for the stream (Default $\\mathbf { \\mu } = \\mathbf { \\mu } ^ { \\mathrm { w } \\prime \\prime }$ )"}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "virtual function void free_tr_stream( uvm_tr_stream stream"}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "Frees the internal references associated with stream."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "The next call to get_tr_stream will result in a newly created uvm_tr_stream. If the current stream is open (or closed), then it will be freed."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "bit print_enabled $\\qquad = \\quad 1$"}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "This bit determines if this component should automatically be printed as a child of its parent object."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "By default, all children are printed. However, this bit allows a parent component to disable the printing of specific children."}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "uvm_tr_database tr_database"}
{"type": "text", "page_from": 367, "page_to": 367, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=367", "section_title": "uvm_component", "content": "Specifies the uvm_tr_database object to use for begin_tr and other methods in the Recording Interface. Default is uvm_coreservice_t::get_default_tr_database."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "This class is the virtual base class for the user-defined tests."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "The uvm_test virtual class should be used as the base class for user-defined tests. Doing so provides the ability to select which test to execute using the UVM_TESTNAME command line or argument to the uvm_root::run_test task."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "The global run_test() task should be specified inside an initial block such as"}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "Multiple tests, identified by their type name, are compiled in and then selected for execution from the command line without need for recompilation. Random seed selection is also available on the command line."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "If $+ \\mathsf { U V } \\mathsf { M } _ { - }$ _TESTNAME $=$ test_name is specified, then an object of type ‘test_name’ is created by factory and phasing begins. Here, it is presumed that the test will instantiate the test environment, or the test environment will have already been instantiated before the call to run_test()."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "If the specified test_name cannot be created by the uvm_factory, then a fatal error occurs. If run_test() is called without UVM_TESTNAME being specified, then all components constructed before the call to run_test will be cycled through their simulation phases."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "Deriving from uvm_test will allow you to distinguish tests from other component types that inherit from uvm_component directly. Such tests will automatically inherit features that may be added to uvm_test in the future."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "This class is the virtual base class for the user-defined tests."}
{"type": "text", "page_from": 368, "page_to": 368, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=368", "section_title": "uvm_test", "content": "virtual class uvm_test extends uvm_component"}
{"type": "text", "page_from": 369, "page_to": 369, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=369", "section_title": "uvm_test", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 369, "page_to": 369, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=369", "section_title": "uvm_test", "content": "function new ( string name, uvm_component parent )"}
{"type": "text", "page_from": 369, "page_to": 369, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=369", "section_title": "uvm_test", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 370, "page_to": 370, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=370", "section_title": "uvm_env", "content": "The base class for hierarchical containers of other components that together comprise a complete environment. The environment may initially consist of the entire testbench. Later, it can be reused as a sub-environment in even larger system-level environments."}
{"type": "text", "page_from": 370, "page_to": 370, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=370", "section_title": "uvm_env", "content": "The base class for hierarchical containers of other components that together comprise a complete environment."}
{"type": "text", "page_from": 370, "page_to": 370, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=370", "section_title": "uvm_env", "content": "virtual class uvm_env extends uvm_component"}
{"type": "text", "page_from": 370, "page_to": 370, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=370", "section_title": "uvm_env", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 370, "page_to": 370, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=370", "section_title": "uvm_env", "content": "function new ( string name $=$ \"env\", uvm_component parent $=$ null )"}
{"type": "text", "page_from": 370, "page_to": 370, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=370", "section_title": "uvm_env", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 371, "page_to": 371, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=371", "section_title": "uvm_agent", "content": "The uvm_agent virtual class should be used as the base class for the user- defined agents. Deriving from uvm_agent will allow you to distinguish agents from other component types also using its inheritance. Such agents will automatically inherit features that may be added to uvm_agent in the future."}
{"type": "text", "page_from": 371, "page_to": 371, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=371", "section_title": "uvm_agent", "content": "While an agent’s build function, inherited from uvm_component, can be implemented to define any agent topology, an agent typically contains three subcomponents: a driver, sequencer, and monitor. If the agent is active, subtypes should contain all three subcomponents. If the agent is passive, subtypes should contain only the monitor."}
{"type": "text", "page_from": 371, "page_to": 371, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=371", "section_title": "uvm_agent", "content": "The uvm_agent virtual class should be used as the base class for the userdefined agents."}
{"type": "text", "page_from": 371, "page_to": 371, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=371", "section_title": "uvm_agent", "content": "virtual class uvm_agent extends uvm_component"}
{"type": "text", "page_from": 371, "page_to": 371, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=371", "section_title": "uvm_agent", "content": "function new ( string name, uvm_component parent"}
{"type": "text", "page_from": 371, "page_to": 371, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=371", "section_title": "uvm_agent", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 371, "page_to": 371, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=371", "section_title": "uvm_agent", "content": "The int configuration parameter is_active is used to identify whether this agent should be"}
{"type": "text", "page_from": 372, "page_to": 372, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=372", "section_title": "uvm_agent", "content": "acting in active or passive mode. This parameter can be set by doing:"}
{"type": "text", "page_from": 372, "page_to": 372, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=372", "section_title": "uvm_agent", "content": "virtual function uvm_active_passive_enum get_is_active()"}
{"type": "text", "page_from": 372, "page_to": 372, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=372", "section_title": "uvm_agent", "content": "Returns UVM_ACTIVE is the agent is acting as an active agent and UVM_PASSIVE if it is acting as a passive agent. The default implementation is to just return the is_active flag, but the component developer may override this behavior if a more complex algorithm is needed to determine the active/passive nature of the agent."}
{"type": "text", "page_from": 373, "page_to": 373, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=373", "section_title": "uvm_monitor", "content": "This class should be used as the base class for user-defined monitors."}
{"type": "text", "page_from": 373, "page_to": 373, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=373", "section_title": "uvm_monitor", "content": "Deriving from uvm_monitor allows you to distinguish monitors from generic component types inheriting from uvm_component. Such monitors will automatically inherit features that may be added to uvm_monitor in the future."}
{"type": "text", "page_from": 373, "page_to": 373, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=373", "section_title": "uvm_monitor", "content": "This class should be used as the base class for user-defined monitors."}
{"type": "text", "page_from": 373, "page_to": 373, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=373", "section_title": "uvm_monitor", "content": "virtual class uvm_monitor extends uvm_component"}
{"type": "text", "page_from": 373, "page_to": 373, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=373", "section_title": "uvm_monitor", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 373, "page_to": 373, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=373", "section_title": "uvm_monitor", "content": "function new ( string name, uvm_component parent )"}
{"type": "text", "page_from": 373, "page_to": 373, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=373", "section_title": "uvm_monitor", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 374, "page_to": 374, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=374", "section_title": "uvm_scoreboard", "content": "The uvm_scoreboard virtual class should be used as the base class for user-defined scoreboards."}
{"type": "text", "page_from": 374, "page_to": 374, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=374", "section_title": "uvm_scoreboard", "content": "Deriving from uvm_scoreboard will allow you to distinguish scoreboards from other component types inheriting directly from uvm_component. Such scoreboards will automatically inherit and benefit from features that may be added to uvm_scoreboard in the future."}
{"type": "text", "page_from": 374, "page_to": 374, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=374", "section_title": "uvm_scoreboard", "content": "The uvm_scoreboard virtual class should be used as the base class for userdefined scoreboards."}
{"type": "text", "page_from": 374, "page_to": 374, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=374", "section_title": "uvm_scoreboard", "content": "virtual class uvm_scoreboard extends uvm_component"}
{"type": "text", "page_from": 374, "page_to": 374, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=374", "section_title": "uvm_scoreboard", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 375, "page_to": 375, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=375", "section_title": "uvm_driver #(REQ,RSP)", "header_path": ["17", "7"], "chapter": "17", "section": "17.7", "content": "17.7 uvm_driver #(REQ,RSP)"}
{"type": "text", "page_from": 375, "page_to": 375, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=375", "section_title": "uvm_driver", "content": "The base class for drivers that initiate requests for new transactions via a uvm_seq_item_pull_port. The ports are typically connected to the exports of an appropriate sequencer component."}
{"type": "text", "page_from": 375, "page_to": 375, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=375", "section_title": "uvm_driver", "content": "This driver operates in pull mode. Its ports are typically connected to the corresponding exports in a pull sequencer as follows:"}
{"type": "text", "page_from": 375, "page_to": 375, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=375", "section_title": "uvm_driver", "content": "The rsp_port needs connecting only if the driver will use it to write responses to the analysis export in the sequencer."}
{"type": "text", "page_from": 375, "page_to": 375, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=375", "section_title": "uvm_driver", "content": "uvm_driver #(REQ,RSP)"}
{"type": "text", "page_from": 375, "page_to": 375, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=375", "section_title": "uvm_driver", "content": "The base class for drivers that initiate requests for new transactions via a uvm_seq_item_pull_port."}
{"type": "text", "page_from": 375, "page_to": 375, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=375", "section_title": "uvm_driver", "content": "class uvm_driver #( type REQ $=$ uvm_sequence_item, type RSP $=$ REQ extends uvm_component"}
{"type": "text", "page_from": 376, "page_to": 376, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=376", "section_title": "uvm_driver", "content": "Derived driver classes should use this port to request items from the sequencer. They may also use it to send responses back."}
{"type": "text", "page_from": 376, "page_to": 376, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=376", "section_title": "uvm_driver", "content": "This port provides an alternate way of sending responses back to the originating sequencer. Which port to use depends on which export the sequencer provides for connection."}
{"type": "text", "page_from": 376, "page_to": 376, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=376", "section_title": "uvm_driver", "content": "function new ( string name, uvm_component parent )"}
{"type": "text", "page_from": 376, "page_to": 376, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=376", "section_title": "uvm_driver", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver #(REQ,RSP)", "header_path": ["17", "8"], "chapter": "17", "section": "17.8", "content": "17.8 uvm_push_driver #(REQ,RSP)"}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver", "content": "Base class for a driver that passively receives transactions, i.e. does not initiate requests transactions. Also known as push mode. Its ports are typically connected to the corresponding ports in a push sequencer as follows:"}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver", "content": "The rsp_port needs connecting only if the driver will use it to write responses to the analysis export in the sequencer."}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver", "content": "uvm_push_driver #(REQ,RSP)"}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver", "content": "Base class for a driver that passively receives transactions."}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver", "content": "req_export This export provides the blocking put interface whose default implementation produces an error. rsp_port This analysis port is used to send response transactions back to the originating sequencer."}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 377, "page_to": 377, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=377", "section_title": "uvm_push_driver", "content": "This export provides the blocking put interface whose default implementation produces an error. Derived drivers must override put with an appropriate implementation (and not call super.put). Ports connected to this export will supply the driver with transactions."}
{"type": "text", "page_from": 378, "page_to": 378, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=378", "section_title": "uvm_push_driver", "content": "This analysis port is used to send response transactions back to the originating sequencer."}
{"type": "text", "page_from": 378, "page_to": 378, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=378", "section_title": "uvm_push_driver", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus #(T)", "header_path": ["17", "9"], "chapter": "17", "section": "17.9", "content": "17.9 uvm_random_stimulus #(T)"}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "A general purpose unidirectional random stimulus class."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "The uvm_random_stimulus class generates streams of T transactions. These streams may be generated by the randomize method of T, or the randomize method of one of its subclasses. The stream may go indefinitely, until terminated by a call to stop_stimulus_generation, or we may specify the maximum number of transactions to be generated."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "By using inheritance, we can add directed initialization or tidy up after random stimulus generation. Simply extend the class and define the run task, calling super.run() when you want to begin the random stimulus phase of simulation."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "While very useful in its own right, this component can also be used as a template for defining other stimulus generators, or it can be extended to add additional stimulus generation methods and to simplify test writing."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "uvm_random_stimulus #(T)"}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "A general purpose unidirectional random stimulus class."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "class uvm_random_stimulus #( type T $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ uvm_transaction ) extends uvm_component"}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "The blocking_put_port is used to send the generated stimulus to the rest of the testbench."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "new Creates a new instance of a specialization of this class. generate_stimulus Generate up to max_count transactions of type T. stop_stimulus_generation Stops the generation of stimulus."}
{"type": "text", "page_from": 379, "page_to": 379, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=379", "section_title": "uvm_random_stimulus", "content": "The blocking_put_port is used to send the generated stimulus to the rest of the"}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "function new( string name, uvm_component parent )"}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "Creates a new instance of a specialization of this class. Also, displays the random state obtained from a get_randstate call. In subsequent simulations, set_randstate can be called with the same value to reproduce the same sequence of transactions."}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "virtual task generate_stimulus( T t $=$ null, int max_count $\\qquad = \\quad 0$ )"}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "Generate up to max_count transactions of type T. If t is not specified, a default instance of T is allocated and used. If t is specified, that transaction is used when randomizing. It must be a subclass of T."}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "max_count is the maximum number of transactions to be generated. A value of zero indicates no maximum - in this case, generate_stimulus will go on indefinitely unless stopped by some other process"}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "The transactions are cloned before they are sent out over the blocking_put_port"}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "stop_stimulus_generation"}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "virtual function void stop_stimulus_generation"}
{"type": "text", "page_from": 380, "page_to": 380, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=380", "section_title": "uvm_random_stimulus", "content": "Stops the generation of stimulus. If a subclass of this method has forked additional processes, those processes will also need to be stopped in an overridden version of this method"}
{"type": "text", "page_from": 381, "page_to": 381, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=381", "section_title": "uvm_subscriber", "header_path": ["17", "10"], "chapter": "17", "section": "17.10", "content": "17.10 uvm_subscriber"}
{"type": "text", "page_from": 381, "page_to": 381, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=381", "section_title": "uvm_subscriber", "content": "This class provides an analysis export for receiving transactions from a connected analysis export. Making such a connection “subscribes” this component to any transactions emitted by the connected analysis port."}
{"type": "text", "page_from": 381, "page_to": 381, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=381", "section_title": "uvm_subscriber", "content": "Subtypes of this class must define the write method to process the incoming transactions. This class is particularly useful when designing a coverage collector that attaches to a monitor."}
{"type": "text", "page_from": 381, "page_to": 381, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=381", "section_title": "uvm_subscriber", "content": "This class provides an analysis export for receiving transactions from a connected analysis export."}
{"type": "text", "page_from": 381, "page_to": 381, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=381", "section_title": "uvm_subscriber", "content": "virtual class uvm_subscriber #( type T = int ) extends uvm_component"}
{"type": "text", "page_from": 381, "page_to": 381, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=381", "section_title": "uvm_subscriber", "content": "This export provides access to the write method, which derived subscribers must implement."}
{"type": "text", "page_from": 381, "page_to": 381, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=381", "section_title": "uvm_subscriber", "content": "This export provides access to the write method, which derived subscribers must implement."}
{"type": "text", "page_from": 382, "page_to": 382, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=382", "section_title": "uvm_subscriber", "content": "function new ( string name, uvm_component parent )"}
{"type": "text", "page_from": 382, "page_to": 382, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=382", "section_title": "uvm_subscriber", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 382, "page_to": 382, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=382", "section_title": "uvm_subscriber", "content": "pure virtual function void write( T t"}
{"type": "text", "page_from": 382, "page_to": 382, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=382", "section_title": "uvm_subscriber", "content": "A pure virtual method that must be defined in each subclass. Access to this method by outside components should be done via the analysis_export."}
{"type": "text", "page_from": 383, "page_to": 383, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=383", "section_title": "Comparators", "content": "A common function of testbenches is to compare streams of transactions for equivalence. For example, a testbench may compare a stream of transactions from a DUT with expected results."}
{"type": "text", "page_from": 383, "page_to": 383, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=383", "section_title": "Comparators", "content": "The UVM library provides a base class called uvm_in_order_comparator and two derived classes: uvm_in_order_built_in_comparator for comparing streams of built-in types and uvm_in_order_class_comparator for comparing streams of class objects."}
{"type": "text", "page_from": 383, "page_to": 383, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=383", "section_title": "Comparators", "content": "The uvm_algorithmic_comparator also compares two streams of transactions, but the transaction streams might be of different type objects. Thus, this comparator will employ a user-defined transformation function to convert one type to another before performing a comparison."}
{"type": "text", "page_from": 383, "page_to": 383, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=383", "section_title": "Comparators", "content": "A common function of testbenches is to compare streams of transactions for equivalence."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "The following classes define comparators for objects and built-in types."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_comparator #(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "Compares two streams of data objects of the type parameter, T. These transactions may either be classes or built-in types. To be successfully compared, the two streams of data must be in the same order. Apart from that, there are no assumptions made about the relative timing of the two streams of data."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "Built in types (such as ints, bits, logic, and structs) can be compared using the default values for comp_type, convert, and pair_type. For convenience, you can use the subtype, uvm_in_order_built_in_comparator #(T) for built-in types."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "When T is a uvm_object, you can use the convenience subtype uvm_in_order_class_comparator #(T)."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "Comparisons are commutative, meaning it does not matter which data stream is connected to which export, before_export or after_export."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "Comparisons are done in order and as soon as a transaction is received from both streams. Internal fifos are used to buffer incoming transactions on one stream until a transaction to compare arrives on the other stream."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_comparator #(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "Compares two streams of data objects of the type parameter, T."}
{"type": "text", "page_from": 384, "page_to": 384, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=384", "section_title": "uvm_in_order_comparator", "content": "before_export The export to which one stream of data is written."}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "The export to which one stream of data is written. The port must be connected to an analysis port that will provide such data."}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "The export to which the other stream of data is written. The port must be connected to an analysis port that will provide such data."}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "The comparator sends out pairs of transactions across this analysis port. Both matched and unmatched pairs are published via a pair_type objects. Any connected analysis export(s) will receive these transaction pairs."}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "virtual function void flush()"}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "This method sets m_matches and m_mismatches back to zero. The uvm_tlm_fifo::flush takes care of flushing the FIFOs."}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_built_in_comparator #(T)"}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "This class uses the uvm_built_in_\\* comparison, converter, and pair classes. Use this class for built-in types (int, bit, string, etc.)"}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_built_in_comparator #(T)"}
{"type": "text", "page_from": 385, "page_to": 385, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=385", "section_title": "uvm_in_order_comparator", "content": "This class uses the uvm_built_in_\\* comparison, converter, and pair classes."}
{"type": "text", "page_from": 386, "page_to": 386, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=386", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_class_comparator #(T)"}
{"type": "text", "page_from": 386, "page_to": 386, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=386", "section_title": "uvm_in_order_comparator", "content": "This class uses the uvm_class_\\* comparison, converter, and pair classes. Use this class for comparing user-defined objects of type T, which must provide compare() and convert2string() method."}
{"type": "text", "page_from": 386, "page_to": 386, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=386", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_class_comparator #(T)"}
{"type": "text", "page_from": 386, "page_to": 386, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=386", "section_title": "uvm_in_order_comparator", "content": "This class uses the uvm_class_\\* comparison, converter, and pair classes."}
{"type": "text", "page_from": 386, "page_to": 386, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=386", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_comparator#(T,uvm_class_comp#(T),uvm_class_converter#(T),uvm_class_pair#(T,T))"}
{"type": "text", "page_from": 386, "page_to": 386, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=386", "section_title": "uvm_in_order_comparator", "content": "uvm_in_order_class_comparator#(T)"}
{"type": "text", "page_from": 386, "page_to": 386, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=386", "section_title": "uvm_in_order_comparator", "content": "class uvm_in_order_class_comparator #( type T int ) extends uvm_in_order_comparator #( T , uvm_class_comp #( T ) , uvm_class_converter #( T ) , uvm_class_pair #( T, T ) )"}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "Algorithmic Comparator", "header_path": ["18", "2"], "chapter": "18", "section": "18.2", "content": "18.2 Algorithmic Comparator"}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "A common function of testbenches is to compare streams of transactions for equivalence. For example, a testbench may compare a stream of transactions from a DUT with expected results."}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "The UVM library provides a base class called uvm_in_order_comparator #(T,comp_type,convert,pair_type) and two derived classes, which are uvm_in_order_built_in_comparator #(T) for comparing streams of built-in types and uvm_in_order_class_comparator #(T) for comparing streams of class objects."}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "The uvm_algorithmic_comparator also compares two streams of transactions; however, the transaction streams might be of different type objects. This device will use a userwritten transformation function to convert one type to another before performing a comparison."}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "Algorithmic Comparator"}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "A common function of testbenches is to compare streams of transactions for equivalence."}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "uvm_algorithmic_comparator #(BEFORE,AFTER,TRANSFORMER)"}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "Compares two streams of data objects of different types, BEFORE and AFTER."}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "The algorithmic comparator is a wrapper around uvm_in_order_class_comparator #(T). Like the in-order comparator, the algorithmic comparator compares two streams of transactions, the BEFORE stream and the AFTER stream. It is often the case when two streams of transactions need to be compared that the two streams are in different forms. That is, the type of the BEFORE transaction stream is different than the type of the AFTER transaction stream."}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "The uvm_algorithmic_comparator’s TRANSFORMER type parameter specifies the class responsible for converting transactions of type BEFORE into those of type AFTER. This transformer class must provide a transform() method with the following prototype:"}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "Matches and mismatches are reported in terms of the AFTER transactions. For more information, see the uvm_in_order_comparator #(T,comp_type,convert,pair_type) class."}
{"type": "text", "page_from": 387, "page_to": 387, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=387", "section_title": "uvm_algorithmic_comparator", "content": "uvm_algorithmic_comparator #(BEFORE,AFTER,TRANSFORMER)"}
{"type": "text", "page_from": 388, "page_to": 388, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=388", "section_title": "uvm_algorithmic_comparator", "content": "Compares two streams of data objects of different types, BEFORE and AFTER."}
{"type": "text", "page_from": 388, "page_to": 388, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=388", "section_title": "uvm_algorithmic_comparator", "content": "class uvm_algorithmic_comparator #( type BEFORE = int, type AFTER $=$ int, type TRANSFORMER $=$ int extends uvm_component"}
{"type": "text", "page_from": 388, "page_to": 388, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=388", "section_title": "uvm_algorithmic_comparator", "content": "before_export The export to which a data stream of type BEFORE is sent via a connected analysis port. after_export The export to which a data stream of type AFTER is sent via a connected analysis port."}
{"type": "text", "page_from": 388, "page_to": 388, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=388", "section_title": "uvm_algorithmic_comparator", "content": "The export to which a data stream of type BEFORE is sent via a connected analysis port. Publishers (monitors) can send in an ordered stream of transactions against which the transformed BEFORE transactions will (be compared."}
{"type": "text", "page_from": 388, "page_to": 388, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=388", "section_title": "uvm_algorithmic_comparator", "content": "The export to which a data stream of type AFTER is sent via a connected analysis port. Publishers (monitors) can send in an ordered stream of transactions to be transformed and compared to the AFTER transactions."}
{"type": "text", "page_from": 388, "page_to": 388, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=388", "section_title": "uvm_algorithmic_comparator", "content": "Creates an instance of a specialization of this class. In addition to the standard"}
{"type": "text", "page_from": 389, "page_to": 389, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=389", "section_title": "uvm_algorithmic_comparator", "content": "uvm_component constructor arguments, name and parent, the constructor takes a handle to a transformer object, which must already be allocated (handles can’t be null) and must implement the transform() method."}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair classes", "header_path": ["18", "3"], "chapter": "18", "section": "18.3", "content": "18.3 uvm_pair classes"}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair", "content": "This section defines container classes for handling value pairs."}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair", "content": "uvm_class_pair #(T1,T2)"}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair", "content": "Container holding handles to two objects whose types are specified by the type parameters, T1 and T2."}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair", "content": "uvm_class_pair #(T1,T2)"}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair", "content": "Container holding handles to two objects whose types are specified by the type parameters, T1 and T2."}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair", "content": "T1 first The handle to the first object in the pair T2 second The handle to the second object in the pair"}
{"type": "text", "page_from": 390, "page_to": 390, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=390", "section_title": "uvm_pair", "content": "Creates an instance that holds a handle to two objects."}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "The handle to the first object in the pair"}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "The handle to the second object in the pair"}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "Creates an instance that holds a handle to two objects. The optional name argument gives a name to the new pair object."}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "uvm_built_in_pair #(T1,T2)"}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "Container holding two variables of built-in types (int, string, etc.). The types are specified by the type parameters, T1 and T2."}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "uvm_built_in_pair #(T1,T2)"}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "Container holding two variables of built-in types (int, string, etc.)"}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "T1 first The first value in the pair T2 second The second value in the pair"}
{"type": "text", "page_from": 391, "page_to": 391, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=391", "section_title": "uvm_pair", "content": "Creates an instance that holds two built-in type values."}
{"type": "text", "page_from": 392, "page_to": 392, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=392", "section_title": "uvm_pair", "content": "The first value in the pair"}
{"type": "text", "page_from": 392, "page_to": 392, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=392", "section_title": "uvm_pair", "content": "The second value in the pair"}
{"type": "text", "page_from": 392, "page_to": 392, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=392", "section_title": "uvm_pair", "content": "function new (string name）"}
{"type": "text", "page_from": 392, "page_to": 392, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=392", "section_title": "uvm_pair", "content": "Creates an instance that holds two built-in type values. The optional name argument gives a name to the new pair object."}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "Policy classes are used to implement polymorphic operations that differ between built-in types and class-based types. Generic components can then be built that work with either classes or built-in types, depending on what policy class is used."}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "uvm_built_in_comp #(T)"}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "This policy class is used to compare built-in types."}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "Provides a comp method that compares the built-in type, ${ \\sf T } ,$ for which the $= =$ operator is defined."}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "uvm_built_in_comp #(T)"}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "This policy class is used to compare built-in types."}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "class uvm_built_in_comp #( type T = int )"}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "uvm_built_in_converter #(T)"}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "This policy class is used to convert built-in types to strings."}
{"type": "text", "page_from": 393, "page_to": 393, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=393", "section_title": "uvm_policies", "content": "Provides a convert2string method that converts the built-in type, ${ \\sf T } ,$ to a string using the %p format specifier."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "uvm_built_in_converter #(T)"}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "This policy class is used to convert built-in types to strings."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "class uvm_built_in_converter #( type T = int )"}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "uvm_built_in_clone #(T)"}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "This policy class is used to clone built-in types via the $=$ operator."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "Provides a clone method that returns a copy of the built-in type, T."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "uvm_built_in_clone #(T)"}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "This policy class is used to clone built-in types via the $=$ operator."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "class uvm_built_in_clone #( type T = int )"}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "This policy class is used to compare two objects of the same type."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "Provides a comp method that compares two objects of type T. The class T must provide the method “function bit compare(T rhs)”, similar to the uvm_object::compare method."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "This policy class is used to compare two objects of the same type."}
{"type": "text", "page_from": 394, "page_to": 394, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=394", "section_title": "uvm_policies", "content": "class uvm_class_comp #( type T = int"}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "uvm_class_converter #(T)"}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "This policy class is used to convert a class object to a string."}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "Provides a convert2string method that converts an instance of type $\\mathsf { T }$ to a string. The class T must provide the method “function string convert2string()”, similar to the uvm_object::convert2string method."}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "uvm_class_converter #(T)"}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "This policy class is used to convert a class object to a string."}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "class uvm_class_converter #( type T = int )"}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "uvm_class_clone #(T)"}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "This policy class is used to clone class objects."}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "Provides a clone method that returns a copy of the built-in type, T. The class T must implement the clone method, to which this class delegates the operation. If T is derived from uvm_object, then T must instead implement uvm_object::do_copy, either directly or indirectly through use of the \\`uvm_field macros."}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "uvm_class_clone #(T)"}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "This policy class is used to clone class objects."}
{"type": "text", "page_from": 395, "page_to": 395, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=395", "section_title": "uvm_policies", "content": "class uvm_class_clone #( type T = int"}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "19. Sequencer Classes"}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "The sequencer serves as an arbiter for controlling transaction flow from multiple stimulus generators. More specifically, the sequencer controls the flow of uvm_sequence_itembased transactions generated by one or more uvm_sequence #(REQ,RSP)-based sequences."}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "There are two sequencer variants available."}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "uvm_sequencer #(REQ,RSP) - Requests for new sequence items are initiated by the driver. Upon such requests, the sequencer selects a sequence from a list of available sequences to produce and deliver the next item to execute. This sequencer is typically connected to a user-extension of uvm_driver #(REQ,RSP). uvm_push_sequencer #(REQ,RSP) - Sequence items (from the currently running sequences) are pushed by the sequencer to the driver, which blocks item flow when it is not ready to accept new transactions. This sequencer is typically connected to a user-extension of uvm_push_driver #(REQ,RSP)."}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "Sequencer-driver communication follows a pull or push semantic, depending on which sequencer type is used. However, sequence-sequencer communication is always initiated by the user-defined sequence, i.e. follows a push semantic."}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "See Sequence Classes for an overview on sequences and sequence items."}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "As with all UVM components, the sequencers and drivers described above use TLM Interfaces to communicate transactions."}
{"type": "text", "page_from": 396, "page_to": 396, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=396", "section_title": "Sequencers", "content": "The uvm_sequencer #(REQ,RSP) and uvm_driver #(REQ,RSP) pair also uses a sequence item pull port to achieve the special execution semantic needed by the sequencer-driver pair."}
{"type": "text", "page_from": 397, "page_to": 397, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=397", "section_title": "Sequencers", "content": "Sequencers and drivers use a seq_item_port specifically supports sequencer-driver communication. Connections to these ports are made in the same fashion as the TLM ports."}
{"type": "text", "page_from": 397, "page_to": 397, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=397", "section_title": "Sequencers", "content": "The sequencer serves as an arbiter for controlling transaction flow from multiple stimulus generators."}
{"type": "text", "page_from": 398, "page_to": 398, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=398", "section_title": "uvm_sequencer_base", "content": "Controls the flow of sequences, which generate the stimulus (sequence item transactions) that is passed on to drivers for execution."}
{"type": "text", "page_from": 398, "page_to": 398, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=398", "section_title": "uvm_sequencer_base", "content": "Controls the flow of sequences, which generate the stimulus (sequence item transactions) that is passed on to drivers for execution."}
{"type": "text", "page_from": 398, "page_to": 398, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=398", "section_title": "uvm_sequencer_base", "content": "class uvm_sequencer_base extends uvm_component"}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "Returns 1 if the child sequence is a child of the parent sequence, 0 otherwise."}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "user_priority_arbitration"}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "virtual function integer user_priority_arbitration( integer avail_sequences[\\$]"}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "When the sequencer arbitration mode is set to UVM_SEQ_ARB_USER (via the set_arbitration method), the sequencer will call this function each time that it needs to arbitrate among sequences."}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "Derived sequencers may override this method to perform a custom arbitration policy. The override must return one of the entries from the avail_sequences queue, which are indexes into an internal queue, arb_sequence_q."}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "The default implementation behaves like UVM_SEQ_ARB_FIFO, which returns the entry at avail_sequences[0]."}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "virtual task execute_item( uvm_sequence_item item"}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "Executes the given transaction item directly on this sequencer. A temporary parent sequence is automatically created for the item. There is no capability to retrieve responses. If the driver returns responses, they will accumulate in the sequencer, eventually causing response overflow unless uvm_sequence_base::set_response_queue_error_report_disabled is called."}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "start_phase_sequence"}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "virtual function void start_phase_sequence( uvm_phase phase"}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "Start the default sequence for this phase, if any. The default sequence is configured via resources using either a sequence instance or sequence type (object wrapper). If both are used, the sequence instance takes precedence. When attempting to override a previous default sequence setting, you must override both the instance and type (wrapper) resources, else your override may not take effect."}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "When setting the resource using set, the 1st argument specifies the context pointer, usually this for components or null when executed from outside the component hierarchy (i.e. in module). The 2nd argument is the instance string, which is a path name to the target sequencer, relative to the context pointer. The path must include the name of the phase with a “_phase” suffix. The 3rd argument is the resource name, which is “default_sequence”. The 4th argument is either an object wrapper for the sequence type, or an instance of a sequence."}
{"type": "text", "page_from": 400, "page_to": 400, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=400", "section_title": "uvm_sequencer_base", "content": "Configuration by instances allows pre-initialization, setting rand_mode, use of inline constraints, etc."}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "myseq_t myseq $=$ new(\"myseq\"); myseq.randomize() with { ... };uvm_config_db #(uvm_sequence_base)::set(null, \"top.agent.myseqr.main_phase\", \"default_sequence\", myseq);"}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "Configuration by type is shorter and can be substituted via the factory."}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "uvm_config_db #(uvm_object_wrapper)::set(null, \"top.agent.myseqr.main_phase\", \"default_sequence\", myseq_type::type_id::get());"}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "The uvm_resource_db can similarly be used."}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "myseq_t myseq $=$ new(\"myseq\"); myseq.randomize() with { ... }; uvm_resource_db #(uvm_sequence_base)::set({get_full_name(), \".myseqr.main_phase\", \"default_sequence\", myseq, this);"}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "virtual function void stop_phase_sequence(uvm_phase phase ）"}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "Stop the default sequence for this phase, if any exists, and it is still executing."}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "This task issues a request for the specified sequence. If item_priority is not specified, then the current sequence priority will be used by the arbiter. If a lock_request is made, then the sequencer will issue a lock immediately before granting the sequence. (Note that the lock may be granted without the sequence being granted if is_relevant is not asserted)."}
{"type": "text", "page_from": 401, "page_to": 401, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=401", "section_title": "uvm_sequencer_base", "content": "When this method returns, the sequencer has granted the sequence, and the sequence must call send_request without inserting any simulation delay other than delta cycles. The driver is currently waiting for the next item to be sent via the send_request call."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "virtual task wait_for_item_done( uvm_sequence_base sequence_ptr, int transaction_id )"}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "A sequence may optionally call wait_for_item_done. This task will block until the driver calls item_done() or put() on a transaction issued by the specified sequence. If no transaction_id parameter is specified, then the call will return the next time that the driver calls item_done() or put(). If a specific transaction_id is specified, then the call will only return when the driver indicates that it has completed that specific item."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "Note that if a specific transaction_id has been specified, and the driver has already issued an item_done or put for that transaction, then the call will hang waiting for that specific transaction_id."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "function bit is_blocked( uvm_sequence_base sequence_ptr"}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "Returns 1 if the sequence referred to by sequence_ptr is currently locked out of the sequencer. It will return 0 if the sequence is currently allowed to issue operations."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "Note that even when a sequence is not blocked, it is possible for another sequence to issue a lock before this sequence is able to issue a request or lock."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "function bit has_lock( uvm_sequence_base sequence_ptr"}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "Returns 1 if the sequence referred to in the parameter currently has a lock on this sequencer, 0 otherwise."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "Note that even if this sequence has a lock, a child sequence may also have a lock, in which case the sequence is still blocked from issuing operations on the sequencer"}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "Requests a lock for the sequence specified by sequence_ptr."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "A lock request will be arbitrated the same as any other request. A lock is granted after all earlier requests are completed and no other locks or grabs are blocking this sequence."}
{"type": "text", "page_from": 402, "page_to": 402, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=402", "section_title": "uvm_sequencer_base", "content": "The lock call will return when the lock has been granted."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "Requests a lock for the sequence specified by sequence_ptr."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "A grab request is put in front of the arbitration queue. It will be arbitrated before any other requests. A grab is granted when no other grabs or locks are blocking this sequence."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "The grab call will return when the grab has been granted."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "virtual function void unlock( uvm_sequence_base sequence_ptr"}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "Removes any locks and grabs obtained by the specified sequence_ptr."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "virtual function void ungrab( uvm_sequence_base sequence_ptr"}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "Removes any locks and grabs obtained by the specified sequence_ptr."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "virtual function void stop_sequences()"}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "Tells the sequencer to kill all sequences and child sequences currently operating on the sequencer, and remove all requests, locks and responses that are currently queued. This essentially resets the sequencer to an idle state."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "virtual function bit is_grabbed()"}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "Returns 1 if any sequence currently has a lock or grab on this sequencer, 0 otherwise."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "virtual function uvm_sequence_base current_grabber()"}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "Returns a reference to the sequence that currently has a lock or grab on the sequence. If multiple hierarchical sequences have a lock, it returns the child that is currently allowed to perform operations on the sequencer."}
{"type": "text", "page_from": 403, "page_to": 403, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=403", "section_title": "uvm_sequencer_base", "content": "virtual function bit has_do_available()"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Returns 1 if any sequence running on this sequencer is ready to supply a transaction, 0 otherwise. A sequence is ready if it is not blocked (via grab or lock and is_relevant returns 1."}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "function void set_arbitration( UVM_SEQ_ARB_TYPE val )"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Specifies the arbitration mode for the sequencer. It is one of"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Requests are granted in FIFO order (default)"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Requests are granted randomly by weight"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "UVM_SEQ_ARB_WEIGHTED UVM_SEQ_ARB_RANDOM UVM_SEQ_ARB_STRICT_FIFO"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Requests are granted randomly"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Requests at highest priority granted in FIFO order"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "UVM_SEQ_ARB_STRICT_RANDOM"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Requests at highest priority granted in randomly"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Arbitration is delegated to the user-defined function, user_priority_arbitration. That function will specify the next sequence to grant."}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "The default user function specifies FIFO order."}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "function UVM_SEQ_ARB_TYPE get_arbitration()"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Return the current arbitration mode set for this sequencer. See set_arbitration for a list of possible modes."}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "virtual task wait_for_sequences()"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Waits for a sequence to have a new item available. Uses uvm_wait_for_nba_region to give a sequence as much time as possible to deliver an item before advancing time."}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "virtual function void send_request( uvm_sequence_base sequence_ptr, uvm_sequence_item t, bit rerandomize = 0 )"}
{"type": "text", "page_from": 404, "page_to": 404, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=404", "section_title": "uvm_sequencer_base", "content": "Derived classes implement this function to send a request item to the sequencer, which will forward it to the driver. If the rerandomize bit is set, the item will be randomized before being sent to the driver."}
{"type": "text", "page_from": 405, "page_to": 405, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=405", "section_title": "uvm_sequencer_base", "content": "This function may only be called after a wait_for_grant call."}
{"type": "text", "page_from": 405, "page_to": 405, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=405", "section_title": "uvm_sequencer_base", "content": "set_max_zero_time_wait_relevant_count"}
{"type": "text", "page_from": 405, "page_to": 405, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=405", "section_title": "uvm_sequencer_base", "content": "Can be called at any time to change the maximum number of times wait_for_relevant() can be called by the sequencer in zero time before an error is declared. The default maximum is 10."}
{"type": "text", "page_from": 406, "page_to": 406, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=406", "section_title": "uvm_sequencer_param_base #(REQ,RSP)", "header_path": ["19", "2"], "chapter": "19", "section": "19.2", "content": "19.2 uvm_sequencer_param_base #(REQ,RSP)"}
{"type": "text", "page_from": 406, "page_to": 406, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=406", "section_title": "uvm_sequencer_param_base", "content": "Extends uvm_sequencer_base with an API depending on specific request (REQ) and response (RSP) types."}
{"type": "text", "page_from": 406, "page_to": 406, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=406", "section_title": "uvm_sequencer_param_base", "content": "uvm_sequencer_param_base #(REQ,RSP)"}
{"type": "text", "page_from": 406, "page_to": 406, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=406", "section_title": "uvm_sequencer_param_base", "content": "Extends uvm_sequencer_base with an API depending on specific request (REQ) and response (RSP) types."}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "function new ( string name, uvm_component parent )"}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "Creates and initializes an instance of this class using the normal constructor arguments for uvm_component: name is the name of the instance, and parent is the handle to the hierarchical parent, if any."}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "virtual function void send_request( uvm_sequence_base sequence_ptr, uvm_sequence_item t, bit rerandomize $\\qquad = \\quad 0$ )"}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "The send_request function may only be called after a wait_for_grant call. This call will send the request item, $\\mathrm { t , }$ to the sequencer pointed to by sequence_ptr. The sequencer will forward it to the driver. If rerandomize is set, the item will be randomized before being sent to the driver."}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "function REQ get_current_item()"}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "Returns the request_item currently being executed by the sequencer. If the sequencer is not currently executing an item, this method will return null."}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "The sequencer is executing an item from the time that get_next_item or peek is called until the time that get or item_done is called."}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "Note that a driver that only calls get() will never show a current item, since the item is completed at the same time as it is requested."}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "function int get_num_reqs_sent()"}
{"type": "text", "page_from": 407, "page_to": 407, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=407", "section_title": "uvm_sequencer_param_base", "content": "Returns the number of requests that have been sent by this sequencer."}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "function int unsigned get_num_last_reqs()"}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "Returns the size of the last requests buffer, as set by set_num_last_reqs."}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "function REQ last_req( int unsigned $\\mathrm { ~ n ~ } ^ { - } = \\mathrm { ~ \\bar { ~ } { ~ 0 ~ } ~ }$ )"}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "Returns the last request item by default. If n is not 0, then it will get the nï¿½th before last request item. If n is greater than the last request buffer size, the function will return null."}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "Drivers or monitors can connect to this port to send responses to the sequencer. Alternatively, a driver can send responses via its seq_item_port."}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "The rsp_port in the driver and/or monitor must be connected to the rsp_export in this sequencer in order to send responses through the response analysis port."}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "get_num_rsps_received"}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "function int get_num_rsps_received()"}
{"type": "text", "page_from": 408, "page_to": 408, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=408", "section_title": "uvm_sequencer_param_base", "content": "Returns the number of responses received thus far by this sequencer."}
{"type": "text", "page_from": 409, "page_to": 409, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=409", "section_title": "uvm_sequencer_param_base", "content": "Returns the max size of the last responses buffer, as set by set_num_last_rsps."}
{"type": "text", "page_from": 409, "page_to": 409, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=409", "section_title": "uvm_sequencer_param_base", "content": "function RSP last_rsp( int unsigned $\\mathrm { ~ n ~ } ^ { - } = \\mathrm { ~ 0 ~ }$ )"}
{"type": "text", "page_from": 409, "page_to": 409, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=409", "section_title": "uvm_sequencer_param_base", "content": "Returns the last response item by default. If n is not 0, then it will get the nth-beforelast response item. If n is greater than the last response buffer size, the function will return null."}
{"type": "text", "page_from": 410, "page_to": 410, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=410", "section_title": "uvm_sequencer", "content": "uvm_sequencer #(REQ,RSP)"}
{"type": "text", "page_from": 410, "page_to": 410, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=410", "section_title": "uvm_sequencer", "content": "function new string ( name, uvm_component parent $=$ null )"}
{"type": "text", "page_from": 410, "page_to": 410, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=410", "section_title": "uvm_sequencer", "content": "Standard component constructor that creates an instance of this class using the given name and parent, if any."}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "virtual function void stop_sequences()"}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "Tells the sequencer to kill all sequences and child sequences currently operating on the sequencer, and remove all requests, locks and responses that are currently queued. This essentially resets the sequencer to an idle state."}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "Seq UeNcer INTer FAce"}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "This is an interface for communicating with sequencers."}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "The interface is defined as"}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "See uvm_sqr_if_base #(REQ,RSP) for information about this interface."}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "uvm_seq_item_pull_imp #( REQ, RSP, this_type ) seq_item_export"}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "This export provides access to this sequencer’s implementation of the sequencer interface."}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "virtual task get_next_item output REQ t"}
{"type": "text", "page_from": 411, "page_to": 411, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=411", "section_title": "uvm_sequencer", "content": "Retrieves the next available item from a sequence."}
{"type": "text", "page_from": 412, "page_to": 412, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=412", "section_title": "uvm_sequencer", "content": "virtual function void item_done ( RSP item $=$ null"}
{"type": "text", "page_from": 412, "page_to": 412, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=412", "section_title": "uvm_sequencer", "content": "Indicates that the request is completed."}
{"type": "text", "page_from": 412, "page_to": 412, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=412", "section_title": "uvm_sequencer", "content": "Sends a response back to the sequence that issued the request."}
{"type": "text", "page_from": 412, "page_to": 412, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=412", "section_title": "uvm_sequencer", "content": "Retrieves the next available item from a sequence."}
{"type": "text", "page_from": 412, "page_to": 412, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=412", "section_title": "uvm_sequencer", "content": "Returns the current request item if one is in the FIFO."}
{"type": "text", "page_from": 412, "page_to": 412, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=412", "section_title": "uvm_sequencer", "content": "Waits for a sequence to have a new item available."}
{"type": "text", "page_from": 412, "page_to": 412, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=412", "section_title": "uvm_sequencer", "content": "Returns 1 if any sequence running on this sequencer is ready to supply a transaction, 0 otherwise."}
{"type": "text", "page_from": 413, "page_to": 413, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=413", "section_title": "uvm_push_sequencer", "content": "uvm_push_sequencer #(REQ,RSP)"}
{"type": "text", "page_from": 413, "page_to": 413, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=413", "section_title": "uvm_push_sequencer", "content": "class uvm_push_sequencer #( type REQ $=$ uvm_sequence_item, RSP $=$ REQ ) extends uvm_sequencer_param_base #(REQ, RSP)"}
{"type": "text", "page_from": 413, "page_to": 413, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=413", "section_title": "uvm_push_sequencer", "content": "t The push sequencer requires access to a blocking put interface."}
{"type": "text", "page_from": 413, "page_to": 413, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=413", "section_title": "uvm_push_sequencer", "content": "new Standard component constructor that creates an instance of this class using the given name and parent, if any. run_phase The push sequencer continuously selects from its list of available sequences and sends the next item from the selected sequence out its req_port using req_port.put(item)."}
{"type": "text", "page_from": 413, "page_to": 413, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=413", "section_title": "uvm_push_sequencer", "content": "The push sequencer requires access to a blocking put interface. A continuous stream of sequence items are sent out this port, based on the list of available sequences loaded into this sequencer."}
{"type": "text", "page_from": 413, "page_to": 413, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=413", "section_title": "uvm_push_sequencer", "content": "function new ( string name, uvm_component parent $=$ null"}
{"type": "text", "page_from": 413, "page_to": 413, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=413", "section_title": "uvm_push_sequencer", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 414, "page_to": 414, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=414", "section_title": "uvm_push_sequencer", "content": "Standard component constructor that creates an instance of this class using the given name and parent, if any."}
{"type": "text", "page_from": 414, "page_to": 414, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=414", "section_title": "uvm_push_sequencer", "content": "The push sequencer continuously selects from its list of available sequences and sends the next item from the selected sequence out its req_port using req_port.put(item). Typically, the req_port would be connected to the req_export on an instance of a uvm_push_driver #(REQ,RSP), which would be responsible for executing the item."}
{"type": "text", "page_from": 415, "page_to": 415, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=415", "section_title": "Sequences", "content": "20. Sequence Classes"}
{"type": "text", "page_from": 415, "page_to": 415, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=415", "section_title": "Sequences", "content": "Sequences encapsulate user-defined procedures that generate multiple uvm_sequence_item-based transactions. Such sequences can be reused, extended, randomized, and combined sequentially and hierarchically in interesting ways to produce realistic stimulus to your DUT."}
{"type": "text", "page_from": 415, "page_to": 415, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=415", "section_title": "Sequences", "content": "With uvm_sequence objects, users can encapsulate DUT initialization code, bus-based stress tests, network protocol stacks-- anything procedural-- then have them all execute in specific or random order to more quickly reach corner cases and coverage goals."}
{"type": "text", "page_from": 415, "page_to": 415, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=415", "section_title": "Sequences", "content": "The UVM sequence item and sequence class hierarchy is shown below."}
{"type": "text", "page_from": 415, "page_to": 415, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=415", "section_title": "Sequences", "content": "uvm_sequence_item - The uvm_sequence_item is the base class for user-defined transactions that leverage the stimulus generation and control capabilities of the sequence-sequencer mechanism."}
{"type": "text", "page_from": 415, "page_to": 415, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=415", "section_title": "Sequences", "content": "uvm_sequence #(REQ,RSP) - The uvm_sequence extends uvm_sequence_item to add the ability to generate streams of uvm_sequence_items, either directly or by recursively executing other uvm_sequences."}
{"type": "text", "page_from": 415, "page_to": 415, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=415", "section_title": "Sequences", "content": "Sequences encapsulate user-defined procedures that generate multiple uvm_sequence_item-based transactions."}
{"type": "text", "page_from": 416, "page_to": 416, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=416", "section_title": "uvm_sequence_item", "content": "The base class for user-defined sequence items and also the base class for the uvm_sequence class. The uvm_sequence_item class provides the basic functionality for objects, both sequence items and sequences, to operate in the sequence mechanism."}
{"type": "text", "page_from": 416, "page_to": 416, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=416", "section_title": "uvm_sequence_item", "content": "The base class for user-defined sequence items and also the base class for the uvm_sequence class."}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "The constructor method for uvm_sequence_item."}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "function int get_sequence_id()"}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "Get_sequence_id is an internal method that is not intended for user code. The sequence_id is not a simple integer. The get_transaction_id is meant for users to identify specific transactions."}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "These methods allow access to the sequence_item sequence and transaction IDs. get_transaction_id and set_transaction_id are methods on the uvm_transaction base_class. These IDs are used to identify sequences to the sequencer, to route responses back to the sequence that issued a request, and to uniquely identify transactions."}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "The sequence_id is assigned automatically by a sequencer when a sequence initiates communication through any sequencer calls (i.e. \\`uvm_do_\\*, wait_for_grant). A sequence_id will remain unique for this sequence until it ends or it is killed. However, a single sequence may have multiple valid sequence ids at any point in time. Should a sequence start again after it has ended, it will be given a new unique sequence_id."}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "The transaction_id is assigned automatically by the sequence each time a transaction is sent to the sequencer with the transaction_id in its default (-1) value. If the user sets the transaction_id to any non-default value, that value will be maintained."}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "Responses are routed back to this sequences based on sequence_id. The sequence may use the transaction_id to correlate responses with their requests."}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "function void set_item_context( uvm_sequence_base parent_seq, uvm_sequencer_base sequencer $=$ null )"}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "Set the sequence and sequencer execution context for a sequence item"}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "set_use_sequence_info"}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "function void set_use_sequence_info( bit value"}
{"type": "text", "page_from": 417, "page_to": 417, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=417", "section_title": "uvm_sequence_item", "content": "get_use_sequence_info"}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "function bit get_use_sequence_info()"}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "These methods are used to set and get the status of the use_sequence_info bit. Use_sequence_info controls whether the sequence information (sequencer, parent_sequence, sequence_id, etc.) is printed, copied, or recorded. When use_sequence_info is the default value of 0, then the sequence information is not used. When use_sequence_info is set to 1, the sequence information will be used in printing and copying."}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "function void set_id_info( uvm_sequence_item item"}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "Copies the sequence_id and transaction_id from the referenced item into the calling item. This routine should always be used by drivers to initialize responses for future compatibility."}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "virtual function void set_sequencer( uvm_sequencer_base sequencer"}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "Sets the default sequencer for the sequence to sequencer. It will take effect immediately, so it should not be called while the sequence is actively communicating with the sequencer."}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "function uvm_sequencer_base get_sequencer()"}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "Returns a reference to the default sequencer used by this sequence."}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "function void set_parent_sequence( uvm_sequence_base parent"}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "Sets the parent sequence of this sequence_item. This is used to identify the source sequence of a sequence_item."}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "function uvm_sequence_base get_parent_sequence()"}
{"type": "text", "page_from": 418, "page_to": 418, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=418", "section_title": "uvm_sequence_item", "content": "Returns a reference to the parent sequence of any sequence on which this method was called. If this is a parent sequence, the method returns null."}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "The depth of any sequence is calculated automatically. However, the user may use set_depth to specify the depth of a particular sequence. This method will override the automatically calculated depth, even if it is incorrect."}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "function int get_depth()"}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "Returns the depth of a sequence from its parent. A parent sequence will have a depth of 1, its child will have a depth of 2, and its grandchild will have a depth of 3."}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "virtual function bit is_item()"}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "This function may be called on any sequence_item or sequence. It will return 1 for items and 0 for sequences (which derive from this class)."}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "get_root_sequence_name"}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "function string get_root_sequence_name()"}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "Provides the name of the root sequence (the top-most parent sequence)."}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "function uvm_sequence_base get_root_sequence()"}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "Provides a reference to the root sequence (the top-most parent sequence)."}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "function string get_sequence_path()"}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "Provides a string of names of each sequence in the full hierarchical path. A “.” is used as the separator between each sequence."}
{"type": "text", "page_from": 419, "page_to": 419, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=419", "section_title": "uvm_sequence_item", "content": "Sequence items and sequences will use the sequencer which they are associated with for reporting messages. If no sequencer has been set for the item/sequence using set_sequencer or indirectly via uvm_sequence_base::start_item or uvm_sequence_base::start), then the global reporter will be used."}
{"type": "text", "page_from": 420, "page_to": 420, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=420", "section_title": "uvm_sequence_item", "content": "virtual function void uvm_report_info( string id, string message, int verbosity UVM_MEDIUM, string filename int line 0, string context_name \"\", bit report_enabled_checked = 0"}
{"type": "text", "page_from": 420, "page_to": 420, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=420", "section_title": "uvm_sequence_item", "content": "virtual function void uvm_report_error( string id, string message, int verbosity UVM_LOW, string filename int line = 0, , string context_name , bit report_enabled_checked = 0 )"}
{"type": "text", "page_from": 420, "page_to": 420, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=420", "section_title": "uvm_sequence_item", "content": "virtual function void uvm_report_fatal( string id, string message, int verbosity UVM_NONE, string filename int line 0, , string context_name , bit report_enabled_checked = 0 )"}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "The uvm_sequence_base class provides the interfaces needed to create streams of sequence items and/or other sequences."}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "A sequence is executed by calling its start method, either directly or invocation of any of the \\`uvm_do_\\* macros."}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "Executing sequences via start"}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "A sequence’s start method has a parent_sequence argument that controls whether pre_do, mid_do, and post_do are called in the parent sequence. It also has a call_pre_post argument that controls whether its pre_body and post_body methods are called. In all cases, its pre_start and post_start methods are always called."}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "When start is called directly, you can provide the appropriate arguments according to your application."}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "The sequence execution flow looks like this"}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "The following methods are called, in order"}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "Executing sub-sequences via \\`uvm_do macros"}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "A sequence can also be indirectly started as a child in the body of a parent sequence. The child sequence’s start method is called indirectly by invoking any of the \\`uvm_do macros. In these cases, start is called with call_pre_post set to 0, preventing the started sequence’s pre_body and post_body methods from being called. During execution of the child sequence, the parent’s pre_do, mid_do, and post_do methods are called."}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "The sub-sequence execution flow looks like"}
{"type": "text", "page_from": 422, "page_to": 422, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=422", "section_title": "uvm_sequence_base", "content": "The following methods are called, in order"}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "Remember, it is the parent sequence’s pre|mid|post_do that are called, not the sequence being executed."}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "Executing sequence items via start_item/finish_item or \\`uvm_do macros"}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "Items are started in the body of a parent sequence via calls to start_item/finish_item or invocations of any of the \\`uvm_do macros. The pre_do, mid_do, and post_do methods of the parent sequence will be called as the item is executed."}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "The sequence-item execution flow looks like"}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "The following methods are called, in order"}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "Attempting to execute a sequence via start_item/finish_item will produce a run-time error."}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "The uvm_sequence_base class provides the interfaces needed to create streams of sequence items and/or other sequences."}
{"type": "text", "page_from": 423, "page_to": 423, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=423", "section_title": "uvm_sequence_base", "content": "class uvm_sequence_base extends uvm_sequence_item"}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "bit do_not_randomize"}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "If set, prevents the sequence from being randomized before being executed by the \\`uvm_ ${ \\sf d o } ^ { * } ( \\ u )$ and \\`uvm_rand_send\\*() macros, or as a default sequence."}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "function new ( string name $=$ \"uvm_sequence\""}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "The constructor for uvm_sequence_base."}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "virtual function bit is_item()"}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "Returns 1 on items and 0 on sequences. As this object is a sequence, is_item will always return 0."}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "function uvm_sequence_state_enum get_sequence_state()"}
{"type": "text", "page_from": 426, "page_to": 426, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=426", "section_title": "uvm_sequence_base", "content": "Returns the sequence state as an enumerated value. Can use to wait on the sequence reaching or changing from one or more states."}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "wait_for_sequence_state"}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "task wait_for_sequence_state( int unsigned state_mask )"}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "Waits until the sequence reaches one of the given state. If the sequence is already in one of the state, this method returns immediately."}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "function integer get_tr_handle()"}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "Returns the integral recording transaction handle for this sequence. Can be used to associate sub-sequences and sequence items as child transactions when calling uvm_component::begin_child_tr."}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "Executes this sequence, returning when the sequence has completed."}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "The sequencer argument specifies the sequencer on which to run this sequence. The sequencer must be compatible with the sequence."}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "If parent_sequence is null, then this sequence is a root parent, otherwise it is a child of parent_sequence. The parent_sequence’s pre_do, mid_do, and post_do methods will be called during the execution of this sequence."}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "By default, the priority of a sequence is the priority of its parent sequence. If it is a root sequence, its default priority is 100. A different priority may be specified by this_priority. Higher numbers indicate higher priority."}
{"type": "text", "page_from": 427, "page_to": 427, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=427", "section_title": "uvm_sequence_base", "content": "If call_pre_post is set to 1 (default), then the pre_body and post_body tasks will be called before and after the sequence body is called."}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "This task is a user-definable callback that is called before the optional execution of pre_body. This method should not be called directly by the user."}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "virtual task pre_body()"}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "This task is a user-definable callback that is called before the execution of body only when the sequence is started with start. If start is called with call_pre_post set to 0, pre_body is not called. This method should not be called directly by the user."}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "This task is a user-definable callback task that is called on the parent sequence, if any sequence has issued a wait_for_grant() call and after the sequencer has selected this sequence, and before the item is randomized."}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "Although pre_do is a task, consuming simulation cycles may result in unexpected behavior on the driver."}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "This method should not be called directly by the user."}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "This function is a user-definable callback function that is called after the sequence item has been randomized, and just before the item is sent to the driver. This method should not be called directly by the user."}
{"type": "text", "page_from": 428, "page_to": 428, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=428", "section_title": "uvm_sequence_base", "content": "This is the user-defined task where the main sequence code resides. This method should not be called directly by the user."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "virtual task post_body()"}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "This task is a user-definable callback task that is called after the execution of body only when the sequence is started with start. If start is called with call_pre_post set to 0, post_body is not called. This task is a user-definable callback task that is called after the execution of the body, unless the sequence is started with call_pre_post $\\mathtt { = 0 }$ . This method should not be called directly by the user."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "virtual task post_start()"}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "This task is a user-definable callback that is called after the optional execution of post_body. This method should not be called directly by the user."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "function uvm_phase get_starting_phase()"}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "Returns the ‘starting phase’."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "If non-null, the starting phase specifies the phase in which this sequence was started. The starting phase is set automatically when this sequence is started as the default sequence on a sequencer. See uvm_sequencer_base::start_phase_sequence for more information."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "Internally, the uvm_sequence_base uses a uvm_get_to_lock_dap to protect the starting phase value from being modified after the reference has been read. Once the sequence has ended its execution (either via natural termination, or being killed), then the starting phase value can be modified again."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "Sets the ‘starting phase’."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "Internally, the uvm_sequence_base uses a uvm_get_to_lock_dap to protect the starting phase value from being modified after the reference has been read. Once the sequence has ended its execution (either via natural termination, or being killed), then the starting phase value can be modified again."}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "set_automatic_phase_objection"}
{"type": "text", "page_from": 429, "page_to": 429, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=429", "section_title": "uvm_sequence_base", "content": "function void set_automatic_phase_objection( bit value"}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "Sets the ‘automatically object to starting phase’ bit."}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "The most common interaction with the starting phase within a sequence is to simply raise the phase’s objection prior to executing the sequence, and drop the objection after ending the sequence (either naturally, or via a call to kill). In order to simplify this interaction for the user, the UVM provides the ability to perform this functionality automatically."}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "From a timeline point of view, the automatic phase objection looks like:"}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "This functionality can also be enabled in sequences which were not written with UVM Run-Time Phasing in mind:"}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "Internally, the uvm_sequence_base uses a uvm_get_to_lock_dap to protect the automatic_phase_objection value from being modified after the reference has been read. Once the sequence has ended its execution (either via natural termination, or being killed), then the automatic_phase_objection value can be modified again."}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "NEVER set the automatic phase objection bit to 1 if your sequence runs with a forever loop inside of the body, as the objection will never get dropped!"}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "get_automatic_phase_objection"}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "function bit get_automatic_phase_objection()"}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "Returns (and locks) the value of the ‘automatically object to starting phase’ bit."}
{"type": "text", "page_from": 430, "page_to": 430, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=430", "section_title": "uvm_sequence_base", "content": "If 1, then the sequence will automatically raise an objection to the starting phase (if the starting phase is not null) immediately prior to pre_start being called. The objection will be dropped after post_start has executed, or kill has been called."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "function void set_priority int value"}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "The priority of a sequence may be changed at any point in time. When the priority of a sequence is changed, the new priority will be used by the sequencer the next time that it arbitrates between sequences."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "The default priority value for a sequence is 100. Higher values result in higher priorities."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "function int get_priority()"}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "This function returns the current priority of the sequence."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "virtual function bit is_relevant()"}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "The default is_relevant implementation returns 1, indicating that the sequence is always relevant."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "Users may choose to override with their own virtual function to indicate to the sequencer that the sequence is not currently relevant after a request has been made."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "When the sequencer arbitrates, it will call is_relevant on each requesting, unblocked sequence to see if it is relevant. If a 0 is returned, then the sequence will not be chosen."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "If all requesting sequences are not relevant, then the sequencer will call wait_for_relevant on all sequences and re-arbitrate upon its return."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "Any sequence that implements is_relevant must also implement wait_for_relevant so that the sequencer has a way to wait for a sequence to become relevant."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "virtual task wait_for_relevant()"}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "This method is called by the sequencer when all available sequences are not relevant. When wait_for_relevant returns the sequencer attempt to re-arbitrate."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "Returning from this call does not guarantee a sequence is relevant, although that would be the ideal. The method provide some delay to prevent an infinite loop."}
{"type": "text", "page_from": 431, "page_to": 431, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=431", "section_title": "uvm_sequence_base", "content": "If a sequence defines is_relevant so that it is not always relevant (by default, a sequence is always relevant), then the sequence must also supply a wait_for_relevant method."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "task lock( uvm_sequencer_base sequencer $=$ null )"}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "Requests a lock on the specified sequencer. If sequencer is null, the lock will be requested on the current default sequencer."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "A lock request will be arbitrated the same as any other request. A lock is granted after all earlier requests are completed and no other locks or grabs are blocking this sequence."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "The lock call will return when the lock has been granted."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "task grab( uvm_sequencer_base sequencer $=$ null )"}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "Requests a lock on the specified sequencer. If no argument is supplied, the lock will be requested on the current default sequencer."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "A grab request is put in front of the arbitration queue. It will be arbitrated before any other requests. A grab is granted when no other grabs or locks are blocking this sequence."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "The grab call will return when the grab has been granted."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "function void unlock( uvm_sequencer_base sequencer $=$ null )"}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "Removes any locks or grabs obtained by this sequence on the specified sequencer. If sequencer is null, then the unlock will be done on the current default sequencer."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "function void ungrab( uvm_sequencer_base sequencer $=$ null )"}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "Removes any locks or grabs obtained by this sequence on the specified sequencer. If sequencer is null, then the unlock will be done on the current default sequencer."}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "function bit is_blocked()"}
{"type": "text", "page_from": 432, "page_to": 432, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=432", "section_title": "uvm_sequence_base", "content": "Returns a bit indicating whether this sequence is currently prevented from running due to another lock or grab. A 1 is returned if the sequence is currently blocked. A 0 is returned if no lock or grab prevents this sequence from executing. Note that even if a sequence is not blocked, it is possible for another sequence to issue a lock or grab before this sequence can issue a request."}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "function bit has_lock()"}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "Returns 1 if this sequence has a lock, 0 otherwise."}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "Note that even if this sequence has a lock, a child sequence may also have a lock, in which case the sequence is still blocked from issuing operations on the sequencer."}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "function void kill()"}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "This function will kill the sequence, and cause all current locks and requests in the sequence’s default sequencer to be removed. The sequence state will change to UVM_STOPPED, and the post_body() and post_start() callback methods will not be executed."}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "If a sequence has issued locks, grabs, or requests on sequencers other than the default sequencer, then care must be taken to unregister the sequence with the other sequencer(s) using the sequencer unregister_sequence() method."}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "virtual function void do_kill()"}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "This function is a user hook that is called whenever a sequence is terminated by using either sequence.kill() or sequencer.stop_sequences() (which effectively calls sequence.kill())."}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "SeQUeNce ITeM EXec UTION"}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "protected function uvm_sequence_item create_item( uvm_object_wrapper type_var, uvm_sequencer_base l_sequencer, string name )"}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "Create_item will create and initialize a sequence_item or sequence using the factory. The sequence_item or sequence will be initialized to communicate with the specified sequencer."}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "virtual task start_item ( uvm_sequence_item item, int set_priority = -1, uvm_sequencer_base sequencer $=$ null )"}
{"type": "text", "page_from": 433, "page_to": 433, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=433", "section_title": "uvm_sequence_base", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "start_item and finish_item together will initiate operation of a sequence item. If the item has not already been initialized using create_item, then it will be initialized here to use the default sequencer specified by m_sequencer. Randomization may be done between start_item and finish_item to ensure late generation"}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "virtual task finish_item ( uvm_sequence_item item, int set_priority = -1 ) finish_item, together with start_item together will initiate operation of a sequence_item. Finish_item must be called after start_item with no delays or delta-cycles."}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "Randomization, or other functions may be called between the start_item and finish_item calls."}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "virtual task wait_for_grant( int item_priority 三 -1, bit lock_request = 0 )"}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "This task issues a request to the current sequencer. If item_priority is not specified, then the current sequence priority will be used by the arbiter. If a lock_request is made, then the sequencer will issue a lock immediately before granting the sequence. (Note that the lock may be granted without the sequence being granted if is_relevant is not asserted)."}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "When this method returns, the sequencer has granted the sequence, and the sequence must call send_request without inserting any simulation delay other than delta cycles. The driver is currently waiting for the next item to be sent via the send_request call."}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "virtual function void send_request( uvm_sequence_item request, bit rerandomize $\\qquad = \\quad 0$ )"}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "The send_request function may only be called after a wait_for_grant call. This call will send the request item to the sequencer, which will forward it to the driver. If the rerandomize bit is set, the item will be randomized before being sent to the driver."}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "virtual task wait_for_item_done( int transaction_id $\\mathbf { \\bar { \\theta } } = \\mathbf { \\Phi }$ -1"}
{"type": "text", "page_from": 434, "page_to": 434, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=434", "section_title": "uvm_sequence_base", "content": "A sequence may optionally call wait_for_item_done. This task will block until the driver calls item_done or put. If no transaction_id parameter is specified, then the call will return the next time that the driver calls item_done or put. If a specific transaction_id is specified, then the call will return when the driver indicates completion of that specific item."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "Note that if a specific transaction_id has been specified, and the driver has already issued an item_done or put for that transaction, then the call will hang, having missed the earlier notification."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "use_response_handler"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "function void use_response_handler( bit enable"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "When called with enable set to 1, responses will be sent to the response handler. Otherwise, responses must be retrieved using get_response."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "By default, responses from the driver are retrieved in the sequence by calling get_response."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "An alternative method is for the sequencer to call the response_handler function with each response."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "get_use_response_handler"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "function bit get_use_response_handler()"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "Returns the state of the use_response_handler bit."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "virtual function void response_handler( uvm_sequence_item response"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "When the use_response_handler bit is set to 1, this virtual task is called by the sequencer for each response that arrives for this sequence."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "set_response_queue_error_report_disabled"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "function void set_response_queue_error_report_disabled( bit value"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "By default, if the response_queue overflows, an error is reported. The response_queue will overflow if more responses are sent to this sequence from the driver than get_response calls are made. Setting value to 0 disables these errors, while setting it to 1 enables them."}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "get_response_queue_error_report_disabled"}
{"type": "text", "page_from": 435, "page_to": 435, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=435", "section_title": "uvm_sequence_base", "content": "function bit get_response_queue_error_report_disabled()"}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "When this bit is 0 (default value), error reports are generated when the response queue overflows. When this bit is 1, no such error reports are generated."}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "set_response_queue_depth"}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "function void set_response_queue_depth( int value )"}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "The default maximum depth of the response queue is 8. These method is used to examine or change the maximum depth of the response queue."}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "Setting the response_queue_depth to $^ { - 1 }$ indicates an arbitrarily deep response queue. No checking is done."}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "get_response_queue_depth"}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "function int get_response_queue_depth()"}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "Returns the current depth setting for the response queue."}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "clear_response_queue"}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "virtual function void clear_response_queue()"}
{"type": "text", "page_from": 436, "page_to": 436, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=436", "section_title": "uvm_sequence_base", "content": "Empties the response queue for this sequence."}
{"type": "text", "page_from": 437, "page_to": 437, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=437", "section_title": "uvm_sequence #(REQ,RSP)", "header_path": ["20", "3"], "chapter": "20", "section": "20.3", "content": "20.3 uvm_sequence #(REQ,RSP)"}
{"type": "text", "page_from": 437, "page_to": 437, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=437", "section_title": "uvm_sequence", "content": "The uvm_sequence class provides the interfaces necessary in order to create streams of sequence items and/or other sequences."}
{"type": "text", "page_from": 437, "page_to": 437, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=437", "section_title": "uvm_sequence", "content": "uvm_sequence #(REQ,RSP)"}
{"type": "text", "page_from": 437, "page_to": 437, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=437", "section_title": "uvm_sequence", "content": "The uvm_sequence class provides the interfaces necessary in order to create streams of sequence items and/or other sequences."}
{"type": "text", "page_from": 437, "page_to": 437, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=437", "section_title": "uvm_sequence", "content": "req The sequence contains a field of the request type called req. rsp The sequence contains a field of the response type called rsp."}
{"type": "text", "page_from": 437, "page_to": 437, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=437", "section_title": "uvm_sequence", "content": "new Creates and initializes a new sequence object. send_request This method will send the request item to the sequencer, which will forward it to the driver. get_current_item Returns the request item currently being executed by the sequencer. get_response By default, sequences must retrieve responses by calling get_response."}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "The sequence contains a field of the response type called rsp. The user can use this field, if desired, or create another field to use. The default do_print will print this field."}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "Creates and initializes a new sequence object."}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "function void send_request( uvm_sequence_item request, bit rerandomize = 0 ) This method will send the request item to the sequencer, which will forward it to the driver. If the rerandomize bit is set, the item will be randomized before being sent to the driver. The send_request function may only be called after uvm_sequence_base::wait_for_grant returns."}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "function REQ get_current_item()"}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "Returns the request item currently being executed by the sequencer. If the sequencer is not currently executing an item, this method will return null."}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "The sequencer is executing an item from the time that get_next_item or peek is called until the time that get or item_done is called."}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "Note that a driver that only calls get will never show a current item, since the item is completed at the same time as it is requested."}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "virtual task get_response( output RSP response, input int transaction_id = -1"}
{"type": "text", "page_from": 438, "page_to": 438, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=438", "section_title": "uvm_sequence", "content": "By default, sequences must retrieve responses by calling get_response. If no transaction_id is specified, this task will return the next response sent to this sequence. If no response is available in the response queue, the method will block until a response is received."}
{"type": "text", "page_from": 439, "page_to": 439, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=439", "section_title": "uvm_sequence", "content": "If a transaction_id is parameter is specified, the task will block until a response with that transaction_id is received in the response queue."}
{"type": "text", "page_from": 439, "page_to": 439, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=439", "section_title": "uvm_sequence", "content": "The default size of the response queue is 8. The get_response method must be called soon enough to avoid an overflow of the response queue to prevent responses from being dropped."}
{"type": "text", "page_from": 439, "page_to": 439, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=439", "section_title": "uvm_sequence", "content": "If a response is dropped in the response queue, an error will be reported unless the error reporting is disabled via set_response_queue_error_report_disabled."}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "header_path": ["20", "4"], "chapter": "20", "section": "20.4", "content": "20.4 uvm_sequence_library"}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "The uvm_sequence_library is a sequence that contains a list of registered sequence types. It can be configured to create and execute these sequences any number of times using one of several modes of operation, including a user-defined mode."}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "When started (as any other sequence), the sequence library will randomly select and execute a sequence from its sequences queue. If in UVM_SEQ_LIB_RAND mode, its select_rand property is randomized and used as an index into sequences. When in UVM_SEQ_LIB_RANDC mode, the select_randc property is used. When in UVM_SEQ_LIB_ITEM mode, only sequence items of the REQ type are generated and executed--no sequences are executed. Finally, when in UVM_SEQ_LIB_USER mode, the select_sequence method is called to obtain the index for selecting the next sequence to start. Users can override this method in subtypes to implement custom selection algorithms."}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "Creating a subtype of a sequence library requires invocation of the \\`uvm_sequence_library_utils macro in its declaration and calling the init_sequence_library method in its constructor. The macro and function are needed to populate the sequence library with any sequences that were statically registered with it or any of its base classes."}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "class my_seq_lib extends uvm_sequence_library #(my_item); \\`uvm_object_utils(my_seq_lib) \\`uvm_sequence_library_utils(my_seq_lib)function new(string name=\"\"); super.new(name); init_sequence_library(); endfunction endclass"}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "uvm_sequence_library The uvm_sequence_library is a sequence that contains a list of registered sequence types. uvm_sequence_library_cfg A convenient container class for configuring all the sequence library parameters using a single set command."}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "function new( string name )"}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "Create a new instance of this class"}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "virtual function string get_type_name()"}
{"type": "text", "page_from": 440, "page_to": 440, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=440", "section_title": "uvm_sequence_library", "content": "Get the type name of this class"}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "uvm_sequence_lib_mode selection_mode"}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "Specifies the mode used to select sequences for execution"}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "If you do not have access to an instance of the library, use the configuration resource interface."}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "The following example sets the config_seq_lib as the default sequence for the ‘main’ phase on the sequencer to be located at “env.agent.sequencer” and set the selection mode to UVM_SEQ_LIB_RANDC. If the settings are being done from within a component, the first argument must be this and the second argument a path relative to that component."}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "Alternatively, you may create an instance of the sequence library a priori, initialize all its parameters, randomize it, then set it to run as-is on the sequencer."}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "int unsigned min_random_count ${ \\tt = } 1 0$"}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "Sets the minimum number of items to execute. Use the configuration mechanism to set. See selection_mode for an example."}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "int unsigned max_random_coun $\\mathtt { t } = 1 0$"}
{"type": "text", "page_from": 441, "page_to": 441, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=441", "section_title": "uvm_sequence_library", "content": "Sets the maximum number of items to execute. Use the configuration mechanism to set. See selection_mode for an example."}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "protected int unsigned sequences_executed"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "Indicates the number of sequences executed, not including the currently executing sequence, if any."}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "rand int unsigned sequence_count $\\qquad = \\quad \\mathtt { 1 0 }$"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "Specifies the number of sequences to execute when this sequence library is started. If in UVM_SEQ_LIB_ITEM mode, specifies the number of sequence items that will be generated."}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "rand int unsigned select_rand"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "The index variable that is randomized to select the next sequence to execute when in UVM_SEQ_LIB_RAND mode"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "Extensions may place additional constraints on this variable."}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "randc bit [15:0] select_randc"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "The index variable that is randomized to select the next sequence to execute when in UVM_SEQ_LIB_RANDC mode"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "Extensions may place additional constraints on this variable."}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "virtual function int unsigned select_sequence( int unsigned max"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "Generates an index used to select the next sequence to execute. Overrides must return a value between 0 and max, inclusive. Used only for UVM_SEQ_LIB_USER selection mode. The default implementation returns 0, incrementing on successive calls, wrapping back to 0 when reaching max."}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "SEQUENcE REGIsTRATION"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "add_typewide_sequence"}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "static function void add typewide sequence("}
{"type": "text", "page_from": 442, "page_to": 442, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=442", "section_title": "uvm_sequence_library", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "Registers the provided sequence type with this sequence library type. The sequence type will be available for selection by all instances of this class. Sequence types already registered are silently ignored."}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "add_typewide_sequences"}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "static function void add_typewide_sequences( uvm_object_wrapper seq_types[\\$]"}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "Registers the provided sequence types with this sequence library type. The sequence types will be available for selection by all instances of this class. Sequence types already registered are silently ignored."}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "function void add_sequence( uvm_object_wrapper seq_type )"}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "Registers the provided sequence type with this sequence library instance. Sequence types already registered are silently ignored."}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "virtual function void add_sequences( uvm_object_wrapper seq_types[\\$] ）"}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "Registers the provided sequence types with this sequence library instance. Sequence types already registered are silently ignored."}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "virtual function void remove_sequence(uvm_object_wrapper seq_type）"}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "Removes the given sequence type from this sequence library instance. If the type was registered statically, the sequence queues of all instances of this library will be updated accordingly. A warning is issued if the sequence is not registered."}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "virtual function void get_sequences( ref uvm_object_wrapper seq_types[\\$] )"}
{"type": "text", "page_from": 443, "page_to": 443, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=443", "section_title": "uvm_sequence_library", "content": "Append to the provided seq_types array the list of registered sequences."}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "init_sequence_library"}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "function void init_sequence_library()"}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "All subtypes of this class must call init_sequence_library in its constructor."}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "uvm_sequence_library_utils"}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "All subtypes of this class must invoke the \\`uvm_sequence_library_utils macro."}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "class my_seq_lib extends uvm_sequence_library #(my_item); \\`uvm_object_utils(my_seq_lib) \\`uvm_sequence_library_utils(my_seq_lib) function new(string name=\"\"); super.new(name); init_sequence_library(); endfunction ... endclass"}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "A convenient container class for configuring all the sequence library parameters using a single set command."}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "uvm_sequence_library_cfg cfg; cfg $\\underline { { \\underline { { \\mathbf { \\Pi } } } } } = \\underline { { \\underline { { \\mathbf { \\delta \\pi } } } } }$ new(\"seqlib_cfg\", UVM_SEQ_LIB_RANDC, 1000, 2000); uvm_config_db #(uvm_sequence_library_cfg)::set(null, \"env.agent.sequencer.main_ph\", \"default_sequence.config\", cfg);"}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "uvm_sequence_library_cfg"}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "A convenient container class for configuring all the sequence library parameters using a single set command."}
{"type": "text", "page_from": 444, "page_to": 444, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=444", "section_title": "uvm_sequence_library", "content": "class uvm_sequence_library_cfg extends uvm_object"}
{"type": "text", "page_from": 445, "page_to": 445, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=445", "section_title": "Macros and Defines", "content": "21. Macros and Defines"}
{"type": "text", "page_from": 445, "page_to": 445, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=445", "section_title": "Macros and Defines", "content": "UVM includes some macros to allow the user to specify intent without the need to specify multiple types of SystemVerilog constructs. These macros assist with reporting, object behavior (interaction with the factory and field usage in comparing/copying/etc), sequence specification, and TLM connection."}
{"type": "text", "page_from": 445, "page_to": 445, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=445", "section_title": "Macros and Defines", "content": "UVM also includes some defines to specify sizing in the register space and to determine version of the UVM standard and/or implementation."}
{"type": "text", "page_from": 445, "page_to": 445, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=445", "section_title": "Macros and Defines", "content": "UVM includes some macros to allow the user to specify intent without the need to specify multiple types of SystemVerilog constructs."}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "This set of macros provides wrappers around the uvm_report_\\* Reporting functions. The macros serve two essential purposes:"}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "To reduce the processing overhead associated with filtered out messages, a check is made against the report’s verbosity setting and the action for the id/severity pair before any string formatting is performed. This affects only \\`uvm_info reports. The \\`__FILE__ and \\`__LINE__ information is automatically provided to the underlying uvm_report_\\* call. Having the file and line number from where a report was issued aides in debug. You can disable display of file and line information in reports by defining UVM_REPORT_DISABLE_FILE_LINE on the command line."}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "The macros also enforce a verbosity setting of UVM_NONE for warnings, errors and fatals so that they cannot be mistakenly turned off by setting the verbosity level too low (warning and errors can still be turned off by setting the actions appropriately)."}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "To use the macros, replace the previous call to uvm_report_\\* with the corresponding macro."}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "//Previous calls to uvm_report_\\* uvm_report_info(\"MYINFO1\", \\$sformatf(\"val: %0d\", val), UVM_LOW); uvm_report_warning(\"MYWARN1\", \"This is a warning\"); uvm_report_error(\"MYERR\", \"This is an error\"); uvm_report_fatal(\"MYFATAL\", \"A fatal error has occurred\");"}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "The above code is replaced by //New calls to \\`uvm_\\* \\`uvm_info(\"MYINFO1\", \\$sformatf(\"val: %0d\", val), UVM_LOW) \\`uvm_warning(\"MYWARN1\", \"This is a warning\") \\`uvm_error(\"MYERR\", \"This is an error\") \\`uvm_fatal(\"MYFATAL\", \"A fatal error has occurred\")"}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "Macros represent text substitutions, not statements, so they should not be terminated with semi-colons."}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "This set of macros provides wrappers around the uvm_report_\\* Reporting functions."}
{"type": "text", "page_from": 446, "page_to": 446, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=446", "section_title": "Report Macros", "content": "BAsIC MEss AGING MACr Os"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "\\`uvm_warning_context \\`uvm_error_context \\`uvm_fatal_context"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "MEss AGE Tr ACE MACr Os"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "\\`uvm_info_begin \\`uvm_info_end"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "This macro pair provides the ability to add elements to messages."}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "\\`uvm_warning_begin \\`uvm_warning_end"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_info_begin/\\`uvm_info_end with exception that the message severity is UVM_WARNING and has no verbosity threshold."}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "\\`uvm_error_begin \\`uvm_error_end"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_info_begin/\\`uvm_info_end with exception that the message severity is UVM_ERROR and has no verbosity threshold."}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "\\`uvm_fatal_begin \\`uvm_fatal_end"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_info_begin/\\`uvm_info_end with exception that the message severity is UVM_FATAL and has no verbosity threshold."}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "\\`uvm_info_context_begin \\`uvm_info_context_end \\`uvm_warning_context_begin \\`uvm_warning_context_end \\`uvm_error_context_begin \\`uvm_error_context_end \\`uvm_fatal_context_begin \\`uvm_fatal_context_end"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "MEss AGE ELEmENt MACr Os"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "\\`uvm_message_add_tag \\`uvm_message_add_int \\`uvm_message_add_string \\`uvm_message_add_object"}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "Calls uvm_report_info if VERBOSITY is lower than the configured verbosity of the associated reporter. ID is given as the message tag and MSG is given as the message text. The file and line are also sent to the uvm_report_info call."}
{"type": "text", "page_from": 447, "page_to": 447, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=447", "section_title": "Report Macros", "content": "Calls uvm_report_warning with a verbosity of UVM_NONE. The message cannot be turned off using the reporter’s verbosity setting, but can be turned off by setting the"}
{"type": "text", "page_from": 448, "page_to": 448, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=448", "section_title": "Report Macros", "content": "action for the message. $I D$ is given as the message tag and MSG is given as the message text. The file and line are also sent to the uvm_report_warning call."}
{"type": "text", "page_from": 448, "page_to": 448, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=448", "section_title": "Report Macros", "content": "Calls uvm_report_error with a verbosity of UVM_NONE. The message cannot be turned off using the reporter’s verbosity setting, but can be turned off by setting the action for the message. $I D$ is given as the message tag and MSG is given as the message text. The file and line are also sent to the uvm_report_error call."}
{"type": "text", "page_from": 448, "page_to": 448, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=448", "section_title": "Report Macros", "content": "Calls uvm_report_fatal with a verbosity of UVM_NONE. The message cannot be turned off using the reporter’s verbosity setting, but can be turned off by setting the action for the message. $I D$ is given as the message tag and MSG is given as the message text. The file and line are also sent to the uvm_report_fatal call."}
{"type": "text", "page_from": 448, "page_to": 448, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=448", "section_title": "Report Macros", "content": "Operates identically to \\`uvm_info but requires that the context, or uvm_report_object, in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 448, "page_to": 448, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=448", "section_title": "Report Macros", "content": "Operates identically to \\`uvm_warning but requires that the context, or uvm_report_object, in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 449, "page_to": 449, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=449", "section_title": "Report Macros", "content": "Operates identically to \\`uvm_error but requires that the context, or uvm_report_object in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 449, "page_to": 449, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=449", "section_title": "Report Macros", "content": "Operates identically to \\`uvm_fatal but requires that the context, or uvm_report_object, in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 449, "page_to": 449, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=449", "section_title": "Report Macros", "content": "MEss AGE Tr ACE MACr Os"}
{"type": "text", "page_from": 449, "page_to": 449, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=449", "section_title": "Report Macros", "content": "This macro pair provides the ability to add elements to messages."}
{"type": "text", "page_from": 449, "page_to": 449, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=449", "section_title": "Report Macros", "content": "Example usage is shown here."}
{"type": "text", "page_from": 450, "page_to": 450, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=450", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_info_begin/\\`uvm_info_end with exception that the message severity is UVM_WARNING and has no verbosity threshold."}
{"type": "text", "page_from": 450, "page_to": 450, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=450", "section_title": "Report Macros", "content": "The usage shown in \\`uvm_info_end works identically for this pair."}
{"type": "text", "page_from": 450, "page_to": 450, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=450", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_info_begin/\\`uvm_info_end with exception that the message severity is UVM_ERROR and has no verbosity threshold."}
{"type": "text", "page_from": 450, "page_to": 450, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=450", "section_title": "Report Macros", "content": "The usage shown in \\`uvm_info_end works identically for this pair."}
{"type": "text", "page_from": 450, "page_to": 450, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=450", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_info_begin/\\`uvm_info_end with exception that the message severity is UVM_FATAL and has no verbosity threshold."}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "The usage shown in \\`uvm_info_end works identically for this pair."}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "uvm_info_context_begin"}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "\\`uvm_info_context_end"}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_info_begin/\\`uvm_info_end, but requires that the context, or uvm_report_object in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "uvm_warning_context_begin"}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "uvm_warning_context_end"}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_warning_begin/\\`uvm_warning_end, but requires that the context, or uvm_report_object in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 451, "page_to": 451, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=451", "section_title": "Report Macros", "content": "uvm_error_context_begin"}
{"type": "text", "page_from": 452, "page_to": 452, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=452", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_error_begin/\\`uvm_error_end, but requires that the context, or uvm_report_object in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 452, "page_to": 452, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=452", "section_title": "Report Macros", "content": "uvm_fatal_context_begin"}
{"type": "text", "page_from": 452, "page_to": 452, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=452", "section_title": "Report Macros", "content": "uvm_fatal_context_end"}
{"type": "text", "page_from": 452, "page_to": 452, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=452", "section_title": "Report Macros", "content": "This macro pair operates identically to \\`uvm_fatal_begin/\\`uvm_fatal_end, but requires that the context, or uvm_report_object in which the message is printed be explicitly supplied as a macro argument."}
{"type": "text", "page_from": 452, "page_to": 452, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=452", "section_title": "Report Macros", "content": "MEss AGE ELEmENt MACr Os"}
{"type": "text", "page_from": 452, "page_to": 452, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=452", "section_title": "Report Macros", "content": "\\`uvm_message_add_string"}
{"type": "text", "page_from": 453, "page_to": 453, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=453", "section_title": "Report Macros", "content": "uvm_message_add_object"}
{"type": "text", "page_from": 453, "page_to": 453, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=453", "section_title": "Report Macros", "content": "These macros allow the user to provide elements that are associated with uvm_report_messages. Separate macros are provided such that the user can supply arbitrary string/string pairs using \\`uvm_message_add_tag, integral types along with a radix using \\`uvm_message_add_int, string using \\`uvm_message_add_string and uvm_objects using \\`uvm_message_add_object."}
{"type": "text", "page_from": 454, "page_to": 454, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=454", "section_title": "Utility and Field Macros for Components and Objects", "header_path": ["21", "2"], "chapter": "21", "section": "21.2", "content": "21.2 Utility and Field Macros for Components and Objects"}
{"type": "text", "page_from": 457, "page_to": 457, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=457", "section_title": "Component and Object", "content": "The utils macros define the infrastructure needed to enable the object/component for correct factory operation. See \\`uvm_object_utils and \\`uvm_component_utils for details."}
{"type": "text", "page_from": 457, "page_to": 457, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=457", "section_title": "Component and Object", "content": "A utils macro should be used inside every user-defined class that extends uvm_object directly or indirectly, including uvm_sequence_item and uvm_component."}
{"type": "text", "page_from": 457, "page_to": 457, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=457", "section_title": "Component and Object", "content": "Below is an example usage of the utils macro for a user-defined object."}
{"type": "text", "page_from": 457, "page_to": 457, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=457", "section_title": "Component and Object", "content": "Below is an example usage of a utils macro for a user-defined component."}
{"type": "text", "page_from": 458, "page_to": 458, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=458", "section_title": "Component and Object", "content": "These macros form a block in which \\`uvm_field_\\* macros can be placed. Used as"}
{"type": "text", "page_from": 458, "page_to": 458, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=458", "section_title": "Component and Object", "content": "These macros do not perform factory registration nor implement the get_type_name and create methods. Use this form when you need custom implementations of these two methods, or when you are setting up field macros for an abstract class (i.e. virtual class)."}
{"type": "text", "page_from": 458, "page_to": 458, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=458", "section_title": "Component and Object", "content": "uvm_object_utils_end"}
{"type": "text", "page_from": 458, "page_to": 458, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=458", "section_title": "Component and Object", "content": "uvm_object-based class declarations may contain one of the above forms of utility macros."}
{"type": "text", "page_from": 458, "page_to": 458, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=458", "section_title": "Component and Object", "content": "For simple objects with no field macros, use"}
{"type": "text", "page_from": 458, "page_to": 458, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=458", "section_title": "Component and Object", "content": "For simple objects with field macros, use"}
{"type": "text", "page_from": 459, "page_to": 459, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=459", "section_title": "Component and Object", "content": "For parameterized objects with no field macros, use"}
{"type": "text", "page_from": 459, "page_to": 459, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=459", "section_title": "Component and Object", "content": "For parameterized objects, with field macros, use \\`uvm_object_param_utils_begin(TYPE) uvm f j eld_\\* macro invocations here \\`uvm_object_utils_end"}
{"type": "text", "page_from": 459, "page_to": 459, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=459", "section_title": "Component and Object", "content": "Simple (non-parameterized) objects use the uvm_object_utils\\* versions, which do the following:"}
{"type": "text", "page_from": 459, "page_to": 459, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=459", "section_title": "Component and Object", "content": "Implements get_type_name, which returns TYPE as a string Implements create, which allocates an object of type TYPE by calling its constructor with no arguments. TYPE’s constructor, if defined, must have default values on all it arguments. Registers the TYPE with the factory, using the string TYPE as the factory lookup string for the type. Implements the static get_type() method which returns a factory proxy object for the type. Implements the virtual get_object_type() method which works just like the static get_type() method, but operates on an already allocated object."}
{"type": "text", "page_from": 459, "page_to": 459, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=459", "section_title": "Component and Object", "content": "Parameterized classes must use the uvm_object_param_utils\\* versions. They differ from \\`uvm_object_utils only in that they do not supply a type name when registering the object with the factory. As such, name-based lookup with the factory for parameterized classes is not possible."}
{"type": "text", "page_from": 459, "page_to": 459, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=459", "section_title": "Component and Object", "content": "The macros with _begin suffixes are the same as the non-suffixed versions except that they also start a block in which \\`uvm_field_\\* macros can be placed. The block must be terminated by \\`uvm_object_utils_end."}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "For simple components with field macros, use"}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "For parameterized components with no field macros, use"}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "For parameterized components with field macros, use"}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "Simple (non-parameterized) components must use the uvm_components_utils\\* versions, which do the following:"}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "Implements get_type_name, which returns TYPE as a string. Implements create, which allocates a component of type TYPE using a two argument constructor. TYPE’s constructor must have a name and a parent argument. Registers the TYPE with the factory, using the string TYPE as the factory lookup string for the type. Implements the static get_type() method which returns a factory proxy object for the type. Implements the virtual get_object_type() method which works just like the static get_type() method, but operates on an already allocated object."}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "Parameterized classes must use the uvm_object_param_utils\\* versions. They differ from \\`uvm_object_utils only in that they do not supply a type name when registering the object with the factory. As such, name-based lookup with the factory for parameterized classes is not possible."}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "The macros with _begin suffixes are the same as the non-suffixed versions except that they also start a block in which \\`uvm_field_\\* macros can be placed. The block must be terminated by \\`uvm_component_utils_end."}
{"type": "text", "page_from": 460, "page_to": 460, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=460", "section_title": "Component and Object", "content": "Register a uvm_object-based class with the factory"}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "Registers a uvm_object-based class $\\tau$ and lookup string $S$ with the factory. S typically is the name of the class in quotes. The \\`uvm_object_utils family of macros uses this macro."}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "uvm_component_registry"}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "Registers a uvm_component-based class with the factory"}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "Registers a uvm_component-based class $\\tau$ and lookup string $S$ with the factory. S typically is the name of the class in quotes. The \\`uvm_object_utils family of macros uses this macro."}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "The \\`uvm_field_\\* macros are invoked inside of the \\`uvm_\\*_utils_begin and \\`uvm_\\*_utils_end macro blocks to form “automatic” implementations of the core data methods: copy, compare, pack, unpack, record, print, and sprint."}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "By using the macros, you do not have to implement any of the do_\\* methods inherited from uvm_object. However, be aware that the field macros expand into general inline code that is not as run-time efficient nor as flexible as direct implementations of the do_\\* methods."}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "Below is an example usage of the field macros for a sequence item."}
{"type": "text", "page_from": 461, "page_to": 461, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=461", "section_title": "Component and Object", "content": "Below is an example usage of the field macros for a component."}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "Each \\`uvm_field_\\* macro is named according to the particular data type it handles: integrals, strings, objects, queues, etc., and each has at least two arguments: ARG and FLAG."}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "ARG is the instance name of the variable, whose type must be compatible with the macro being invoked. In the example, class variable addr is an integral type, so we use the \\`uvm_field_int macro. FLAG if set to UVM_ALL_ON, as in the example, the ARG variable will be included in all data methods. If FLAG is set to something other than UVM_ALL_ON or UVM_DEFAULT, it specifies which data method implementations will not include the given variable. Thus, if FLAG is specified as NO_COMPARE, the ARG variable will not affect comparison operations, but it will be included in everything else."}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "All possible values for FLAG are listed and described below. Multiple flag values can be bitwise OR’ed together (in most cases they may be added together as well, but care must be taken when using the $^ +$ operator to ensure that the same bit is not added more than once)."}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "UVM_ALL_ON UVM_DEFAULT"}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "This is the recommended set of flags to pass to the field macros. Currently, it enables all of the operations, making it functionally identical to UVM_ALL_ON. In the future however, additional flags could be added with a recommended default value of off."}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "UVM_NOCOPY UVM_NOCOMPARE UVM_NOPRINT UVM_NOPACK UVM_REFERENCE"}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "A radix for printing and recording can be specified by OR’ing one of the following constants in the FLAG argument"}
{"type": "text", "page_from": 462, "page_to": 462, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=462", "section_title": "Component and Object", "content": "UVM_BIN Print / record the field in binary (base-2). UVM_DEC Print / record the field in decimal (base-10). UVM_UNSIGNED Print / record the field in unsigned decimal (base-10). UVM_OCT Print / record the field in octal (base-8). UVM_HEX Print / record the field in hexadecimal (base-16). UVM_STRING Print / record the field in string format. UVM_TIME Print / record the field in time format."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "Radix settings for integral types. Hex is the default radix if none is specified."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "A UVM component should not be specified using the \\`uvm_field_object macro unless its flag includes UVM_REFERENCE. Otherwise, the field macro will implement deep copy, which is an illegal operation for uvm_components. You will get a FATAL error if you tried to copy or clone an object containing a component handle that was registered with a field macro without the UVM_REFERENCE flag. You will also get duplicate entries when printing component topology, as this functionality is already provided by UVM."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "Macros that implement data operations for scalar properties."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "Implements the data operations for any packed integral property."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "ARG is an integral property of the class, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "Implements the data operations for a uvm_object-based property."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "ARG is an object property of the class, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "Implements the data operations for a string property."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "ARG is a string property of the class, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 463, "page_to": 463, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=463", "section_title": "Component and Object", "content": "Implements the data operations for an enumerated property."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "$\\tau$ is an enumerated type, ARG is an instance of that type, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "Implements the data operations for any real property."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "ARG is an real property of the class, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "Implements the data operations for an event property."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "ARG is an event property of the class, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "Macros that implement data operations for one-dimensional static array properties."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "uvm_field_sarray_int"}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional static array of integrals."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "ARG is a one-dimensional static array of integrals, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "uvm_field_sarray_object"}
{"type": "text", "page_from": 464, "page_to": 464, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=464", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional static array of uvm_object-based objects."}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "ARG is a one-dimensional static array of uvm_object-based objects, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "\\`uvm_field_sarray_string"}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional static array of strings."}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "ARG is a one-dimensional static array of strings, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "uvm_field_sarray_enum"}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional static array of enums."}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "$\\tau$ is a one-dimensional dynamic array of enums type, ARG is an instance of that type, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above"}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "Macros that implement data operations for one-dimensional dynamic array properties."}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "lines flagged with empty multi-line comments, $/ ^ { * * } / ,$ , are not needed or need to be different for fixed arrays, which cannot be resized. Fixed arrays do not need to pack/unpack their size either, because their size is known; wouldn’t hurt though if it allowed code consolidation. Unpacking would necessarily be different. \\*/"}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional dynamic array of integrals."}
{"type": "text", "page_from": 465, "page_to": 465, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=465", "section_title": "Component and Object", "content": "ARG is a one-dimensional dynamic array of integrals, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional dynamic array of uvm_objectbased objects."}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "ARG is a one-dimensional dynamic array of uvm_object-based objects, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "uvm_field_array_string"}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional dynamic array of strings."}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "ARG is a one-dimensional dynamic array of strings, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "uvm_field_array_enum"}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional dynamic array of enums."}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "$\\tau$ is a one-dimensional dynamic array of enums type, ARG is an instance of that type, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 466, "page_to": 466, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=466", "section_title": "Component and Object", "content": "Macros that implement data operations for dynamic queues."}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "Implements the data operations for a queue of uvm_object-based objects."}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "ARG is a one-dimensional queue of uvm_object-based objects, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "Implements the data operations for a queue of strings."}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "ARG is a one-dimensional queue of strings, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "uvm_field_queue_enum"}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "Implements the data operations for a one-dimensional queue of enums."}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "$\\tau$ is a queue of enums type, ARG is an instance of that type, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 467, "page_to": 467, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=467", "section_title": "Component and Object", "content": "Macros that implement data operations for associative arrays indexed by string."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of uvm_object-based objects indexed by string."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of objects with string key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "uvm_field_aa_string_string"}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of strings indexed by string."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of strings with string key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "Macros that implement data operations for associative arrays indexed by an integral type."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "uvm_field_aa_object_int"}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of uvm_object-based objects indexed by the int data type."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of objects with int key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "uvm_field_aa_int_int"}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the int data type."}
{"type": "text", "page_from": 468, "page_to": 468, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=468", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with int key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the int unsigned data type."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with int unsigned key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "uvm_field_aa_int_integer"}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the integer data type."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with integer key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "uvm_field_aa_int_integer_unsigned"}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the integer unsigned data type."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with integer unsigned key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "uvm_field_aa_int_byte"}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the byte data type."}
{"type": "text", "page_from": 469, "page_to": 469, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=469", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with byte key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the byte unsigned data type."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with byte unsigned key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "uvm_field_aa_int_shortint"}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the shortint data type."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with shortint key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "uvm_field_aa_int_shortint_unsigned"}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the shortint unsigned data type."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with shortint unsigned key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "uvm_field_aa_int_longint"}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the longint data type."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with longint key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "uvm_field_aa_int_longint_unsigned"}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by the longint unsigned data type."}
{"type": "text", "page_from": 470, "page_to": 470, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=470", "section_title": "Component and Object", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "ARG is the name of a property that is an associative array of integrals with longint unsigned key, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "uvm_field_aa_int_key"}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by any integral key data type."}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "KEY is the data type of the integral key, ARG is the name of a property that is an associative array of integrals, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "uvm_field_aa_int_enumkey"}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "Implements the data operations for an associative array of integral types indexed by any enumeration key data type."}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "KEY is the enumeration type of the key, ARG is the name of a property that is an associative array of integrals, and FLAG is a bitwise OR of one or more flag settings as described in Field Macros above."}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "The recording macros assist users who implement the uvm_object::do_record method. They help ensure that the fields are recorded using a vendor- independent API. Unlike the uvm_recorder policy, fields recorded using the macros do not lose type information-- they are passed directly to the vendor-specific API. This results in more efficient recording and no artificial limit on bit-widths. See your simulator vendor’s documentation for more information on its transaction recording capabilities."}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "uvm_record_attribute"}
{"type": "text", "page_from": 471, "page_to": 471, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=471", "section_title": "Component and Object", "content": "Vendor-independent macro to hide tool-specific interface for recording attributes (fields) to a transaction database."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "The default implementation of the macro passes NAME and VALUE through to the uvm_recorder::record_generic method."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "This macro should not be called directly by the user, the other recording macros will call it automatically if uvm_recorder::use_record_attribute returns true."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "The \\`uvm_record_int macro takes the same arguments as the uvm_recorder::record_field method (including the optional RADIX)."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "The default implementation will pass the name/value pair to \\`uvm_record_attribute if enabled, otherwise the information will be passed to uvm_recorder::record_field."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "The \\`uvm_record_string macro takes the same arguments as the uvm_recorder::record_string method."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "The default implementation will pass the name/value pair to \\`uvm_record_attribute if enabled, otherwise the information will be passed to uvm_recorder::record_string."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "The \\`uvm_record_time macro takes the same arguments as the uvm_recorder::record_time method."}
{"type": "text", "page_from": 472, "page_to": 472, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=472", "section_title": "Component and Object", "content": "The default implementation will pass the name/value pair to \\`uvm_record_attribute if enabled, otherwise the information will be passed to uvm_recorder::record_time."}
{"type": "text", "page_from": 473, "page_to": 473, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=473", "section_title": "Component and Object", "content": "The \\`uvm_record_real macro takes the same arguments as the uvm_recorder::record_field_real method."}
{"type": "text", "page_from": 473, "page_to": 473, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=473", "section_title": "Component and Object", "content": "The default implementation will pass the name/value pair to \\`uvm_record_attribute if enabled, otherwise the information will be passed to uvm_recorder::record_field_real."}
{"type": "text", "page_from": 473, "page_to": 473, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=473", "section_title": "Component and Object", "content": "Macro for recording arbitrary name-value pairs into a transaction recording database. Requires a valid transaction handle, as provided by the uvm_transaction::begin_tr and uvm_component::begin_tr methods."}
{"type": "text", "page_from": 473, "page_to": 473, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=473", "section_title": "Component and Object", "content": "The default implementation will pass the name/value pair to \\`uvm_record_attribute if enabled, otherwise the information will be passed to uvm_recorder::record_generic, with the VALUE being converted to a string using $\\ \" \\% \\mathsf { p } ^ { \\prime \\prime }$ notation."}
{"type": "text", "page_from": 473, "page_to": 473, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=473", "section_title": "Component and Object", "content": "The packing macros assist users who implement the uvm_object::do_pack method. They help ensure that the pack operation is the exact inverse of the unpack operation. See also Unpacking Macros."}
{"type": "text", "page_from": 473, "page_to": 473, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=473", "section_title": "Component and Object", "content": "The $\\because N ^ { \\prime }$ versions of these macros take an explicit size argument, which must be compiletime constant value greater than 0."}
{"type": "text", "page_from": 473, "page_to": 473, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=473", "section_title": "Component and Object", "content": "PAcKING - WITH SIZE INfo"}
{"type": "text", "page_from": 474, "page_to": 474, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=474", "section_title": "Component and Object", "content": "Pack an integral variable."}
{"type": "text", "page_from": 474, "page_to": 474, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=474", "section_title": "Component and Object", "content": "Pack a static array of integrals."}
{"type": "text", "page_from": 474, "page_to": 474, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=474", "section_title": "Component and Object", "content": "Pack a dynamic array of integrals."}
{"type": "text", "page_from": 474, "page_to": 474, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=474", "section_title": "Component and Object", "content": "Pack a queue of integrals."}
{"type": "text", "page_from": 474, "page_to": 474, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=474", "section_title": "Component and Object", "content": "PAcKING - No SIZE INfo"}
{"type": "text", "page_from": 474, "page_to": 474, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=474", "section_title": "Component and Object", "content": "Pack an integral variable without having to also specify the bit size."}
{"type": "text", "page_from": 474, "page_to": 474, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=474", "section_title": "Component and Object", "content": "Pack an enumeration value. Packing does not require its type be specified."}
{"type": "text", "page_from": 475, "page_to": 475, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=475", "section_title": "Component and Object", "content": "Pack a string variable."}
{"type": "text", "page_from": 475, "page_to": 475, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=475", "section_title": "Component and Object", "content": "Pack a variable of type real."}
{"type": "text", "page_from": 475, "page_to": 475, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=475", "section_title": "Component and Object", "content": "Pack a static array without having to also specify the bit size of its elements."}
{"type": "text", "page_from": 475, "page_to": 475, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=475", "section_title": "Component and Object", "content": "Pack a dynamic array without having to also specify the bit size of its elements. Array size must be non-zero."}
{"type": "text", "page_from": 475, "page_to": 475, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=475", "section_title": "Component and Object", "content": "Pack a queue without having to also specify the bit size of its elements. Queue must not be empty."}
{"type": "text", "page_from": 476, "page_to": 476, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=476", "section_title": "Component and Object", "content": "The unpacking macros assist users who implement the uvm_object::do_unpack method. They help ensure that the unpack operation is the exact inverse of the pack operation. See also Packing Macros."}
{"type": "text", "page_from": 476, "page_to": 476, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=476", "section_title": "Component and Object", "content": "The $\\because N ^ { \\prime }$ versions of these macros take an explicit size argument, which must be a compiletime constant value greater than 0."}
{"type": "text", "page_from": 476, "page_to": 476, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=476", "section_title": "Component and Object", "content": "UNpAcKING - WITH SIZE INfo"}
{"type": "text", "page_from": 476, "page_to": 476, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=476", "section_title": "Component and Object", "content": "Unpack into an integral variable."}
{"type": "text", "page_from": 476, "page_to": 476, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=476", "section_title": "Component and Object", "content": "Unpack enum of type TYPE into VAR."}
{"type": "text", "page_from": 476, "page_to": 476, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=476", "section_title": "Component and Object", "content": "\\`uvm_unpack_enumN(VAR,SIZE,TYPE)"}
{"type": "text", "page_from": 476, "page_to": 476, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=476", "section_title": "Component and Object", "content": "Unpack a static (fixed) array of integrals."}
{"type": "text", "page_from": 477, "page_to": 477, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=477", "section_title": "Component and Object", "content": "Unpack into a queue of integrals."}
{"type": "text", "page_from": 477, "page_to": 477, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=477", "section_title": "Component and Object", "content": "Unpack an integral variable without having to also specify the bit size."}
{"type": "text", "page_from": 477, "page_to": 477, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=477", "section_title": "Component and Object", "content": "Unpack an enumeration value, which requires its type be specified."}
{"type": "text", "page_from": 477, "page_to": 477, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=477", "section_title": "Component and Object", "content": "Unpack a string variable."}
{"type": "text", "page_from": 478, "page_to": 478, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=478", "section_title": "Component and Object", "content": "Unpack a dynamic array without having to also specify the bit size of its elements. Array size must be non-zero."}
{"type": "text", "page_from": 478, "page_to": 478, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=478", "section_title": "Component and Object", "content": "Unpack a queue without having to also specify the bit size of its elements. Queue must not be empty."}
{"type": "text", "page_from": 479, "page_to": 479, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=479", "section_title": "Sequence and Do Action", "content": "SEQUENCE ACTION MaCr Os"}
{"type": "text", "page_from": 479, "page_to": 479, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=479", "section_title": "Sequence and Do Action", "content": "These macros are used to start sequences and sequence items on the default sequencer, m_sequencer. This is determined a number of ways."}
{"type": "text", "page_from": 479, "page_to": 479, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=479", "section_title": "Sequence and Do Action", "content": "the sequencer handle provided in the uvm_sequence_base::start method the sequencer used by the parent sequence the sequencer that was set using the uvm_sequence_item::set_sequencer method"}
{"type": "text", "page_from": 480, "page_to": 480, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=480", "section_title": "Sequence and Do Action", "content": "This action creates the item or sequence using the factory. It intentionally does zero processing. After this action completes, the user can manually set values, manipulate rand_mode and constraint_mode, etc."}
{"type": "text", "page_from": 480, "page_to": 480, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=480", "section_title": "Sequence and Do Action", "content": "This macro takes as an argument a uvm_sequence_item variable or object. The argument is created using \\`uvm_create if necessary, then randomized. In the case of an item, it is randomized after the call to uvm_sequence_base::start_item() returns. This is called late-randomization. In the case of a sequence, the sub-sequence is started using uvm_sequence_base::start() with call_pre_post set to 0. In the case of an item, the item is sent to the driver through the associated sequencer."}
{"type": "text", "page_from": 480, "page_to": 480, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=480", "section_title": "Sequence and Do Action", "content": "For a sequence item, the following are called, in order"}
{"type": "text", "page_from": 480, "page_to": 480, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=480", "section_title": "Sequence and Do Action", "content": "For a sequence, the following are called, in order"}
{"type": "text", "page_from": 481, "page_to": 481, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=481", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_do except that the constraint block in the 2nd argument is applied to the item or sequence in a randomize with statement before execution."}
{"type": "text", "page_from": 481, "page_to": 481, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=481", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_do_pri except that the given constraint block is applied to the item or sequence in a randomize with statement before execution."}
{"type": "text", "page_from": 481, "page_to": 481, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=481", "section_title": "Sequence and Do Action", "content": "SEQUENCE ON SEQUENCEr ACTION MaCr Os"}
{"type": "text", "page_from": 481, "page_to": 481, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=481", "section_title": "Sequence and Do Action", "content": "These macros are used to start sequences and sequence items on a specific sequencer. The sequence or item is created and executed on the given sequencer."}
{"type": "text", "page_from": 481, "page_to": 481, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=481", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_create except that it also sets the parent sequence to the sequence in which the macro is invoked, and it sets the sequencer to the specified SEQR argument."}
{"type": "text", "page_from": 481, "page_to": 481, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=481", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_do except that it also sets the parent sequence to the sequence in which the macro is invoked, and it sets the sequencer to the specified SEQR argument."}
{"type": "text", "page_from": 482, "page_to": 482, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=482", "section_title": "Sequence and Do Action", "content": "sequence in which the macro is invoked, and it sets the sequencer to the specified SEQR argument."}
{"type": "text", "page_from": 482, "page_to": 482, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=482", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_do_with except that it also sets the parent sequence to the sequence in which the macro is invoked, and it sets the sequencer to the specified SEQR argument. The user must supply brackets around the constraints."}
{"type": "text", "page_from": 482, "page_to": 482, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=482", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_do_pri_with except that it also sets the parent sequence to the sequence in which the macro is invoked, and it sets the sequencer to the specified SEQR argument."}
{"type": "text", "page_from": 482, "page_to": 482, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=482", "section_title": "Sequence and Do Action", "content": "SEQUENCE ACTION MaCr Os FOr Pr E-EXIsTING SEQUENCEs"}
{"type": "text", "page_from": 482, "page_to": 482, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=482", "section_title": "Sequence and Do Action", "content": "These macros are used to start sequences and sequence items that do not need to be created."}
{"type": "text", "page_from": 482, "page_to": 482, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=482", "section_title": "Sequence and Do Action", "content": "This macro processes the item or sequence that has been created using \\`uvm_create. The processing is done without randomization. Essentially, an \\`uvm_do without the create or randomization."}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "This macro processes the item or sequence that has been already been allocated (possibly with \\`uvm_create). The processing is done with randomization. Essentially, an \\`uvm_do without the create."}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_rand_send except that the sequence item or sequence is executed with the priority specified in the argument."}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_rand_send except that the given constraint block is applied to the item or sequence in a randomize with statement before execution."}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "uvm_rand_send_pri_with"}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "This is the same as \\`uvm_rand_send_pri except that the given constraint block is applied to the item or sequence in a randomize with statement before execution."}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "uvm_add_to_sequence_library"}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "Adds the given sequence TYPE to the given sequence library LIBTYPE"}
{"type": "text", "page_from": 483, "page_to": 483, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=483", "section_title": "Sequence and Do Action", "content": "Invoke any number of times within a sequence declaration to statically add that sequence to one or more sequence library types. The sequence will then be available for selection and execution in all instances of the given sequencer types."}
{"type": "text", "page_from": 484, "page_to": 484, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=484", "section_title": "Sequence and Do Action", "content": "uvm_sequence_library_utils"}
{"type": "text", "page_from": 484, "page_to": 484, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=484", "section_title": "Sequence and Do Action", "content": "Declares the infrastructure needed to define extensions to the uvm_sequence_library class. You define new sequence library subtypes to statically specify sequence membership from within sequence definitions. See also \\`uvm_add_to_sequence_library for more information."}
{"type": "text", "page_from": 484, "page_to": 484, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=484", "section_title": "Sequence and Do Action", "content": "Each library, itself a sequence, can then be started independently on different sequencers or in different phases of the same sequencer. See uvm_sequencer_base::start_phase_sequence for information on starting default sequences."}
{"type": "text", "page_from": 484, "page_to": 484, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=484", "section_title": "Sequence and Do Action", "content": "uvm_declare_p_sequencer"}
{"type": "text", "page_from": 484, "page_to": 484, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=484", "section_title": "Sequence and Do Action", "content": "This macro is used to declare a variable p_sequencer whose type is specified by SEQUENCER."}
{"type": "text", "page_from": 484, "page_to": 484, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=484", "section_title": "Sequence and Do Action", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 485, "page_to": 485, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=485", "section_title": "Sequence and Do Action", "content": "The example below shows using the \\`uvm_declare_p_sequencer macro along with the uvm_object_utils macros to set up the sequence but not register the sequence in the sequencer’s library."}
{"type": "text", "page_from": 486, "page_to": 486, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=486", "section_title": "Callback Macros", "header_path": ["21", "4"], "chapter": "21", "section": "21.4", "content": "21.4 Callback Macros"}
{"type": "text", "page_from": 486, "page_to": 486, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=486", "section_title": "Callback Macros", "content": "These macros are used to register and execute callbacks extending from uvm_callbacks."}
{"type": "text", "page_from": 486, "page_to": 486, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=486", "section_title": "Callback Macros", "content": "These macros are used to register and execute callbacks extending from uvm_callbacks."}
{"type": "text", "page_from": 486, "page_to": 486, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=486", "section_title": "Callback Macros", "content": "\\`uvm_register_cb \\`uvm_set_super_type \\`uvm_do_callbacks \\`uvm_do_obj_callbacks \\`uvm_do_callbacks_exit_on \\`uvm_do_obj_callbacks_exit_on"}
{"type": "text", "page_from": 486, "page_to": 486, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=486", "section_title": "Callback Macros", "content": "Registers the given CB callback type with the given $\\tau$ object type. If a type-callback pair is not registered then a warning is issued if an attempt is made to use the pair (add, delete, etc.)."}
{"type": "text", "page_from": 486, "page_to": 486, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=486", "section_title": "Callback Macros", "content": "The registration will typically occur in the component that executes the given type of callback. For instance:"}
{"type": "text", "page_from": 487, "page_to": 487, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=487", "section_title": "Callback Macros", "content": "Defines the super type of $\\tau$ to be ST. This allows for derived class objects to inherit typewide callbacks that are registered with the base class."}
{"type": "text", "page_from": 487, "page_to": 487, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=487", "section_title": "Callback Macros", "content": "The registration will typically occur in the component that executes the given type of callback. For instance:"}
{"type": "text", "page_from": 487, "page_to": 487, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=487", "section_title": "Callback Macros", "content": "Calls the given METHOD of all callbacks of type $C B$ registered with the calling object (i.e. this object), which is or is based on type T."}
{"type": "text", "page_from": 487, "page_to": 487, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=487", "section_title": "Callback Macros", "content": "This macro executes all of the callbacks associated with the calling object (i.e. this object). The macro takes three arguments:"}
{"type": "text", "page_from": 487, "page_to": 487, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=487", "section_title": "Callback Macros", "content": "CB is the class type of the callback objects to execute. The class type must have a function signature that matches the METHOD argument. T is the type associated with the callback. Typically, an instance of type T is passed as one the arguments in the METHOD call. METHOD is the method call to invoke, with all required arguments as if they were invoked directly."}
{"type": "text", "page_from": 487, "page_to": 487, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=487", "section_title": "Callback Macros", "content": "For example, given the following callback class definition"}
{"type": "text", "page_from": 487, "page_to": 487, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=487", "section_title": "Callback Macros", "content": "A component would invoke the macro as"}
{"type": "text", "page_from": 488, "page_to": 488, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=488", "section_title": "Callback Macros", "content": "Calls the given METHOD of all callbacks based on type CB registered with the given object, OBJ, which is or is based on type T."}
{"type": "text", "page_from": 488, "page_to": 488, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=488", "section_title": "Callback Macros", "content": "This macro is identical to \\`uvm_do_callbacks macro, but it has an additional OBJ argument to allow the specification of an external object to associate the callback with. For example, if the callbacks are being applied in a sequence, OBJ could be specified as the associated sequencer or parent sequence."}
{"type": "text", "page_from": 488, "page_to": 488, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=488", "section_title": "Callback Macros", "content": "uvm_do_callbacks_exit_on"}
{"type": "text", "page_from": 488, "page_to": 488, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=488", "section_title": "Callback Macros", "content": "Calls the given METHOD of all callbacks of type CB registered with the calling object (i.e. this object), which is or is based on type $^ { T , }$ , returning upon the first callback returning the bit value given by VAL."}
{"type": "text", "page_from": 488, "page_to": 488, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=488", "section_title": "Callback Macros", "content": "This macro executes all of the callbacks associated with the calling object (i.e. this object). The macro takes three arguments:"}
{"type": "text", "page_from": 488, "page_to": 488, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=488", "section_title": "Callback Macros", "content": "CB is the class type of the callback objects to execute. The class type must have a function signature that matches the METHOD argument. T is the type associated with the callback. Typically, an instance of type T is passed as one the arguments in the METHOD call. METHOD is the method call to invoke, with all required arguments as if they were invoked directly. VAL, if 1, says return upon the first callback invocation that returns 1. If 0, says return upon the first callback invocation that returns 0."}
{"type": "text", "page_from": 488, "page_to": 488, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=488", "section_title": "Callback Macros", "content": "For example, given the following callback class definition"}
{"type": "text", "page_from": 489, "page_to": 489, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=489", "section_title": "Callback Macros", "content": "A component would invoke the macro as"}
{"type": "text", "page_from": 489, "page_to": 489, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=489", "section_title": "Callback Macros", "content": "Because this macro calls return, its use is restricted to implementations of functions that return a bit value, as in the above example."}
{"type": "text", "page_from": 489, "page_to": 489, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=489", "section_title": "Callback Macros", "content": "uvm_do_obj_callbacks_exit_on"}
{"type": "text", "page_from": 489, "page_to": 489, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=489", "section_title": "Callback Macros", "content": "Calls the given METHOD of all callbacks of type CB registered with the given object OBJ, which must be or be based on type $T ,$ and returns upon the first callback that returns the bit value given by VAL. It is exactly the same as the \\`uvm_do_callbacks_exit_on but has a specific object instance (instead of the implicit this instance) as the third argument."}
{"type": "text", "page_from": 489, "page_to": 489, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=489", "section_title": "Callback Macros", "content": "Because this macro calls return, its use is restricted to implementations of functions that return a bit value, as in the above example."}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Implementation Port Declaration Macros", "header_path": ["21", "5"], "chapter": "21", "section": "21.5", "content": "21.5 TLM Implementation Port Declaration Macros"}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Macros", "content": "The TLM implementation declaration macros provide a way for components to provide multiple implementation ports of the same implementation interface. When an implementation port is defined using the built-in set of imps, there must be exactly one implementation of the interface."}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Macros", "content": "For example, if a component needs to provide a put implementation then it would have an implementation port defined like:"}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Macros", "content": "There are times, however, when you need more than one implementation for an interface. This set of declarations allow you to easily create a new implementation class to allow for multiple implementations. Although the new implementation class is a different class, it can be bound to the same types of exports and ports as the original class. Extending the put example above, let’s say that mycomp needs to provide two put implementation ports. In that case, you would do something like:"}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Macros", "content": "The important thing to note is that each \\`uvm_<interface>_imp_decl creates a new class of type uvm_<interface>_imp $<$ <suffix>, where suffix is the input argument to the macro. For this reason, you will typically want to put these macros in a separate package to avoid collisions and to allow sharing of the definitions."}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Macros", "content": "TLM Implementation Port Declaration Macros"}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Macros", "content": "The TLM implementation declaration macros provide a way for components to provide multiple implementation ports of the same implementation interface."}
{"type": "text", "page_from": 490, "page_to": 490, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=490", "section_title": "TLM Macros", "content": "\\`uvm_blocking_put_imp_decl \\`uvm_nonblocking_put_imp_decl \\`uvm_put_imp_decl \\`uvm_blocking_get_imp_decl"}
{"type": "text", "page_from": 491, "page_to": 491, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=491", "section_title": "TLM Macros", "content": "\\`uvm_nonblocking_get_imp_decl \\`uvm_get_imp_decl \\`uvm_blocking_peek_imp_decl \\`uvm_nonblocking_peek_imp_decl \\`uvm_peek_imp_decl \\`uvm_blocking_get_peek_imp_decl \\`uvm_nonblocking_get_peek_imp_decl \\`uvm_get_peek_imp_decl \\`uvm_blocking_master_imp_decl \\`uvm_nonblocking_master_imp_decl \\`uvm_master_imp_decl \\`uvm_blocking_slave_imp_decl \\`uvm_nonblocking_slave_imp_decl \\`uvm_slave_imp_decl \\`uvm_blocking_transport_imp_decl \\`uvm_nonblocking_transport_imp_decl \\`uvm_transport_imp_decl \\`uvm_analysis_imp_decl"}
{"type": "text", "page_from": 491, "page_to": 491, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=491", "section_title": "TLM Macros", "content": "\\`uvm_blocking_put_imp_decl"}
{"type": "text", "page_from": 491, "page_to": 491, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=491", "section_title": "TLM Macros", "content": "Define the class uvm_blocking_put_impSFX for providing blocking put implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 491, "page_to": 491, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=491", "section_title": "TLM Macros", "content": "uvm_nonblocking_put_imp_decl"}
{"type": "text", "page_from": 491, "page_to": 491, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=491", "section_title": "TLM Macros", "content": "Define the class uvm_nonblocking_put_impSFX for providing non-blocking put implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "Define the class uvm_blocking_get_impSFX for providing blocking get implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "uvm_nonblocking_get_imp_decl"}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "Define the class uvm_nonblocking_get_impSFX for providing non-blocking get implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "Define the class uvm_get_impSFX for providing both blocking and non-blocking get implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "uvm_blocking_peek_imp_decl"}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "Define the class uvm_blocking_peek_impSFX for providing blocking peek implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "uvm_nonblocking_peek_imp_decl"}
{"type": "text", "page_from": 492, "page_to": 492, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=492", "section_title": "TLM Macros", "content": "Define the class uvm_nonblocking_peek_impSFX for providing non-blocking peek implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "Define the class uvm_peek_impSFX for providing both blocking and non-blocking peek implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "\\`uvm_blocking_get_peek_imp_decl"}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "Define the class uvm_blocking_get_peek_impSFX for providing the blocking get_peek implementation."}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "\\`uvm_nonblocking_get_peek_imp_decl"}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "Define the class uvm_nonblocking_get_peek_impSFX for providing non-blocking get_peek implementation."}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "uvm_get_peek_imp_decl"}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "Define the class uvm_get_peek_impSFX for providing both blocking and non-blocking get_peek implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "uvm_blocking_master_imp_decl"}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "Define the class uvm_blocking_master_impSFX for providing the blocking master implementation."}
{"type": "text", "page_from": 493, "page_to": 493, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=493", "section_title": "TLM Macros", "content": "uvm_nonblocking_master_imp_decl"}
{"type": "text", "page_from": 494, "page_to": 494, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=494", "section_title": "TLM Macros", "content": "Define the class uvm_nonblocking_master_impSFX for providing the non-blocking master implementation."}
{"type": "text", "page_from": 494, "page_to": 494, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=494", "section_title": "TLM Macros", "content": "Define the class uvm_master_impSFX for providing both blocking and non-blocking master implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 494, "page_to": 494, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=494", "section_title": "TLM Macros", "content": "uvm_blocking_slave_imp_decl"}
{"type": "text", "page_from": 494, "page_to": 494, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=494", "section_title": "TLM Macros", "content": "Define the class uvm_blocking_slave_impSFX for providing the blocking slave implementation."}
{"type": "text", "page_from": 494, "page_to": 494, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=494", "section_title": "TLM Macros", "content": "uvm_nonblocking_slave_imp_decl"}
{"type": "text", "page_from": 494, "page_to": 494, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=494", "section_title": "TLM Macros", "content": "Define the class uvm_nonblocking_slave_impSFX for providing the non-blocking slave implementation."}
{"type": "text", "page_from": 495, "page_to": 495, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=495", "section_title": "TLM Macros", "content": "Define the class uvm_blocking_transport_impSFX for providing the blocking transport implementation."}
{"type": "text", "page_from": 495, "page_to": 495, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=495", "section_title": "TLM Macros", "content": "uvm_nonblocking_transport_imp_decl"}
{"type": "text", "page_from": 495, "page_to": 495, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=495", "section_title": "TLM Macros", "content": "Define the class uvm_nonblocking_transport_impSFX for providing the non-blocking transport implementation."}
{"type": "text", "page_from": 495, "page_to": 495, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=495", "section_title": "TLM Macros", "content": "uvm_transport_imp_decl"}
{"type": "text", "page_from": 495, "page_to": 495, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=495", "section_title": "TLM Macros", "content": "Define the class uvm_transport_impSFX for providing both blocking and non-blocking transport implementations. SFX is the suffix for the new class type."}
{"type": "text", "page_from": 495, "page_to": 495, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=495", "section_title": "TLM Macros", "content": "uvm_analysis_imp_decl"}
{"type": "text", "page_from": 495, "page_to": 495, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=495", "section_title": "TLM Macros", "content": "Define the class uvm_analysis_impSFX for providing an analysis implementation. SFX is the suffix for the new class type. The analysis implementation is the write function. The \\`uvm_analysis_imp_decl allows for a scoreboard (or other analysis component) to support input from many places. For example:"}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "header_path": ["21", "6"], "chapter": "21", "section": "21.6", "content": "21.6 Register Defines"}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "\\`UVM_REG_ADDR_WIDTH"}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "Maximum address width in bits Default value is 64. Used to define the uvm_reg_addr_t type."}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "\\`UVM_REG_DATA_WIDTH"}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "Maximum data width in bits"}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "Default value is 64. Used to define the uvm_reg_data_t type."}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "\\`UVM_REG_BYTENABLE_WIDTH"}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "Maximum number of byte enable bits"}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "Default value is one per byte in \\`UVM_REG_DATA_WIDTH. Used to define the uvm_reg_byte_en_t type."}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "Maximum number of bits in a uvm_reg_cvr_t coverage model set."}
{"type": "text", "page_from": 496, "page_to": 496, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=496", "section_title": "Register Defines", "content": "Default value is 32."}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "These macros provide the current values for the MAJOR, MINOR, and optionally the FIX revision."}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "Example with UVM version 1.2"}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "UVM_MAJOR_REV ’1’ UVM_MINOR_REV $_ { 2 ^ { \\prime } }$ UVM_FIX_REV ’undefined’"}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "Example with UVM version 1.1a"}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "UVM_MAJOR_REV $\\prime _ { 1 } \\prime _ { }$ UVM_MINOR_REV ’1’ UVM_FIX_REV ’a’"}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "Defines the MAJOR revision number."}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "For UVM version 1.2, the MAJOR revision number is ‘1’"}
{"type": "text", "page_from": 497, "page_to": 497, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=497", "section_title": "Version Defines", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "Defines the MINOR revision number."}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "For UVM version 1.2, the MINOR revision number is ‘2’"}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "(Optionally) Defines the FIX revision letter."}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "For the first $\\because \\mathsf { X } . \\mathsf { Y } ^ { \\prime \\prime }$ release of the UVM, there is no FIX revision letter. In these cases, the UVM_FIX_REV is left undefined."}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "For any subsequent $\\because \\mathsf { X } . \\mathsf { Y } ^ { \\prime \\prime }$ fix releases, the UVM_FIX_REV value is set to the appropriate fix release letter."}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "First release, UVM_FIX_REV is undefined 1.1a Fix release, UVM_FIX_REV is ‘a’", "header_path": ["1", "1"], "chapter": "1", "section": "1.1", "content": "1.1 First release, UVM_FIX_REV is undefined 1.1a Fix release, UVM_FIX_REV is ‘a’"}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "The name used by the library when displaying the name of the library."}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "UVM_VERSION _STRIN G"}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "Provides a string-ized version of the UVM Library version number."}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "When there is a FIX_REV, the string is “<name>-<major>.<minor><fix>” (such as “UVM-1.1d”). When there is NO FIX_REV, the string is “<name>-<major>.<minor>” (such as $\\ \" \\cup \\lor \\mathsf { M } - 1 . 2 \\prime \\big )$ )."}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "CONdITIONAL COmPILATION"}
{"type": "text", "page_from": 498, "page_to": 498, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=498", "section_title": "Version Defines", "content": "These macros provide the ability to conditionally compile based on the revision of the library which is being used."}
{"type": "text", "page_from": 499, "page_to": 499, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=499", "section_title": "Version Defines", "content": "These macros are required for conditional compilation, as SystemVerilog does not support conditionals with \\`ifdefs."}
{"type": "text", "page_from": 499, "page_to": 499, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=499", "section_title": "Version Defines", "content": "Indicates that the MAJOR version of this release is $\\because 1 ^ { \\prime }$ ."}
{"type": "text", "page_from": 499, "page_to": 499, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=499", "section_title": "Version Defines", "content": "Indicates that the MINOR version of this release is $\\because$ ."}
{"type": "text", "page_from": 499, "page_to": 499, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=499", "section_title": "Version Defines", "content": "Indicates that the version of this release is $\\because 1 . 2 ^ { \\prime }$ ."}
{"type": "text", "page_from": 499, "page_to": 499, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=499", "section_title": "Version Defines", "content": "UVM_PO ST_VERSION _1_1"}
{"type": "text", "page_from": 499, "page_to": 499, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=499", "section_title": "Version Defines", "content": "Indicates that this version of the UVM came after the 1.1 versions, including the various 1.1 fix revisions."}
{"type": "text", "page_from": 499, "page_to": 499, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=499", "section_title": "Version Defines", "content": "The first UVM version wherein this macro is defined is 1.2, and the macro will continue to be defined for all future revisions of the UVM library."}
{"type": "text", "page_from": 500, "page_to": 500, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=500", "section_title": "Policies", "content": "Each of UVM’s policy classes perform a specific task for uvm_object-based objects: printing, comparing, recording, packing, and unpacking. They are implemented separately from uvm_object so that users can plug in different ways to print, compare, etc. without modifying the object class being operated on. The user can simply apply a different printer or compare “policy” to change how an object is printed or compared."}
{"type": "text", "page_from": 500, "page_to": 500, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=500", "section_title": "Policies", "content": "Each policy class includes several user-configurable parameters that control the operation. Users may also customize operations by deriving new policy subtypes from these base types. For example, the UVM provides four different uvm_printer-based policy classes, each of which print objects in a different format."}
{"type": "text", "page_from": 500, "page_to": 500, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=500", "section_title": "Policies", "content": "uvm_printer - performs deep printing of uvm_object-based objects. The UVM provides several subtypes to uvm_printer that print objects in a specific format: uvm_table_printer, uvm_tree_printer, and uvm_line_printer. Each such printer has many configuration options that govern what and how object members are printed. uvm_comparer - performs deep comparison of uvm_object-based objects. Users may configure what is compared and how miscompares are reported. uvm_recorder - performs the task of recording uvm_object-based objects to a transaction data base. The implementation is vendor-specific. uvm_packer - used to pack (serialize) and unpack uvm_object-based properties into bit, byte, or int arrays and back again."}
{"type": "text", "page_from": 500, "page_to": 500, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=500", "section_title": "Policies", "content": "Each of UVM’s policy classes perform a specific task for uvm_object-based objects: printing, comparing, recording, packing, and unpacking."}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "The uvm_printer class provides an interface for printing uvm_objects in various formats. Subtypes of uvm_printer implement different print formats, or policies."}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "A user-defined printer format can be created, or one of the following four built-in printers can be used:"}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "uvm_printer - provides base printer functionality; must be overridden. uvm_table_printer - prints the object in a tabular form. uvm_tree_printer - prints the object in a tree form. uvm_line_printer - prints the information on a single line, but uses the same object separators as the tree printer."}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "Printers have knobs that you use to control what and how information is printed. These knobs are contained in a separate knob class:"}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "uvm_printer_knobs - common printer settings"}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "For convenience, global instances of each printer type are available for direct reference in your testbenches."}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "uvm_default_tree_printer uvm_default_line_printer uvm_default_table_printer uvm_default_printer (set to default_table_printer by default)"}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "When uvm_object::print and uvm_object::sprint are called without specifying a printer, the uvm_default_printer is used."}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "uvm_printer_knobs knobs $=$ new"}
{"type": "text", "page_from": 501, "page_to": 501, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=501", "section_title": "uvm_printer", "content": "The knob object provides access to the variety of knobs associated with a specific printer instance."}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "virtual function void print_field ( string name, uvm_bitstream_t value, int size, uvm_radix_enum radix $=$ UVM_NORADIX, byte string scope_separator type_name $=$ $=$ \".\" , )"}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "Prints an integral field (up to 4096 bits)."}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "name The name of the field. value The value of the field. size The number of bits of the field (maximum is 4096). radix The radix to use for printing. The printer knob for radix is used if no radix is specified. scope_separator is used to find the leaf name since many printers only print the leaf name of a field. Typical values for the separator are . (dot) or [ (open bracket)."}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "virtual function void print_field_int ( string name, uvm_integral_t value, int size, uvm_radix_enum radix $=$ UVM_NORADIX, byte string scope_separator type_name $=$ \".\", $=$"}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "Prints an integral field (up to 64 bits)."}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "name The name of the field. value The value of the field. size The number of bits of the field (maximum is 64). radix The radix to use for printing. The printer knob for radix is used if no radix is specified. scope_separator is used to find the leaf name since many printers only print the leaf name of a field. Typical values for the separator are . (dot) or [ (open bracket)."}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "virtual function void print_object ( string name, uvm_object value, byte scope_separator ="}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "Prints an object. Whether the object is recursed depends on a variety of knobs, such as the depth knob; if the current depth is at or below the depth setting, then the object is not recursed."}
{"type": "text", "page_from": 502, "page_to": 502, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=502", "section_title": "uvm_printer", "content": "By default, the children of uvm_components are printed. To turn this behavior off, you must set the uvm_component::print_enabled bit to 0 for the specific children you do not want automatically printed."}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "virtual function void print_string string name, string value, byte scope_separator"}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "Prints a string field."}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "virtual function void print_time ( string name, time value, byte scope_separator ."}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "Prints a time value. name is the name of the field, and value is the value to print."}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "The print is subject to the $\\$ 1$ timeformat system task for formatting time values."}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "virtual function void print_real ( string name, real value, byte scope_separator"}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "Prints a real field."}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "virtual function void print_generic ( string name, string type_name, int size, string value, byte scope_separator = \".\""}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "Prints a field having the given name, type_name, size, and value."}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "METHODS FOR PRINTER SUBTYPING"}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "virtual function string emit ()"}
{"type": "text", "page_from": 503, "page_to": 503, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=503", "section_title": "uvm_printer", "content": "Emits a string representing the contents of an object in a format defined by an extension of this object."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "virtual function string format_row ( uvm_printer_row_info row"}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "Hook for producing custom output of a single field (row)."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "Hook to override base header with a custom header."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "Hook to override base footer with a custom footer."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "virtual protected function string adjust_name ( string id, byte scope_separator = \". )"}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "Prints a field’s name, or $i d _ { \\iota }$ , which is the full instance name."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "The intent of the separator is to mark where the leaf name starts if the printer if configured to print only the leaf name of the identifier."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "virtual function void print_array_header( string name, int size, string arraytype $=$ \"array\", byte scope_separator $=$ )"}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "Prints the header of an array. This function is called before each individual element is printed. print_array_footer is called to mark the completion of array printing."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "virtual function void print_array_range ( int min, int max"}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "Prints a range using ellipses for values. This method is used when honoring the array knobs for partial printing of large arrays, uvm_printer_knobs::begin_elements and uvm_printer_knobs::end_elements."}
{"type": "text", "page_from": 504, "page_to": 504, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=504", "section_title": "uvm_printer", "content": "This function should be called after begin_elements have been printed and before end_elements have been printed."}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "virtual function void print_array_footer ( int size = )"}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "Prints the header of a footer. This function marks the end of an array print. Generally, there is no output associated with the array footer, but this method let’s the printer know that the array printing is complete."}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "The table printer prints output in a tabular format."}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "The following shows sample output from the table printer."}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "The table printer prints output in a tabular format."}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "class uvm_table_printer extends uvm_printer"}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "new Creates a new instance of uvm_table_printer."}
{"type": "text", "page_from": 505, "page_to": 505, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=505", "section_title": "uvm_printer", "content": "emit Formats the collected information from prior calls to print_\\* into table format."}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "Creates a new instance of uvm_table_printer."}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "virtual function string emit()"}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "Formats the collected information from prior calls to print_\\* into table format."}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "By overriding various methods of the uvm_printer super class, the tree printer prints output in a tree format."}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "The following shows sample output from the tree printer."}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "By overriding various methods of the uvm_printer super class, the tree printer prints output in a tree format."}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "class uvm_tree_printer extends uvm_printer"}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "new Creates a new instance of uvm_tree_printer."}
{"type": "text", "page_from": 506, "page_to": 506, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=506", "section_title": "uvm_printer", "content": "mit Formats the collected information from prior calls to print_\\* into hierarchical tree format."}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "Creates a new instance of uvm_tree_printer."}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "virtual function string emit()"}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "Formats the collected information from prior calls to print_\\* into hierarchical tree format."}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "The line printer prints output in a line format."}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "The following shows sample output from the line printer."}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "c1: (container@1013) { d1: (mydata@1022) { v1: 'hcb8f1c97 e1: THREE str: hi value: 'h2d }"}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "The line printer prints output in a line format."}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "class uvm_line_printer extends uvm_tree_printer"}
{"type": "text", "page_from": 507, "page_to": 507, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=507", "section_title": "uvm_printer", "content": "new Creates a new instance of uvm_line_printer."}
{"type": "text", "page_from": 508, "page_to": 508, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=508", "section_title": "uvm_printer", "content": "Creates a new instance of uvm_line_printer. It differs from the uvm_tree_printer only in that the output contains no line-feeds and indentation."}
{"type": "text", "page_from": 508, "page_to": 508, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=508", "section_title": "uvm_printer", "content": "The uvm_printer_knobs class defines the printer settings available to all printer subtypes."}
{"type": "text", "page_from": 508, "page_to": 508, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=508", "section_title": "uvm_printer", "content": "The uvm_printer_knobs class defines the printer settings available to all printer subtypes."}
{"type": "text", "page_from": 508, "page_to": 508, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=508", "section_title": "uvm_printer", "content": "class uvm_printer_knobs"}
{"type": "text", "page_from": 509, "page_to": 509, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=509", "section_title": "uvm_printer", "content": "bit header $\\qquad = \\quad 1$"}
{"type": "text", "page_from": 509, "page_to": 509, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=509", "section_title": "uvm_printer", "content": "Indicates whether the uvm_printer::format_header function should be called when printing an object."}
{"type": "text", "page_from": 509, "page_to": 509, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=509", "section_title": "uvm_printer", "content": "bit footer $\\qquad = \\quad 1$"}
{"type": "text", "page_from": 509, "page_to": 509, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=509", "section_title": "uvm_printer", "content": "Indicates whether the uvm_printer::format_footer function should be called when printing an object."}
{"type": "text", "page_from": 509, "page_to": 509, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=509", "section_title": "uvm_printer", "content": "Indicates whether uvm_printer::adjust_name should print the full name of an identifier or just the leaf name."}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "Controls whether to print a field’s size."}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "int depth $\\begin{array} { r l } { \\mathbf { \\Sigma } } & { { } = \\mathbf { \\Sigma } - \\mathbb { 1 } } \\end{array}$"}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "Indicates how deep to recurse when printing objects. A depth of -1 means to print everything."}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "Controls whether to print a unique reference ID for object handles. The behavior of this knob is simulator-dependent."}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "int begin_elements $\\ c = 5$"}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "Defines the number of elements at the head of a list to print. Use -1 for no max."}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "int end_elements = 5"}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "This defines the number of elements at the end of a list that should be printed."}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "string prefix $=$ \"\""}
{"type": "text", "page_from": 510, "page_to": 510, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=510", "section_title": "uvm_printer", "content": "Specifies the string prepended to each output line"}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "This setting indicates whether or not the initial object that is printed (when current depth is 0) prints the full path name. By default, the first object is treated like all other objects and only the leaf name is printed."}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "int mcd $=$ UVM_STDOUT"}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "This is a file descriptor, or multi-channel descriptor, that specifies where the print output should be directed."}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "By default, the output goes to the standard output of the simulator."}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "string separator $=$ \"{}\""}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "For tree printers only, determines the opening and closing separators used for nested objects."}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "Indicates whether the radix string ${ \\mathrm { ( \\ ` h , } }$ and so on) should be prepended to an integral value when one is printed."}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "uvm_radix_enum default_radix $=$ UVM_HEX"}
{"type": "text", "page_from": 511, "page_to": 511, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=511", "section_title": "uvm_printer", "content": "This knob sets the default radix to use for integral values when no radix enum is explicitly supplied to the uvm_printer::print_field or uvm_printer::print_field_int methods."}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "This string should be prepended to the value of an integral type when a radix of UVM_BIN is used for the radix of the integral object."}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "string oct_radix $=$ \"'o\""}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "This string should be prepended to the value of an integral type when a radix of UVM_OCT is used for the radix of the integral object."}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "string unsigned_radix $=$ \"'d\""}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "This is the string which should be prepended to the value of an integral type when a radix of UVM_UNSIGNED is used for the radix of the integral object."}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "string hex_radix = \"'h\""}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "This string should be prepended to the value of an integral type when a radix of UVM_HEX is used for the radix of the integral object."}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "function string get_radix_str( uvm_radix_enum radix )"}
{"type": "text", "page_from": 512, "page_to": 512, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=512", "section_title": "uvm_printer", "content": "Converts the radix from an enumerated to a printable radix according to the radix printing knobs (bin_radix, and so on)."}
{"type": "text", "page_from": 513, "page_to": 513, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=513", "section_title": "uvm_comparer", "content": "The uvm_comparer class provides a policy object for doing comparisons. The policies determine how miscompares are treated and counted. Results of a comparison are stored in the comparer object. The uvm_object::compare and uvm_object::do_compare methods are passed a uvm_comparer policy object."}
{"type": "text", "page_from": 513, "page_to": 513, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=513", "section_title": "uvm_comparer", "content": "The uvm_comparer class provides a policy object for doing comparisons."}
{"type": "text", "page_from": 513, "page_to": 513, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=513", "section_title": "uvm_comparer", "content": "uvm_recursion_policy_enum policy $=$ UVM_DEFAULT_POLICY"}
{"type": "text", "page_from": 513, "page_to": 513, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=513", "section_title": "uvm_comparer", "content": "Determines whether comparison is UVM_DEEP, UVM_REFERENCE, or UVM_SHALLOW."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "int unsigned show_max $\\qquad = \\quad 1$"}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "Sets the maximum number of messages to send to the printer for miscompares of an object."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "int unsigned verbosity $=$ UVM_LOW"}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "Sets the verbosity for printed messages."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "The verbosity setting is used by the messaging mechanism to determine whether messages should be suppressed or shown."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "uvm_severity sev $=$ UVM_INFO"}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "Sets the severity for printed messages."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "The severity setting is used by the messaging mechanism for printing and filtering messages."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "string miscompares $=$ \"\""}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "This string is reset to an empty string when a comparison is started."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "The string holds the last set of miscompares that occurred during a comparison."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "This bit provides a filtering mechanism for fields."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "The abstract and physical settings allow an object to distinguish between two different classes of fields."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "It is up to you, in the uvm_object::do_compare method, to test the setting of this field if you want to use the physical trait as a filter."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "bit abstract $\\qquad = \\quad 1$"}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "This bit provides a filtering mechanism for fields."}
{"type": "text", "page_from": 514, "page_to": 514, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=514", "section_title": "uvm_comparer", "content": "The abstract and physical settings allow an object to distinguish between two different"}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "It is up to you, in the uvm_object::do_compare method, to test the setting of this field if you want to use the abstract trait as a filter."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "This bit determines whether the type, given by uvm_object::get_type_name, is used to verify that the types of two objects are the same."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "This bit is used by the compare_object method. In some cases it is useful to set this to 0 when the two operands are related by inheritance but are different types."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "int unsigned result $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "This bit stores the number of miscompares for a given compare operation. You can use the result to determine the number of miscompares that were found."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "Compares two integral values."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "The name input is used for purposes of storing and printing a miscompare."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "The left-hand-side lhs and right-hand-side rhs objects are the two objects used for comparison."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "The size variable indicates the number of bits to compare; size must be less than or equal to 4096."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "The radix is used for reporting purposes, the default radix is hex."}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "virtual function bit compare_field_int ( string name, uvm_integral_t lhs, uvm_integral_t rhs, int size, uvm_radix_enum radix $=$ UVM_NORADIX"}
{"type": "text", "page_from": 515, "page_to": 515, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=515", "section_title": "uvm_comparer", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "This method is the same as compare_field except that the arguments are small integers, less than or equal to 64 bits. It is automatically called by compare_field if the operand size is less than or equal to 64."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "This method is the same as compare_field except that the arguments are real numbers."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "Compares two class objects using the policy knob to determine whether the comparison should be deep, shallow, or reference."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "The name input is used for purposes of storing and printing a miscompare."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "The lhs and rhs objects are the two objects used for comparison."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "The check_type determines whether or not to verify the object types match (the return from lhs.get_type_name() matches rhs.get_type_name())."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "virtual function bit compare_string ( string name, string lhs, string rhs"}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "Compares two string variables."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "The name input is used for purposes of storing and printing a miscompare."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "The lhs and rhs objects are the two objects used for comparison."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "Causes the error count to be incremented and the message, msg, to be appended to the miscompares string (a newline is used to separate messages)."}
{"type": "text", "page_from": 516, "page_to": 516, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=516", "section_title": "uvm_comparer", "content": "If the message count is less than the show_max setting, then the message is printed to standard-out using the current verbosity and severity settings. See the verbosity and sev variables for more information."}
{"type": "text", "page_from": 517, "page_to": 517, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=517", "section_title": "uvm_recorder", "content": "The uvm_recorder class serves two purposes"}
{"type": "text", "page_from": 517, "page_to": 517, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=517", "section_title": "uvm_recorder", "content": "Firstly, it is an abstract representation of a record within a uvm_tr_stream. Secondly, it is a policy object for recording fields into that record within the stream."}
{"type": "text", "page_from": 517, "page_to": 517, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=517", "section_title": "uvm_recorder", "content": "uvm_recorder Abstract class which defines the recorder API. uvm_text_recorder The uvm_text_recorder is the default recorder implementation for the uvm_text_tr_database."}
{"type": "text", "page_from": 517, "page_to": 517, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=517", "section_title": "uvm_recorder", "content": "Abstract class which defines the recorder API."}
{"type": "text", "page_from": 517, "page_to": 517, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=517", "section_title": "uvm_recorder", "content": "Abstract class which defines the recorder API."}
{"type": "text", "page_from": 518, "page_to": 518, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=518", "section_title": "uvm_recorder", "content": "uvm_radix_enum default_radix $=$ UVM_HEX"}
{"type": "text", "page_from": 518, "page_to": 518, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=518", "section_title": "uvm_recorder", "content": "This is the default radix setting if record_field is called without a radix."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "bit abstract $\\qquad = \\quad 1$"}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "This bit provides a filtering mechanism for fields."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "The abstract and physical settings allow an object to distinguish between two different classes of fields."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "It is up to you, in the uvm_object::do_record method, to test the setting of this field if you want to use the abstract trait as a filter."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "bit identifier $\\ c = ~ 1$"}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "This bit is used to specify whether or not an object’s reference should be recorded when the object is recorded."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "uvm_recursion_policy_enum policy $=$ UVM_DEFAULT_POLICY"}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "Sets the recursion policy for recording objects."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "The default policy is deep (which means to recurse an object)."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "function uvm_tr_stream get_stream()"}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "Returns a reference to the stream which created this record."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "A warning will be asserted if get_stream is called prior to the record being initialized via do_open."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "Tr ANsAct ION REcOrd Er API"}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "Once a recorder has been opened via uvm_tr_stream::open_recorder, the user can close the recorder."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "Due to the fact that many database implementations will require crossing a language boundary, an additional step of freeing the recorder is required."}
{"type": "text", "page_from": 519, "page_to": 519, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=519", "section_title": "uvm_recorder", "content": "A link can be established within the database any time between open and free, however it is illegal to establish a link after freeing the recorder."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "function void close( time close_time"}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "Closes this recorder."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "Closing a recorder marks the end of the transaction in the stream."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "close_time Optional time to record as the closing time of this transaction."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "This method will trigger a do_close call."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "Freeing a recorder indicates that the stream and database can release any references to the recorder."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "close_time Optional time to record as the closing time of this transaction."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "If a recorder has not yet been closed (via a call to close), then close will automatically be called, and passed the close_time. If the recorder has already been closed, then the close_time will be ignored."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "This method will trigger a do_free call."}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "function bit is_open()"}
{"type": "text", "page_from": 520, "page_to": 520, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=520", "section_title": "uvm_recorder", "content": "Returns true if this uvm_recorder was opened on its stream, but has not yet been closed."}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "function time get_close_time()"}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "Returns the close_time"}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "function integer get_handle()"}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "Returns a unique ID for this recorder."}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "A value of $o$ indicates that the recorder has been freed, and no longer has a valid ID."}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "get_recorder_from_handle"}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "Static accessor, returns a recorder reference for a given unique id."}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "If no recorder exists with the given id, or if the recorder with that id has been freed, then null is returned."}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "This method can be used to access the recorder associated with a call to uvm_transaction::begin_tr or uvm_component::begin_tr."}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "function void record_field( string name, uvm_bitstream_t value, int size, uvm_radix_enum radix $=$ UVM_NORADIX )"}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "Records an integral field (less than or equal to 4096 bits)."}
{"type": "text", "page_from": 521, "page_to": 521, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=521", "section_title": "uvm_recorder", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "name Name of the field value Value of the field to record. size Number of bits of the field which apply (Usually obtained via $\\$ 9$ bits). radix The uvm_radix_enum to use."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "This method will trigger a do_record_field call."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "function void record_field_int( string name, uvm_integral_t value, int size, uvm_radix_enum radix $=$ UVM_NORADIX"}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "Records an integral field (less than or equal to 64 bits)."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "This optimized version of record_field is useful for sizes up to 64 bits."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "name Name of the field value Value of the field to record size Number of bits of the wfield which apply (Usually obtained via \\$bits). radix The uvm_radix_enum to use."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "This method will trigger a do_record_field_int call."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "function void record_field_real( string name, real value"}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "Records a real field."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "name Name of the field value Value of the field to record"}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "This method will trigger a do_record_field_real call."}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "function void record_object( string name, uvm_object value )"}
{"type": "text", "page_from": 522, "page_to": 522, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=522", "section_title": "uvm_recorder", "content": "Records an object field."}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "name Name of the field value Object to record"}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "The implementation must use the recursion_policy and identifier to determine exactly what should be recorded."}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "function void record_string( string name, string value"}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "Records a string field."}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "name Name of the field value Value of the field"}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "function void record_time( string name, time value"}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "Records a time field."}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "name Name of the field value Value of the field"}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "function void record_generic( string name, string value, string type_name )"}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "Records a name/value pair, where value has been converted to a string."}
{"type": "text", "page_from": 523, "page_to": 523, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=523", "section_title": "uvm_recorder", "content": "name Name of the field value Value of the field"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "type_name optional Type name of the field"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "use_record_attribute"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "virtual function bit use_record_attribute()"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "Indicates that this recorder does (or does not) support usage of the \\`uvm_record_attribute macro."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "The default return value is $o$ (not supported), developers can optionally extend uvm_recorder and set the value to 1 if they support the \\`uvm_record_attribute macro."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "get_record_attribute_handle"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "virtual function integer get_record_attribute_handle()"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "Provides a tool-specific handle which is compatible with \\`uvm_record_attribute."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "By default, this method will return the same value as get_handle, however tool vendors can override this method to provide tool-specific handles which will be passed to the \\`uvm_record_attribute macro."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "Imp LEmENt At ION AGNOst Ic API"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "Callback triggered via uvm_tr_stream::open_recorder."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "The do_open callback can be used to initialize any internal state within the recorder, as well as providing a location to record any initial information."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "protected virtual function void do_close( time close_time"}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "Callback triggered via close."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "The do_close callback can be used to set internal state within the recorder, as well as providing a location to record any closing information."}
{"type": "text", "page_from": 524, "page_to": 524, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=524", "section_title": "uvm_recorder", "content": "protected virtual function void do_free()"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Callback triggered via free."}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "The do_free callback can be used to release the internal state within the recorder, as well as providing a location to record any “freeing” information."}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "pure virtual protected function void do_record_field( string name, uvm_bitstream_t value, int size, uvm_radix_enum radix"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Records an integral field (less than or equal to 4096 bits)."}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Mandatory Backend implementation of record_field"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "pure virtual protected function void do_record_field_int( string name, uvm_integral_t value, int size, uvm_radix_enum radix"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Records an integral field (less than or equal to 64 bits)."}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Mandatory Backend implementation of record_field_int"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "do_record_field_real"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Records a real field."}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Mandatory Backend implementation of record_field_real"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Records an object field."}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "Mandatory Backend implementation of record_object"}
{"type": "text", "page_from": 525, "page_to": 525, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=525", "section_title": "uvm_recorder", "content": "pure virtual protected function void do_record_string( string name,"}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "Records a string field."}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "Mandatory Backend implementation of record_string"}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "Records a time field."}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "Mandatory Backend implementation of record_time"}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "pure virtual protected function void do_record_generic( string name, string value, string type_name"}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "Records a name/value pair, where value has been converted to a string."}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "Mandatory Backend implementation of record_generic"}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "The uvm_text_recorder is the default recorder implementation for the uvm_text_tr_database."}
{"type": "text", "page_from": 526, "page_to": 526, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=526", "section_title": "uvm_recorder", "content": "The uvm_text_recorder is the default recorder implementation for the uvm_text_tr_database."}
{"type": "text", "page_from": 527, "page_to": 527, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=527", "section_title": "uvm_recorder", "content": "Imp LEmENt At ION AGNOst Ic API"}
{"type": "text", "page_from": 527, "page_to": 527, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=527", "section_title": "uvm_recorder", "content": "do_open protected virtual function void do_open( uvm_tr_stream stream, time open_time, string type_name"}
{"type": "text", "page_from": 527, "page_to": 527, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=527", "section_title": "uvm_recorder", "content": "Callback triggered via uvm_tr_stream::open_recorder."}
{"type": "text", "page_from": 527, "page_to": 527, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=527", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 527, "page_to": 527, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=527", "section_title": "uvm_recorder", "content": "protected virtual function void do_close( time close_time"}
{"type": "text", "page_from": 527, "page_to": 527, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=527", "section_title": "uvm_recorder", "content": "Callback triggered via uvm_recorder::close."}
{"type": "text", "page_from": 527, "page_to": 527, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=527", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "protected virtual function void do_free()"}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Callback triggered via uvm_recorder::free."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "protected virtual function void do_record_field( string name, uvm_bitstream_t value, int size, uvm_radix_enum radix"}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Records an integral field (less than or equal to 4096 bits)."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "protected virtual function void do_record_field_int( string name, uvm_integral_t value, int size, uvm_radix_enum radix"}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Records an integral field (less than or equal to 64 bits)."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "do_record_field_real"}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Record a real field."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Text-backened specific implementation."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Record an object field."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 528, "page_to": 528, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=528", "section_title": "uvm_recorder", "content": "The method uses identifier to determine whether or not to record the object instance id,"}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "and recursion_policy to determine whether or not to recurse into the object."}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Records a string field."}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "protected virtual function void do_record_time( string name, time value"}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Records a time field."}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "protected virtual function void do_record_generic( string name, string value, string type_name"}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Records a name/value pair, where value has been converted to a string."}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Text-backend specific implementation."}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Imp LEmENt At ION SpEcIFIc API"}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "Outputs an integral attribute to the textual log"}
{"type": "text", "page_from": 529, "page_to": 529, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=529", "section_title": "uvm_recorder", "content": "nm Name of the attribute value Value radix Radix of the output numbits number of valid bits"}
{"type": "text", "page_from": 530, "page_to": 530, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=530", "section_title": "uvm_recorder", "content": "function void write_attribute_int( string nm, uvm_integral_t value, uvm_radix_enum radix, integer numbits $=$ \\$bits(uvm_bitstream_t)"}
{"type": "text", "page_from": 530, "page_to": 530, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=530", "section_title": "uvm_recorder", "content": "Outputs an integral attribute to the textual log"}
{"type": "text", "page_from": 530, "page_to": 530, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=530", "section_title": "uvm_recorder", "content": "nm Name of the attribute value Value radix Radix of the output numbits number of valid bits"}
{"type": "text", "page_from": 531, "page_to": 531, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=531", "section_title": "uvm_packer", "content": "The uvm_packer class provides a policy object for packing and unpacking uvm_objects. The policies determine how packing and unpacking should be done. Packing an object causes the object to be placed into a bit (byte or int) array. If the \\`uvm_field_\\* macro are used to implement pack and unpack, by default no metadata information is stored for the packing of dynamic objects (strings, arrays, class objects)."}
{"type": "text", "page_from": 531, "page_to": 531, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=531", "section_title": "uvm_packer", "content": "The uvm_packer class provides a policy object for packing and unpacking uvm_objects."}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "virtual function void pack_field ( uvm_bitstream_t value, int size )"}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "Packs an integral value (less than or equal to 4096 bits) into the packed array. size is the number of bits of value to pack."}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "virtual function void pack_field_int ( uvm_integral_t value, int size"}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "Packs the integral value (less than or equal to 64 bits) into the pack array. The size is the number of bits to pack, usually obtained by \\$bits. This optimized version of pack_field is useful for sizes up to 64 bits."}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "virtual function void pack_bits( ref bit value[], input int size = -1"}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "Packs bits from upacked array of bits into the pack array."}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "See pack_ints for additional information."}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "virtual function void pack_bytes( ref byte value[], input int size = -1"}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "Packs bits from an upacked array of bytes into the pack array."}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "See pack_ints for additional information."}
{"type": "text", "page_from": 532, "page_to": 532, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=532", "section_title": "uvm_packer", "content": "virtual function void pack_ints( ref int value[], input int size = -1 )"}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "Packs bits from an unpacked array of ints into the pack array."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "The bits are appended to the internal pack array. This method allows for fields of arbitrary length to be passed in, using the SystemVerilog stream operator."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "When appending the stream to the internal pack array, the packer will obey the value of big_endian (appending the array from MSB to LSB if set)."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "An optional size parameter is provided, which defaults to $\\cdot _ { - 1 ^ { \\prime } }$ . If set to any value greater than $\\cdot _ { - 1 ^ { \\prime } }$ (including 0), then the packer will use the size as the number of bits to pack, otherwise the packer will simply pack the entire stream."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "An error will be asserted if the size has been specified, and exceeds the size of the source array."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "virtual function void pack_string ( string value"}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "Packs a string value into the pack array."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "When the metadata flag is set, the packed string is terminated by a null character to mark the end of the string."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "This is useful for mixed language communication where unpacking may occur outside of SystemVerilog UVM."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "virtual function void pack_time ( time value"}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "Packs a time value as 64 bits into the pack array."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "virtual function void pack_real ( real value"}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "Packs a real value as 64 bits into the pack array."}
{"type": "text", "page_from": 533, "page_to": 533, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=533", "section_title": "uvm_packer", "content": "The real value is converted to a 6-bit scalar value using the function $\\$ 1$ real2bits before it is packed into the array."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "Packs an object value into the pack array."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "A 4-bit header is inserted ahead of the string to indicate the number of bits that was packed. If a null object was packed, then this header will be 0."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "This is useful for mixed-language communication where unpacking may occur outside of SystemVerilog UVM."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "virtual function bit is_null ()"}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "This method is used during unpack operations to peek at the next 4-bit chunk of the pack data and determine if it is 0."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "If the next four bits are all 0, then the return value is a 1; otherwise it is 0."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "This is useful when unpacking objects, to decide whether a new object needs to be allocated or not."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "virtual function uvm_bitstream_t unpack_field ( int size"}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "Unpacks bits from the pack array and returns the bit-stream that was unpacked. size is the number of bits to unpack; the maximum is 4096 bits."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "virtual function uvm_integral_t unpack_field_int ( int size"}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "Unpacks bits from the pack array and returns the bit-stream that was unpacked."}
{"type": "text", "page_from": 534, "page_to": 534, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=534", "section_title": "uvm_packer", "content": "size is the number of bits to unpack; the maximum is 64 bits. This is a more efficient variant than unpack_field when unpacking into smaller vectors."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "Unpacks bits from the pack array into an unpacked array of bits."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "virtual function void unpack_bytes( ref byte value[], input int size = -1 )"}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "Unpacks bits from the pack array into an unpacked array of bytes."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "virtual function void unpack_ints( ref int value[], input int size = -1"}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "Unpacks bits from the pack array into an unpacked array of ints."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "The unpacked array is unpacked from the internal pack array. This method allows for fields of arbitrary length to be passed in without expanding into a pre-defined integral type first."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "When unpacking the stream from the internal pack array, the packer will obey the value of big_endian (unpacking the array from MSB to LSB if set)."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "An optional size parameter is provided, which defaults to $\\cdot _ { - 1 ^ { \\prime } }$ . If set to any value greater than $\\cdot _ { - 1 ^ { \\prime } }$ (including 0), then the packer will use the size as the number of bits to unpack, otherwise the packer will simply unpack the entire stream."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "An error will be asserted if the size has been specified, and exceeds the size of the target array."}
{"type": "text", "page_from": 535, "page_to": 535, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=535", "section_title": "uvm_packer", "content": "num_chars bytes are unpacked into a string. If num_chars is -1 then unpacking stops on at the first null character that is encountered."}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "virtual function time unpack_time ()"}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "Unpacks the next 64 bits of the pack array and places them into a time variable."}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "virtual function real unpack_real ()"}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "Unpacks the next 64 bits of the pack array and places them into a real variable."}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "The 64 bits of packed data are converted to a real using the $\\$ 9$ bits2real system function."}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "virtual function void unpack_object ( uvm_object value"}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "Unpacks an object and stores the result into value."}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "value must be an allocated object that has enough space for the data being unpacked. The first four bits of packed data are used to determine if a null object was packed into the array."}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "The is_null function can be used to peek at the next four bits in the pack array before calling this method."}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "virtual function int get_packed_size()"}
{"type": "text", "page_from": 536, "page_to": 536, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=536", "section_title": "uvm_packer", "content": "Returns the number of bits that were packed."}
{"type": "text", "page_from": 537, "page_to": 537, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=537", "section_title": "uvm_packer", "content": "This bit provides a filtering mechanism for fields."}
{"type": "text", "page_from": 537, "page_to": 537, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=537", "section_title": "uvm_packer", "content": "The abstract and physical settings allow an object to distinguish between two different classes of fields. It is up to you, in the uvm_object::do_pack and uvm_object::do_unpack routines, to test the setting of this field if you want to use it as a filter."}
{"type": "text", "page_from": 537, "page_to": 537, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=537", "section_title": "uvm_packer", "content": "This flag indicates whether to encode metadata when packing dynamic data, or to decode metadata when unpacking. Implementations of uvm_object::do_pack and uvm_object::do_unpack should regard this bit when performing their respective operation. When set, metadata should be encoded as follows:"}
{"type": "text", "page_from": 537, "page_to": 537, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=537", "section_title": "uvm_packer", "content": "For strings, pack an additional null byte after the string is packed. For objects, pack 4 bits prior to packing the object itself. Use 4’b0000 to indicate the object being packed is null, otherwise pack 4’b0001 (the remaining 3 bits are reserved). For queues, dynamic arrays, and associative arrays, pack 32 bits indicating the size of the array prior to packing individual elements."}
{"type": "text", "page_from": 537, "page_to": 537, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=537", "section_title": "uvm_packer", "content": "This bit determines the order that integral data is packed (using pack_field, pack_field_int, pack_time, or pack_real) and how the data is unpacked from the pack array (using unpack_field, unpack_field_int, unpack_time, or unpack_real). When the bit is set, data is associated msb to lsb; otherwise, it is associated lsb to msb."}
{"type": "text", "page_from": 537, "page_to": 537, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=537", "section_title": "uvm_packer", "content": "The following code illustrates how data can be associated msb to lsb and lsb to msb:"}
{"type": "text", "page_from": 538, "page_to": 538, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=538", "section_title": "Links", "content": "The uvm_link_base class, and its extensions, are provided as a mechanism to allow for compile-time safety when trying to establish links between records within a uvm_tr_database."}
{"type": "text", "page_from": 538, "page_to": 538, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=538", "section_title": "Links", "content": "The uvm_link_base class presents a simple API for defining a link between any two objects."}
{"type": "text", "page_from": 538, "page_to": 538, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=538", "section_title": "Links", "content": "Using extensions of this class, a uvm_tr_database can determine the type of links being passed, without relying on “magic” string names."}
{"type": "text", "page_from": 538, "page_to": 538, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=538", "section_title": "Links", "content": "The uvm_link_base class presents a simple API for defining a link between any two objects."}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "virtual class uvm_link_base extends uvm_object"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "set_lhs Sets the left-hand-side of the link get_lhs Gets the left-hand-side of the link set_rhs Sets the right-hand-side of the link get_rhs Gets the right-hand-side of the link set Convenience method for setting both sides in one call."}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "ImPl EmENTATION CAll BAcKs"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "do_set_lhs Callback for setting the left-hand-side do_get_lhs Callback for retrieving the left-hand-side do_set_rhs Callback for setting the right-hand-side do_get_rhs Callback for retrieving the right-hand-side"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "function void set_lhs( uvm_object lhs"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "Sets the left-hand-side of the link"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "Triggers the do_set_lhs callback."}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "function uvm_object get_lhs()"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "Gets the left-hand-side of the link"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "Triggers the do_get_lhs callback"}
{"type": "text", "page_from": 539, "page_to": 539, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=539", "section_title": "Links", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "function void set_rhs( uvm_object rhs"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Sets the right-hand-side of the link"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Triggers the do_set_rhs callback."}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "function uvm_object get_rhs()"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Gets the right-hand-side of the link"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Triggers the do_get_rhs callback"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "function void set( uvm_object lhs, rhs )"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Convenience method for setting both sides in one call."}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Triggers both the do_set_rhs and do_set_lhs callbacks."}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "ImPl EmENTATION CAll BAcKs"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "pure virtual function void do_set_lhs( uvm_object lhs"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Callback for setting the left-hand-side"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "pure virtual function uvm_object do_get_lhs()"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "Callback for retrieving the left-hand-side"}
{"type": "text", "page_from": 540, "page_to": 540, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=540", "section_title": "Links", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 541, "page_to": 541, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=541", "section_title": "Links", "content": "pure virtual function uvm_object do_get_rhs()"}
{"type": "text", "page_from": 541, "page_to": 541, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=541", "section_title": "Links", "content": "Callback for retrieving the right-hand-side"}
{"type": "text", "page_from": 541, "page_to": 541, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=541", "section_title": "Links", "content": "uvm_parent_child_link"}
{"type": "text", "page_from": 541, "page_to": 541, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=541", "section_title": "Links", "content": "The uvm_parent_child_link is used to represent a Parent/Child relationship between two objects."}
{"type": "text", "page_from": 541, "page_to": 541, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=541", "section_title": "Links", "content": "uvm_parent_child_link"}
{"type": "text", "page_from": 541, "page_to": 541, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=541", "section_title": "Links", "content": "The uvm_parent_child_link is used to represent a Parent/Child relationship between two objects."}
{"type": "text", "page_from": 541, "page_to": 541, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=541", "section_title": "Links", "content": "function new( string name $=$ \"unnamed-uvm_parent_child_link\""}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "static function uvm_parent_child_link get_link(uvm_object lhs,uvm_object rhs,string name $=$ \"pc_link\" ）"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "Constructs a pre-filled link"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "This allows for simple one-line link creations."}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "my_db.establish_link(uvm_parent_child_link::get_link(record1, record2));"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "lhs Left hand side reference rhs Right hand side reference name Optional name for the link object"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "ImPl EmENTATION CAll BAcKs"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "virtual function void do_set_lhs( uvm_object lhs"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "Sets the left-hand-side (Parent)"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "virtual function uvm_object do_get_lhs()"}
{"type": "text", "page_from": 542, "page_to": 542, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=542", "section_title": "Links", "content": "Retrieves the left-hand-side (Parent)"}
{"type": "text", "page_from": 543, "page_to": 543, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=543", "section_title": "Links", "content": "The uvm_cause_effect_link is used to represent a Cause/Effect relationship between two objects."}
{"type": "text", "page_from": 543, "page_to": 543, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=543", "section_title": "Links", "content": "uvm_cause_effect_link"}
{"type": "text", "page_from": 543, "page_to": 543, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=543", "section_title": "Links", "content": "The uvm_cause_effect_link is used to represent a Cause/Effect relationship between two objects."}
{"type": "text", "page_from": 543, "page_to": 543, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=543", "section_title": "Links", "content": "static function uvm_cause_effect_link get_link( uvm_object lhs, uvm_object rhs, string name $=$ \"ce_link\" )"}
{"type": "text", "page_from": 543, "page_to": 543, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=543", "section_title": "Links", "content": "Constructs a pre-filled link"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "This allows for simple one-line link creations."}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "my_db.establish_link(uvm_cause_effect_link::get_link(record1, record2));"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "lhs Left hand side reference rhs Right hand side reference name Optional name for the link object"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "ImPl EmENTATION CAll BAcKs"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "virtual function void do_set_lhs( uvm_object lhs"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "Sets the left-hand-side (Cause)"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "virtual function uvm_object do_get_lhs()"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "Retrieves the left-hand-side (Cause)"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "virtual function void do_set_rhs( uvm_object rhs"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "Sets the right-hand-side (Effect)"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "virtual function uvm_object do_get_rhs()"}
{"type": "text", "page_from": 544, "page_to": 544, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=544", "section_title": "Links", "content": "Retrieves the right-hand-side (Effect)"}
{"type": "text", "page_from": 545, "page_to": 545, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=545", "section_title": "Links", "content": "The uvm_related_link is used to represent a generic “is related” link between two objects."}
{"type": "text", "page_from": 545, "page_to": 545, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=545", "section_title": "Links", "content": "function new( string name $=$ \"unnamed-uvm_related_link\" )"}
{"type": "text", "page_from": 545, "page_to": 545, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=545", "section_title": "Links", "content": "Constructs a pre-filled link"}
{"type": "text", "page_from": 545, "page_to": 545, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=545", "section_title": "Links", "content": "This allows for simple one-line link creations."}
{"type": "text", "page_from": 545, "page_to": 545, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=545", "section_title": "Links", "content": "lhs Left hand side reference"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "ImPl EmENTATION CAll BAcKs"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "virtual function void do_set_lhs( uvm_object lhs"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "Sets the left-hand-side"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "virtual function uvm_object do_get_lhs()"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "Retrieves the left-hand-side"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "virtual function void do_set_rhs( uvm_object rhs"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "Sets the right-hand-side"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "virtual function uvm_object do_get_rhs()"}
{"type": "text", "page_from": 546, "page_to": 546, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=546", "section_title": "Links", "content": "Retrieves the right-hand-side"}
{"type": "text", "page_from": 547, "page_to": 547, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=547", "section_title": "Data Access", "content": "23. Data Access Policies"}
{"type": "text", "page_from": 547, "page_to": 547, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=547", "section_title": "Data Access", "content": "The UVM provides special objects as utility classes for applying common policies to data access (such as ‘locking’ data, or ensuring that it remains constant after being read)."}
{"type": "text", "page_from": 547, "page_to": 547, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=547", "section_title": "Data Access", "content": "This is not intended to be a comprehensive list of all Data Access policies, and the user is encouraged to write their own, and potentially contribute them to the community."}
{"type": "text", "page_from": 547, "page_to": 547, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=547", "section_title": "Data Access", "content": "Data Access Policies"}
{"type": "text", "page_from": 547, "page_to": 547, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=547", "section_title": "Data Access", "content": "The UVM provides special objects as utility classes for applying common policies to data access (such as ‘locking’ data, or ensuring that it remains constant after being read)."}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "uvm_set_get_dap_base", "header_path": ["23", "1"], "chapter": "23", "section": "23.1", "content": "23.1 uvm_set_get_dap_base"}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "Provides the ‘set’ and ‘get’ interface for Data Access Policies (DAPs)"}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "The ‘Set/Get’ base class simply provides a common interface for the various DAPs to implement. This provides a mechanism for consistent implementations of similar DAPs."}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "uvm_set_get_dap_base"}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "Provides the ‘set’ and ‘get’ interface for Data Access Policies (DAPs)"}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "All implementations of the uvm_set_get_dap_base class must cE provide an implementation of the four basic “Set and Get” accessors."}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "set Sets the value contained within the resource. try_set Attempts to set the value contained within the resource. get Retrieves the value contained within the resource. try_get Attempts to retrieve the value contained within the resource."}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "All implementations of the uvm_set_get_dap_base class must provide an implementation of the four basic “Set and Get” accessors."}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "Sets the value contained within the resource."}
{"type": "text", "page_from": 548, "page_to": 548, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=548", "section_title": "Set / Get Base", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "Depending on the DAP policies, an error may be reported if it is illegal to ‘set’ the value at this time."}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "Attempts to set the value contained within the resource."}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "If the DAP policies forbid setting at this time, then the method will return 0, however no errors will be reported. Otherwise, the method will return 1, and will be treated like a standard set call."}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "pure virtual function T get()"}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "Retrieves the value contained within the resource."}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "Depending on the DAP policies, an error may be reported if it is illegal to ‘get’ the value at this time."}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "Attempts to retrieve the value contained within the resource."}
{"type": "text", "page_from": 549, "page_to": 549, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=549", "section_title": "Set / Get Base", "content": "If the DAP policies forbid retrieving at this time, then the method will return 0, however no errors will be reported. Otherwise, the method will return 1, and will be treated like a standard get call."}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "uvm_simple_lock_dap", "header_path": ["23", "2"], "chapter": "23", "section": "23.2", "content": "23.2 uvm_simple_lock_dap"}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "Provides a ‘Simple Lock’ Data Access Policy."}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "The ‘Simple Lock’ Data Access Policy allows for any number of ‘sets’, so long as the value is not ‘locked’. The value can be retrieved using ‘get’ at any time."}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "The UVM uses this policy to protect the file name value in the uvm_text_tr_database."}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "Provides a ‘Simple Lock’ Data Access Policy."}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "uvm_set_get_dap_base#(T)"}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "class uvm_simple_lock_dap#( type ) extends uvm_set_get_dap_base#(T)"}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "set Updates the value stored within the DAP. try_set Attempts to update the value stored within the DAP. get Returns the current value stored within the DAP try_get Retrieves the current value stored within the DAP"}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "lock Locks the data value unlock Unlocks the data value is_locked Returns the state of the lock."}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "The uvm_simple_lock_dap cannot support the standard UVM instrumentation methods (copy, clone, pack and unpack), due to the fact that they would potentially violate the access policy."}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "function new( string name $=$ \"unnamed-uvm_simple_lock_dap#(T)\""}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "virtual function void set("}
{"type": "text", "page_from": 550, "page_to": 550, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=550", "section_title": "Simple Lock", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "Updates the value stored within the DAP."}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "set will result in an error if the DAP has been locked."}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "virtual function bit try_set( T value"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "Attempts to update the value stored within the DAP."}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "try_set will return a 1 if the value was successfully updated, or a 0 if the value cannot be updated due to the DAP being locked. No errors will be reported if try_set fails."}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "virtual function T get()"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "Returns the current value stored within the DAP"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "virtual function bit try_get( output T value"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "Retrieves the current value stored within the DAP"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "try_get will always return 1."}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "function void lock()"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "Locks the data value"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "The data value cannot be updated via set or try_set while locked."}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "function void unlock()"}
{"type": "text", "page_from": 551, "page_to": 551, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=551", "section_title": "Simple Lock", "content": "Unlocks the data value"}
{"type": "text", "page_from": 552, "page_to": 552, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=552", "section_title": "Simple Lock", "content": "function bit is_locked()"}
{"type": "text", "page_from": 552, "page_to": 552, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=552", "section_title": "Simple Lock", "content": "Returns the state of the lock."}
{"type": "text", "page_from": 552, "page_to": 552, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=552", "section_title": "The value is locked 0 The value is unlocked", "header_path": ["1"], "chapter": "1", "content": "1 The value is locked 0 The value is unlocked"}
{"type": "text", "page_from": 552, "page_to": 552, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=552", "section_title": "Simple Lock", "content": "The uvm_simple_lock_dap cannot support the standard UVM instrumentation methods (copy, clone, pack and unpack), due to the fact that they would potentially violate the access policy."}
{"type": "text", "page_from": 552, "page_to": 552, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=552", "section_title": "Simple Lock", "content": "A call to any of these methods will result in an error."}
{"type": "text", "page_from": 553, "page_to": 553, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=553", "section_title": "uvm_get_to_lock_dap", "header_path": ["23", "3"], "chapter": "23", "section": "23.3", "content": "23.3 uvm_get_to_lock_dap"}
{"type": "text", "page_from": 553, "page_to": 553, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=553", "section_title": "Get To Lock", "content": "Provides a ‘Get-To-Lock’ Data Access Policy."}
{"type": "text", "page_from": 553, "page_to": 553, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=553", "section_title": "Get To Lock", "content": "The ‘Get-To-Lock’ Data Access Policy allows for any number of ‘sets’, until the value is retrieved via a ‘get’. Once ‘get’ has been called, it is illegal to ‘set’ a new value."}
{"type": "text", "page_from": 553, "page_to": 553, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=553", "section_title": "Get To Lock", "content": "The UVM uses this policy to protect the starting phase and automatic objection values in uvm_sequence_base."}
{"type": "text", "page_from": 553, "page_to": 553, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=553", "section_title": "Get To Lock", "content": "Provides a ‘Get-To-Lock’ Data Access Policy."}
{"type": "text", "page_from": 553, "page_to": 553, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=553", "section_title": "Get To Lock", "content": "uvm_set_get_dap_base#(T)"}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "Updates the value stored within the DAP."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "set will result in an error if the value has already been retrieved via a call to get."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "Attempts to update the value stored within the DAP."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "try_set will return a 1 if the value was successfully updated, or a 0 if the value cannot be updated due to get having been called. No errors will be reported if try_set fails."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "virtual function T get()"}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "Returns the current value stored within the DAP, and ‘locks’ the DAP."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "After a ‘get’, the value contained within the DAP cannot be changed."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "virtual function bit try_get( output T value"}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "Retrieves the current value stored within the DAP, and ‘locks’ the DAP."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "try_get will always return 1."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "The uvm_get_to_lock_dap cannot support the standard UVM instrumentation methods (copy, clone, pack and unpack), due to the fact that they would potentially violate the access policy."}
{"type": "text", "page_from": 554, "page_to": 554, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=554", "section_title": "Get To Lock", "content": "A call to any of these methods will result in an error."}
{"type": "text", "page_from": 555, "page_to": 555, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=555", "section_title": "uvm_set_before_get_dap", "header_path": ["23", "4"], "chapter": "23", "section": "23.4", "content": "23.4 uvm_set_before_get_dap"}
{"type": "text", "page_from": 555, "page_to": 555, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=555", "section_title": "Set Before Get", "content": "Provides a ‘Set Before Get’ Data Access Policy."}
{"type": "text", "page_from": 555, "page_to": 555, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=555", "section_title": "Set Before Get", "content": "The ‘Set Before Get’ Data Access Policy enforces that the value must be written at least once before it is read. This DAP can be used to pass shared information to multiple components during standard configuration, even if that information hasn’t yet been determined."}
{"type": "text", "page_from": 555, "page_to": 555, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=555", "section_title": "Set Before Get", "content": "Such DAP objects can be useful for passing a ‘placeholder’ reference, before the information is actually available. A good example of this would be the virtual sequencer:"}
{"type": "text", "page_from": 555, "page_to": 555, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=555", "section_title": "Set Before Get", "content": "In the example above, the environment didn’t have a reference to the agent’s sequencer yet, because the agent hadn’t executed its build_phase. The environment needed to give the virtual sequencer a “Set before get” DAP so that the virtual sequencer (and any sequences one it), could eventually see the agent’s sequencer, when the reference was finally available. If the virtual sequencer (or any sequences on it) attempted to ‘get’ the reference to the agent’s sequencer prior to the environment assigning it, an error would have been reported."}
{"type": "text", "page_from": 556, "page_to": 556, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=556", "section_title": "Set Before Get", "content": "Updates the value stored within the DAP."}
{"type": "text", "page_from": 556, "page_to": 556, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=556", "section_title": "Set Before Get", "content": "virtual function bit try_set( T value"}
{"type": "text", "page_from": 556, "page_to": 556, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=556", "section_title": "Set Before Get", "content": "Attempts to update the value stored within the DAP."}
{"type": "text", "page_from": 556, "page_to": 556, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=556", "section_title": "Set Before Get", "content": "try_set will always return a 1."}
{"type": "text", "page_from": 557, "page_to": 557, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=557", "section_title": "Set Before Get", "content": "If the value has not been ‘set’, then try_get will return a 0, otherwise it will return a 1, and set value to the current value stored within the DAP."}
{"type": "text", "page_from": 557, "page_to": 557, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=557", "section_title": "Set Before Get", "content": "The uvm_set_before_get_dap cannot support the standard UVM instrumentation methods (copy, clone, pack and unpack), due to the fact that they would potentially violate the access policy."}
{"type": "text", "page_from": 557, "page_to": 557, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=557", "section_title": "Set Before Get", "content": "A call to any of these methods will result in an error."}
{"type": "text", "page_from": 558, "page_to": 558, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=558", "section_title": "Overview", "content": "The UVM register layer defines several base classes that, when properly extended, abstract the read/write operations to registers and memories in a design-underverification."}
{"type": "text", "page_from": 558, "page_to": 558, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=558", "section_title": "Overview", "content": "A register model is typically composed of a hierarchy of blocks that usually map to the design hierarchy. Blocks contain registers, register files and memories."}
{"type": "text", "page_from": 558, "page_to": 558, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=558", "section_title": "Overview", "content": "The UVM register layer classes are not usable as-is. They only provide generic and introspection capabilities. They must be specialized via extensions to provide an abstract view that corresponds to the actual registers and memories in a design. Due to the large number of registers in a design and the numerous small details involved in properly configuring the UVM register layer classes, this specialization is normally done by a model generator. Model generators work from a specification of the registers and memories in a design and are thus able to provide an up-to-date, correct-by-construction register model. Model generators are outside the scope of the UVM library."}
{"type": "text", "page_from": 558, "page_to": 558, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=558", "section_title": "Overview", "content": "The class diagram of a register layer model is shown below."}
{"type": "text", "page_from": 558, "page_to": 558, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=558", "section_title": "Overview", "content": "The UVM register layer defines several base classes that, when properly extended, abstract the read/write operations to registers and memories in a"}
{"type": "text", "page_from": 559, "page_to": 559, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=559", "section_title": "Overview", "content": "design-under-verification."}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations for the Register Layer", "header_path": ["24", "2"], "chapter": "24", "section": "24.2", "content": "24.2 Global Declarations for the Register Layer"}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "This section defines globally available types, enums, and utility classes."}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "Global Declarations for the Register Layer"}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "This section defines globally available types, enums, and utility classes."}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "2-state data value with \\`UVM_REG_DATA_WIDTH bits"}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "uvm_reg_data_logic_t"}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "4-state data value with \\`UVM_REG_DATA_WIDTH bits"}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "2-state address value with \\`UVM_REG_ADDR_WIDTH bits"}
{"type": "text", "page_from": 560, "page_to": 560, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=560", "section_title": "Global Declarations", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "4-state address value with \\`UVM_REG_ADDR_WIDTH bits"}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "2-state byte_enable value with \\`UVM_REG_BYTENABLE_WIDTH bits"}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "Coverage model value set with \\`UVM_REG_CVR_WIDTH bits."}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "Symbolic values for individual coverage models are defined by the uvm_coverage_model_e type."}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "The following bits in the set are assigned as follows"}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "0-7 UVM pre-defined coverage models 8-15 Coverage models defined by EDA vendors, implemented in a register model generator. 16-23 User-defined coverage models 24.. Reserved"}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "Slice of an HDL path"}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "Struct that specifies the HDL variable that corresponds to all or a portion of a register."}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "path Path to the HDL variable. offset Offset of the LSB in the register that this variable implements size Number of bits (toward the MSB) that this variable implements"}
{"type": "text", "page_from": 561, "page_to": 561, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=561", "section_title": "Global Declarations", "content": "If the HDL variable implements all of the register, offset and size are specified as -1. For example:"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "UVM_NOT_OK Operation completed with error UVM_HAS_X Operation completed successfully bit had unknown bits."}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "Path used for register operation"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "UVM_FRONTDOOR Use the front door UVM_BACKDOOR Use the back door UVM_PREDICT Operation derived from observations by a bus monitor via the uvm_reg_predictor class. UVM_DEFAULT_PATH Operation specified by the context"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "Read-only or read-and-check"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "UVM_NO_CHECK Read only UVM_CHECK Read and check"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "Specifies byte ordering"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "UVM_NO_ENDIAN Byte ordering not applicable UVM_LITTLE_ENDIAN Least-significant bytes first in consecutive addresses UVM_BIG_ENDIAN Most-significant bytes first in consecutive addresses UVM_LITTLE_FIFO Least-significant bytes first at the same address UVM_BIG_FIFO Most-significant bytes first at the same address"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "Type of element being read or written"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "UVM_REG Register UVM_FIELD Field UVM_MEM Memory location"}
{"type": "text", "page_from": 562, "page_to": 562, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=562", "section_title": "Global Declarations", "content": "Type of operation begin performed UVM_READ Read operation UVM_WRITE Write operation"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Whether to provide the requested information from a hierarchical context."}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "UVM_NO_HIER Provide info from the local context UVM_HIER Provide info based on the hierarchical context"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "How the mirror is to be updated"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "UVM_PREDICT_DIRECT UVM_PREDICT_READ"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Predicted value is as-is Predict based on the specified value having been read Predict based on the specified value having been written"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "uvm_coverage_model_e"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Coverage models available or desired. Multiple models may be specified by bitwise OR’ing individual model identifiers."}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "UVM_NO_COVERAGE None UVM_CVR_REG_BITS Individual register bits UVM_CVR_ADDR_MAP Individual register and memory addresses UVM_CVR_FIELD_VALS Field values UVM_CVR_ALL All coverage models"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Select which pre-defined test sequence to execute."}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Multiple test sequences may be selected by bitwise OR’ing their respective symbolic values."}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "UVM_DO_REG_HW_RESET UVM_DO_REG_BIT_BASH UVM_DO_REG_ACCESS UVM_DO_MEM_ACCESS UVM_DO_SHARED_ACCESS UVM_DO_MEM_WALK UVM_DO_ALL_REG_MEM_TESTS"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Run uvm_reg_hw_reset_seq Run uvm_reg_bit_bash_seq Run uvm_reg_access_seq Run uvm_mem_access_seq Run uvm_reg_mem_shared_access_seq Run uvm_mem_walk_seq Run all of the above"}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Test sequences, when selected, are executed in the order in which they are specified above."}
{"type": "text", "page_from": 563, "page_to": 563, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=563", "section_title": "Global Declarations", "content": "Ut Il It Y Cl Ass Es"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "Concatenation of HDL variables"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "A dArray of uvm_hdl_path_slice specifying a concatenation of HDL variables that implement a register in the HDL."}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "Slices must be specified in most-to-least significant order. Slices must not overlap. Gaps may exist in the concatenation if portions of the registers are not implemented."}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "For example, the following register"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "If the register is implemented using a single HDL variable, The array should specify a single slice with its offset and size specified as -1. For example:"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "Concatenation of HDL variables"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "Cl Ass DEcl Ar At ION"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "class uvm_hdl_path_concat"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "slices Array of individual slices, stored in most-to-least significant order"}
{"type": "text", "page_from": 564, "page_to": 564, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=564", "section_title": "Global Declarations", "content": "set Initialize the concatenation using an array literal add_slice Append the specified slice literal to the path concatenation add_path Append the specified path to the path concatenation, for the specified number of bits at the specified offset."}
{"type": "text", "page_from": 565, "page_to": 565, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=565", "section_title": "Global Declarations", "content": "function void set( uvm_hdl_path_slice t[]"}
{"type": "text", "page_from": 565, "page_to": 565, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=565", "section_title": "Global Declarations", "content": "Initialize the concatenation using an array literal"}
{"type": "text", "page_from": 565, "page_to": 565, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=565", "section_title": "Global Declarations", "content": "function void add_slice( uvm_hdl_path_slice slice"}
{"type": "text", "page_from": 565, "page_to": 565, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=565", "section_title": "Global Declarations", "content": "Append the specified slice literal to the path concatenation"}
{"type": "text", "page_from": 565, "page_to": 565, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=565", "section_title": "Global Declarations", "content": "Append the specified path to the path concatenation, for the specified number of bits at the specified offset."}
{"type": "text", "page_from": 566, "page_to": 566, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=566", "section_title": "Blocks", "content": "Block abstraction base class"}
{"type": "text", "page_from": 566, "page_to": 566, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=566", "section_title": "Blocks", "content": "A block represents a design hierarchy. It can contain registers, register files, memories and sub-blocks."}
{"type": "text", "page_from": 566, "page_to": 566, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=566", "section_title": "Blocks", "content": "A block has one or more address maps, each corresponding to a physical interface on the block."}
{"type": "text", "page_from": 566, "page_to": 566, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=566", "section_title": "Blocks", "content": "Block abstraction base class"}
{"type": "text", "page_from": 567, "page_to": 567, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=567", "section_title": "Blocks", "content": "get_default_path Default access path reset Reset the mirror for this block. needs_update Check if DUT registers need to be written update Batch update of register. mirror Update the mirrored values write_reg_by_name Write the named register read_reg_by_name Read the named register write_mem_by_name Write the named memory read_mem_by_name Read the named memory"}
{"type": "text", "page_from": 567, "page_to": 567, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=567", "section_title": "Blocks", "content": "uvm_path_e default_path $=$ UVM_DEFAULT_PATH"}
{"type": "text", "page_from": 567, "page_to": 567, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=567", "section_title": "Blocks", "content": "Default access path for the registers and memories in this block."}
{"type": "text", "page_from": 567, "page_to": 567, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=567", "section_title": "Blocks", "content": "function new( string name $=$ int has_coverage $=$ UVM_NO_COVERAGE )"}
{"type": "text", "page_from": 567, "page_to": 567, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=567", "section_title": "Blocks", "content": "Create a new instance and type-specific configuration"}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "Creates an instance of a block abstraction class with the specified name."}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "has_coverage specifies which functional coverage models are present in the extension of the block abstraction class. Multiple functional coverage models may be specified by adding their symbolic names, as defined by the uvm_coverage_model_e type."}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "Instance-specific configuration"}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "Specify the parent block of this block. A block without parent is a root block."}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "If the block file corresponds to a hierarchical RTL structure, its contribution to the HDL path is specified as the hdl_path. Otherwise, the block does not correspond to a hierarchical RTL structure (e.g. it is physically flattened) and does not contribute to the hierarchical HDL path of any contained registers or memories."}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "Create an address map in this block"}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "Create an address map with the specified name, then configures it with the following properties."}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "base_addr the base address for the map. All registers, memories, and sub-blocks within the map will be at offsets to this address n_bytes the byte-width of the bus on which this map is used endian the endian format. See uvm_endianness_e for possible values byte_addressing specifies whether consecutive addresses refer are 1 byte apart (TRUE) or n_bytes apart (FALSE). Default is TRUE."}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "protected static function bit check_data_width( int unsigned width"}
{"type": "text", "page_from": 568, "page_to": 568, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=568", "section_title": "Blocks", "content": "Check that the specified data width (in bits) is less than or equal to the value of \\`UVM_REG_DATA_WIDTH"}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "This method is designed to be called by a static initializer"}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "function void set_default_map uvm_reg_map map"}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "Defines the default address map"}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "Set the specified address map as the default_map for this block. The address map must be a map of this address block."}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "uvm_reg_map default_map"}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "Default address map for this block, to be used when no address map is specified for a register operation and that register is accessible from more than one address map."}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "It is also the implicit address map for a block with a single, unnamed address map because it has only one physical interface."}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "virtual function void lock_model()"}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "Lock a model and build the address map."}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "Recursively lock an entire register model and build the address maps to enable the uvm_reg_map::get_reg_by_offset() and uvm_reg_map::get_mem_by_offset() methods."}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "Once locked, no further structural changes, such as adding registers or memories, can be made."}
{"type": "text", "page_from": 569, "page_to": 569, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=569", "section_title": "Blocks", "content": "It is not possible to unlock a model."}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Return the simple object name of this block."}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Return the hierarchal name of this block. The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "virtual function uvm_reg_block get_parent()"}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Get the parent block"}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "If this a top-level block, returns null."}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "static function void get_root_blocks( ref uvm_reg_block blks[\\$]"}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Get the all root blocks"}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Returns an array of all root blocks in the simulation."}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Find the blocks whose hierarchical names match the specified name glob. If a root block is specified, the name of the blocks are relative to that block, otherwise they are absolute."}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "Returns the number of blocks found."}
{"type": "text", "page_from": 570, "page_to": 570, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=570", "section_title": "Blocks", "content": "static function uvm_reg_block find_block( input string name, input uvm reg block root = null,"}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "input uvm_object accessor = null ）"}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Find the first block whose hierarchical names match the specified name glob. If a root block is specified, the name of the blocks are relative to that block, otherwise they are absolute."}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Returns the first block found or null otherwise. A warning is issued if more than one block is found."}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Get the blocks instantiated in this blocks. If hier is TRUE, recursively includes any subblocks."}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Get the address maps"}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Get the address maps instantiated in this block."}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Get the registers instantiated in this block. If hier is TRUE, recursively includes the registers in the sub-blocks."}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Note that registers may be located in different and/or multiple address maps. To get the registers in a specific address map, use the uvm_reg_map::get_registers() method."}
{"type": "text", "page_from": 571, "page_to": 571, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=571", "section_title": "Blocks", "content": "Get the fields in the registers instantiated in this block. If hier is TRUE, recursively"}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "includes the fields of the registers in the sub-blocks."}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "Get the memories instantiated in this block. If hier is TRUE, recursively includes the memories in the sub-blocks."}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "Note that memories may be located in different and/or multiple address maps. To get the memories in a specific address map, use the uvm_reg_map::get_memories() method."}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "get_virtual_registers"}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "Get the virtual registers"}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "Get the virtual registers instantiated in this block. If hier is TRUE, recursively includes the virtual registers in the sub-blocks."}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "Get the virtual fields"}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "Get the virtual fields from the virtual registers instantiated in this block. If hier is TRUE, recursively includes the virtual fields in the virtual registers in the sub-blocks."}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "Finds a sub-block with the specified simple name."}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "The name is the simple name of the block, not a hierarchical name. relative to this block. If no block with that name is found in this block, the sub-blocks are searched for a block of that name and the first one to be found is returned."}
{"type": "text", "page_from": 572, "page_to": 572, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=572", "section_title": "Blocks", "content": "If no blocks are found, returns null."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "virtual function uvm_reg_map get_map_by_name ( string name"}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "Finds an address map with the specified simple name."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "The name is the simple name of the address map, not a hierarchical name. relative to this block. If no map with that name is found in this block, the sub-blocks are searched for a map of that name and the first one to be found is returned."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "If no address maps are found, returns null."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "virtual function uvm_reg get_reg_by_name string name )"}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "Finds a register with the specified simple name."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "The name is the simple name of the register, not a hierarchical name. relative to this block. If no register with that name is found in this block, the sub-blocks are searched for a register of that name and the first one to be found is returned."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "If no registers are found, returns null."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "Finds a field with the specified simple name."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "The name is the simple name of the field, not a hierarchical name. relative to this block. If no field with that name is found in this block, the sub-blocks are searched for a field of that name and the first one to be found is returned."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "If no fields are found, returns null."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "virtual function uvm_mem get_mem_by_name ( string name"}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "Finds a memory with the specified simple name."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "The name is the simple name of the memory, not a hierarchical name. relative to this block. If no memory with that name is found in this block, the sub-blocks are searched for a memory of that name and the first one to be found is returned."}
{"type": "text", "page_from": 573, "page_to": 573, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=573", "section_title": "Blocks", "content": "If no memories are found, returns null."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "Finds a virtual register with the specified simple name."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "The name is the simple name of the virtual register, not a hierarchical name. relative to this block. If no virtual register with that name is found in this block, the sub-blocks are searched for a virtual register of that name and the first one to be found is returned."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "If no virtual registers are found, returns null."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "virtual function uvm_vreg_field get_vfield_by_name ( string name"}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "Finds a virtual field with the specified simple name."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "The name is the simple name of the virtual field, not a hierarchical name. relative to this block. If no virtual field with that name is found in this block, the sub-blocks are searched for a virtual field of that name and the first one to be found is returned."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "If no virtual fields are found, returns null."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "protected function uvm_reg_cvr_t build_coverage( uvm_reg_cvr_t models"}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "Check if all of the specified coverage model must be built."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "Check which of the specified coverage model must be built in this instance of the block abstraction class, as specified by calls to uvm_reg::include_coverage()."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e. Returns the sum of all coverage models to be built in the block model."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "virtual protected function void add_coverage( uvm_reg_cvr_t models"}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "Specify that additional coverage models are available."}
{"type": "text", "page_from": 574, "page_to": 574, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=574", "section_title": "Blocks", "content": "Add the specified coverage model to the coverage models available in this class. Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "This method shall be called only in the constructor of subsequently derived classes."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "Check if block has coverage model(s)"}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "Returns TRUE if the block abstraction class contains a coverage model for all of the models specified. Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "virtual function uvm_reg_cvr_t set_coverage( uvm_reg_cvr_t is_on"}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "Turns on coverage measurement."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "Turns the collection of functional coverage measurements on or off for this block and all blocks, registers, fields and memories within it. The functional coverage measurement is turned on for every coverage model specified using uvm_coverage_model_e symbolic identifiers. Multiple functional coverage models can be specified by adding the functional coverage model identifiers. All other functional coverage models are turned off. Returns the sum of all functional coverage models whose measurements were previously on."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "This method can only control the measurement of functional coverage models that are present in the various abstraction classes, then enabled during construction. See the uvm_reg_block::has_coverage() method to identify the available functional coverage models."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "virtual function bit get_coverage( uvm_reg_cvr_t is_on $= ^ { - }$ UVM_CVR_ALL"}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "Check if coverage measurement is on."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "Returns TRUE if measurement for all of the specified functional coverage models are currently on. Multiple functional coverage models can be specified by adding the functional coverage model identifiers."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "See uvm_reg_block::set_coverage() for more details."}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "Functional coverage measurement method"}
{"type": "text", "page_from": 575, "page_to": 575, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=575", "section_title": "Blocks", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "This method is invoked by the block abstraction class whenever an address within one of its address map is successfully read or written. The specified offset is the offset within the block, not an absolute address."}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "Empty by default, this method may be extended by the abstraction class generator to perform the required sampling in any provided functional coverage model."}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "virtual function void sample_values()"}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "Functional coverage measurement method for field values"}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "This method is invoked by the user or by the uvm_reg_block::sample_values() method of the parent block to trigger the sampling of the current field values in the block-level functional coverage model. It recursively invokes the uvm_reg_block::sample_values() and uvm_reg::sample_values() methods in the blocks and registers in this block."}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "This method may be extended by the abstraction class generator to perform the required sampling in any provided field-value functional coverage model. If this method is extended, it MUST call super.sample_values()."}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "virtual function uvm_path_e get_default_path()"}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "Returns the default access path for this block."}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "virtual function void reset( string kind $=$ \"HARD\""}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "Reset the mirror for this block."}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "Sets the mirror value of all registers in the block and sub-blocks to the reset value corresponding to the specified reset event. See uvm_reg_field::reset() for more details. Does not actually set the value of the registers in the design, only the values mirrored in their corresponding mirror."}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "virtual function bit needs_update()"}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "Check if DUT registers need to be written"}
{"type": "text", "page_from": 576, "page_to": 576, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=576", "section_title": "Blocks", "content": "If a mirror value has been modified in the abstraction model without actually updating the actual register (either through randomization or via the uvm_reg::set() method, the mirror and state of the registers are outdated. The corresponding registers in the DUT need to be updated."}
{"type": "text", "page_from": 577, "page_to": 577, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=577", "section_title": "Blocks", "content": "This method returns TRUE if the state of at least one register in the block or sub-blocks needs to be updated to match the mirrored values. The mirror values, or actual content of registers, are not modified. For additional information, see uvm_reg_block::update() method."}
{"type": "text", "page_from": 577, "page_to": 577, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=577", "section_title": "Blocks", "content": "Batch update of register."}
{"type": "text", "page_from": 577, "page_to": 577, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=577", "section_title": "Blocks", "content": "Using the minimum number of write operations, updates the registers in the design to match the mirrored values in this block and sub-blocks. The update can be performed using the physical interfaces (front-door access) or back-door accesses. This method performs the reverse operation of uvm_reg_block::mirror()."}
{"type": "text", "page_from": 577, "page_to": 577, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=577", "section_title": "Blocks", "content": "Update the mirrored values"}
{"type": "text", "page_from": 577, "page_to": 577, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=577", "section_title": "Blocks", "content": "Read all of the registers in this block and sub-blocks and update their mirror values to match their corresponding values in the design. The mirroring can be performed using the physical interfaces (front-door access) or back-door accesses. If the check argument is specified as UVM_CHECK, an error message is issued if the current mirrored value does not match the actual value in the design. This method performs the reverse operation of uvm_reg_block::update()."}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Write the named register"}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Equivalent to get_reg_by_name() followed by uvm_reg::write()"}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Read the named register"}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Equivalent to get_reg_by_name() followed by uvm_reg::read()"}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Write the named memory"}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Equivalent to get_mem_by_name() followed by uvm_mem::write()"}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Read the named memory"}
{"type": "text", "page_from": 578, "page_to": 578, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=578", "section_title": "Blocks", "content": "Equivalent to get_mem_by_name() followed by uvm_mem::read()"}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "function uvm_reg_backdoor get_backdoor( bit inherited $\\ l = \\ 1$ (id"}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "Get the user-defined backdoor for all registers in this block"}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "Return the user-defined backdoor for all register in this block and all sub-blocks -- unless overridden by a backdoor set in a lower-level block or in the register itself."}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "If inherited is TRUE, returns the backdoor of the parent block if none have been specified for this block."}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "Set the user-defined backdoor for all registers in this block"}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "Defines the backdoor mechanism for all registers instantiated in this block and subblocks, unless overridden by a definition in a lower-level block or register."}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "Remove any previously specified HDL path to the block instance for the specified design abstraction."}
{"type": "text", "page_from": 579, "page_to": 579, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=579", "section_title": "Blocks", "content": "Add the specified HDL path to the block instance for the specified design abstraction. This method may be called more than once for the same design abstraction if the block is physically duplicated in the design abstraction"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Check if a HDL path is specified"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Returns TRUE if the block instance has a HDL path defined for the specified design abstraction. If no design abstraction is specified, uses the default design abstraction specified for this block or the nearest block ancestor with a specified default design abstraction."}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Get the incremental HDL path(s)"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Returns the HDL path(s) defined for the specified design abstraction in the block instance. Returns only the component of the HDL paths that corresponds to the block, not a full hierarchical path"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "If no design abstraction is specified, the default design abstraction for this block is used."}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Get the full hierarchical HDL path(s)"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Returns the full hierarchical HDL path(s) defined for the specified design abstraction in the block instance. There may be more than one path returned even if only one path was defined for the block instance, if any of the parent components have more than one path defined for the same design abstraction"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "If no design abstraction is specified, the default design abstraction for each ancestor block is used to get each incremental path."}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "set_default_hdl_path"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Set the default design abstraction"}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "Set the default design abstraction for this block instance."}
{"type": "text", "page_from": 580, "page_to": 580, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=580", "section_title": "Blocks", "content": "get_default_hdl_path"}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "function string get_default_hdl_path ()"}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "Get the default design abstraction"}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "Returns the default design abstraction for this block instance. If a default design abstraction has not been explicitly set for this block instance, returns the default design abstraction for the nearest block ancestor. Returns “” if no default design abstraction has been specified."}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "function void set_hdl_path_root ( string path, string kind $=$ \"RTL\""}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "Specify a root HDL path"}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "Set the specified path as the absolute HDL path to the block instance for the specified design abstraction. This absolute root path is prepended to all hierarchical paths under this block. The HDL path of any ancestor block is ignored. This method overrides any incremental path for the same design abstraction specified using add_hdl_path."}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "Check if this block has an absolute path"}
{"type": "text", "page_from": 581, "page_to": 581, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=581", "section_title": "Blocks", "content": "Returns TRUE if an absolute HDL path to the block instance for the specified design abstraction has been defined. If no design abstraction is specified, the default design abstraction for this block is used."}
{"type": "text", "page_from": 582, "page_to": 582, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=582", "section_title": "uvm_reg_transaction_order_policy", "header_path": ["25", "2"], "chapter": "25", "section": "25.2", "content": "25.2 uvm_reg_transaction_order_policy"}
{"type": "text", "page_from": 582, "page_to": 582, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=582", "section_title": "Address Maps", "content": "uvm_reg_transaction_order_policy uvm_reg_map"}
{"type": "text", "page_from": 582, "page_to": 582, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=582", "section_title": "Address Maps", "content": "pure virtual function void order( ref uvm_reg_bus_op q[\\$]"}
{"type": "text", "page_from": 582, "page_to": 582, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=582", "section_title": "Address Maps", "content": "the order() function may reorder the sequence of bus transactions produced by a single uvm_reg transaction (read/write). This can be used in scenarios when the register width differs from the bus width and one register access results in a series of bus transactions. the first item (0) of the queue will be the first bus transaction (the last $( \\$ )$ will be the final transaction"}
{"type": "text", "page_from": 582, "page_to": 582, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=582", "section_title": "Address Maps", "content": "This class represents an address map. An address map is a collection of registers and memories accessible via a specific physical interface. Address maps can be composed into higher-level address maps."}
{"type": "text", "page_from": 582, "page_to": 582, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=582", "section_title": "Address Maps", "content": "Address maps are created using the uvm_reg_block::create_map() method."}
{"type": "text", "page_from": 582, "page_to": 582, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=582", "section_title": "Address Maps", "content": "class uvm_reg_map extends uvm_object"}
{"type": "text", "page_from": 583, "page_to": 583, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=583", "section_title": "Address Maps", "content": "static function uvm_reg_map backdoor()"}
{"type": "text", "page_from": 583, "page_to": 583, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=583", "section_title": "Address Maps", "content": "Return the backdoor pseudo-map singleton"}
{"type": "text", "page_from": 583, "page_to": 583, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=583", "section_title": "Address Maps", "content": "This pseudo-map is used to specify or configure the backdoor instead of a real address"}
{"type": "text", "page_from": 584, "page_to": 584, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=584", "section_title": "Address Maps", "content": "Create a new instance"}
{"type": "text", "page_from": 584, "page_to": 584, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=584", "section_title": "Address Maps", "content": "Instance-specific configuration"}
{"type": "text", "page_from": 584, "page_to": 584, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=584", "section_title": "Address Maps", "content": "Configures this map with the following properties."}
{"type": "text", "page_from": 584, "page_to": 584, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=584", "section_title": "Address Maps", "content": "parent the block in which this map is created and applied base_addr the base address for this map. All registers, memories, and sub-blocks will be at offsets to this address n_bytes the byte-width of the bus on which this map is used endian the endian format. See uvm_endianness_e for possible values byte_addressing specifies whether the address increment is on a per-byte basis. For example, consecutive memory locations with \\~n_bytes\\~ $^ { = 4 }$ (32-bit bus) are 4 apart: 0, 4, 8, and so on. Default is TRUE."}
{"type": "text", "page_from": 584, "page_to": 584, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=584", "section_title": "Address Maps", "content": "Add the specified register instance $r g$ to this address map."}
{"type": "text", "page_from": 584, "page_to": 584, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=584", "section_title": "Address Maps", "content": "The register is located at the specified address offset from this maps configured base address."}
{"type": "text", "page_from": 584, "page_to": 584, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=584", "section_title": "Address Maps", "content": "The rights specify the register’s accessibility via this map. Valid values are “RW”, “RO”, and $\\ \" \\mathsf { W O ^ { \\prime \\prime } }$ . Whether a register field can be read or written depends on both the field’s"}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "configured access policy (see uvm_reg_field::configure and the register’s rights in the map being used to access the field."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "The number of consecutive physical addresses occupied by the register depends on the width of the register and the number of bytes in the physical interface corresponding to this address map."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "If unmapped is TRUE, the register does not occupy any physical addresses and the base address is ignored. Unmapped registers require a user-defined frontdoor to be specified."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "A register may be added to multiple address maps if it is accessible from multiple physical interfaces. A register may only be added to an address map whose parent block is the same as the register’s parent block."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "Add the specified memory instance to this address map. The memory is located at the specified base address and has the specified access rights $( \\ \" { \\sf R } { \\sf W } ^ { \\prime \\prime } , \\ { \\mathrm { \\tilde { R } O } } ^ { \\prime \\prime } \\ { \\mathrm { o r \\ } } ^ { \\mathrm { \\ w } } { \\sf W } { \\mathrm { O } } ^ { \\prime \\prime } )$ . The number of consecutive physical addresses occupied by the memory depends on the width and size of the memory and the number of bytes in the physical interface corresponding to this address map."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "If unmapped is TRUE, the memory does not occupy any physical addresses and the base address is ignored. Unmapped memories require a user-defined frontdoor to be specified."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "A memory may be added to multiple address maps if it is accessible from multiple physical interfaces. A memory may only be added to an address map whose parent block is the same as the memory’s parent block."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "virtual function void add_submap ( uvm_reg_map child_map, uvm_reg_addr_t offset"}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "Add the specified address map instance to this address map. The address map is located at the specified base address. The number of consecutive physical addresses occupied by the submap depends on the number of bytes in the physical interface that corresponds to the submap, the number of addresses used in the submap and the number of bytes in the physical interface corresponding to this address map."}
{"type": "text", "page_from": 585, "page_to": 585, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=585", "section_title": "Address Maps", "content": "An address map may be added to multiple address maps if it is accessible from multiple physical interfaces. An address map may only be added to an address map in the grandparent block of the address submap."}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "virtual function void set_sequencer ( uvm_sequencer_base sequencer, uvm_reg_adapter adapter $=$ null )"}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "Set the sequencer and adapter associated with this map. This method must be called before starting any sequences based on uvm_reg_sequence."}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "virtual function void set_submap_offset ( uvm_reg_map submap, uvm_reg_addr_t offset"}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "Set the offset of the given submap to offset."}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "virtual function uvm_reg_addr_t get_submap_offset ( uvm_reg_map submap"}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "Return the offset of the given submap."}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "virtual function void set_base_addr ( uvm_reg_addr_t offset"}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "Set the base address of this map."}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "virtual function void reset( string kind $=$ \"SOFT\""}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "Reset the mirror for all registers in this address map."}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "Sets the mirror value of all registers in this address map and all of its submaps to the reset value corresponding to the specified reset event. See uvm_reg_field::reset() for more details. Does not actually set the value of the registers in the design, only the values mirrored in their corresponding mirror."}
{"type": "text", "page_from": 586, "page_to": 586, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=586", "section_title": "Address Maps", "content": "Note that, unlike the other reset() method, the default reset event for this method is “SOFT”."}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Return the simple object name of this address map."}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Return the hierarchal name of this address map. The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "virtual function uvm_reg_map get_root_map()"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Get the externally-visible address map"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Get the top-most address map where this address map is instantiated. It corresponds to the externally-visible address map that can be accessed by the verification environment."}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "virtual function uvm_reg_block get_parent()"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Get the parent block"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Return the block that is the parent of this address map."}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "virtual function uvm_reg_map get_parent_map()"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Get the higher-level address map"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Return the address map in which this address map is mapped. returns null if this is a top-level address map."}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "virtual function uvm_reg_addr_t get_base_addr ( uvm_hier_e hier $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ UVM_HIER"}
{"type": "text", "page_from": 587, "page_to": 587, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=587", "section_title": "Address Maps", "content": "Get the base offset address for this map. If this map is the root map, the base address is that set with the base_addr argument to uvm_reg_block::create_map(). If this map is a submap of a higher-level map, the base address is offset given this submap by the parent map. See set_submap_offset."}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "virtual function int unsigned get_n_bytes ( uvm_hier_e hier $=$ UVM_HIER"}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "Get the width in bytes of the bus associated with this map. If hier is UVM_HIER, then gets the effective bus width relative to the system level. The effective bus width is the narrowest bus width from this map to the top-level root map. Each bus access will be limited to this bus width."}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "virtual function int unsigned get_addr_unit_bytes()"}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "Get the number of bytes in the smallest addressable unit in the map. Returns 1 if the address map was configured using byte-level addressing. Returns get_n_bytes() otherwise."}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "Gets the endianness of the bus associated with this map. If hier is set to UVM_HIER, gets the system-level endianness."}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "virtual function uvm_sequencer_base get_sequencer uvm_hier_e hier $= ^ { - }$ UVM_HIER"}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "Gets the sequencer for the bus associated with this map. If hier is set to UVM_HIER, gets the sequencer for the bus at the system-level. See set_sequencer."}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "virtual function uvm_reg_adapter get_adapter ( uvm_hier_e hier $= ^ { - }$ UVM_HIER"}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "Gets the bus adapter for the bus associated with this map. If hier is set to UVM_HIER, gets the adapter for the bus used at the system-level. See set_sequencer."}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "virtual function void get_submaps ( ref uvm_reg_map maps[\\$], input uvm_hier_e hier $=$ UVM_HIER )"}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "Get the address sub-maps"}
{"type": "text", "page_from": 588, "page_to": 588, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=588", "section_title": "Address Maps", "content": "Get the address maps instantiated in this address map. If hier is UVM_HIER, recursively includes the address maps, in the sub-maps."}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "Get the registers instantiated in this address map. If hier is UVM_HIER, recursively includes the registers in the sub-maps."}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "Get the fields in the registers instantiated in this address map. If hier is UVM_HIER, recursively includes the fields of the registers in the sub-maps."}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "get_virtual_registers"}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "Get the virtual registers"}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "Get the virtual registers instantiated in this address map. If hier is UVM_HIER, recursively includes the virtual registers in the sub-maps."}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "Get the virtual fields"}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "Get the virtual fields from the virtual registers instantiated in this address map. If hier is UVM_HIER, recursively includes the virtual fields in the virtual registers in the sub-maps."}
{"type": "text", "page_from": 589, "page_to": 589, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=589", "section_title": "Address Maps", "content": "get_physical_addresses"}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "Translate a local address into external addresses"}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "Identify the sequence of addresses that must be accessed physically to access the specified number of bytes at the specified address within this address map. Returns the number of bytes of valid data in each access."}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "Returns in addr a list of address in little endian order, with the granularity of the toplevel address map."}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "A register is specified using a base address with mem_offset as 0. A location within a memory is specified using the base address of the memory and the index of the location within that memory."}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "virtual function uvm_reg get_reg_by_offset( uvm_reg_addr_t offset, bit read = 1"}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "Get register mapped at offset"}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "Identify the register located at the specified offset within this address map for the specified type of access. Returns null if no such register is found."}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "The model must be locked using uvm_reg_block::lock_model() to enable this functionality."}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "virtual function uvm_mem get_mem_by_offset( uvm_reg_addr_t offset"}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "Get memory mapped at offset"}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "Identify the memory located at the specified offset within this address map. The offset may refer to any memory location in that memory. Returns null if no such memory is found."}
{"type": "text", "page_from": 590, "page_to": 590, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=590", "section_title": "Address Maps", "content": "The model must be locked using uvm_reg_block::lock_model() to enable this functionality."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "uvm_reg::predict method is called to update the mirrored value in the register."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "When on is FALSE, bus reads and writes via this map do not automatically update the mirror. For real-time updates to the mirror in this mode, you connect a uvm_reg_predictor instance to the bus monitor. The predictor takes observed bus transactions from the bus monitor, looks up the associated uvm_reg register given the address, then calls that register’s uvm_reg::predict method. While more complex, this mode will capture all register read/write activity, including that not directly descendant from calls to uvm_reg::write and uvm_reg::read."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "By default, auto-prediction is turned off."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "function bit get_auto_predict()"}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "Gets the auto-predict mode setting for this map."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "function void set_check_on_read(bit on 1 ）"}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "Sets the check-on-read mode for his map and all of its submaps."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "When on is TRUE, the register model will automatically check any value read back from a register or field against the current value in its mirror and report any discrepancy. This effectively combines the functionality of the uvm_reg::read() and uvm_reg::mirror(UVM_CHECK) method. This mode is useful when the register model is used passively."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "When on is FALSE, no check is made against the mirrored value."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "At the end of the read operation, the mirror value is updated based on the value that was read regardless of this mode setting."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "By default, auto-prediction is turned off."}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "function bit get_check_on_read()"}
{"type": "text", "page_from": 591, "page_to": 591, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=591", "section_title": "Address Maps", "content": "Gets the check-on-read mode setting for this map."}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "virtual task do_bus_read ( uvm_reg_item rw, uvm_sequencer_base sequencer, uvm_reg_adapter adapter"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "Perform a bus read operation."}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "virtual task do_write( uvm_reg_item rw"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "Perform a write operation."}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "virtual task do_read( uvm_reg_item rw )"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "Perform a read operation."}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "set_transaction_order_policy"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "function void set_transaction_order_policy( uvm_reg_transaction_order_policy pol"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "set the transaction order policy"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "get_transaction_order_policy"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "function uvm_reg_transaction_order_policy get_transaction_order_policy()"}
{"type": "text", "page_from": 592, "page_to": 592, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=592", "section_title": "Address Maps", "content": "set the transaction order policy"}
{"type": "text", "page_from": 593, "page_to": 593, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=593", "section_title": "Register Files", "content": "Register file abstraction base class"}
{"type": "text", "page_from": 593, "page_to": 593, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=593", "section_title": "Register Files", "content": "A register file is a collection of register files and registers used to create regular repeated structures."}
{"type": "text", "page_from": 593, "page_to": 593, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=593", "section_title": "Register Files", "content": "Register files are usually instantiated as arrays."}
{"type": "text", "page_from": 593, "page_to": 593, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=593", "section_title": "Register Files", "content": "Register file abstraction base class"}
{"type": "text", "page_from": 593, "page_to": 593, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=593", "section_title": "Register Files", "content": "new Create a new instance configure Configure a register file instance"}
{"type": "text", "page_from": 593, "page_to": 593, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=593", "section_title": "Register Files", "content": "clear_hdl_path Delete HDL paths add_hdl_path Add an HDL path has_hdl_path Check if a HDL path is specified get_hdl_path Get the incremental HDL path(s) get_full_hdl_path Get the full hierarchical HDL path(s) set_default_hdl_path Set the default design abstraction get_default_hdl_path Get the default design abstraction"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Configure a register file instance"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Specify the parent block and register file of the register file instance. If the register file is instantiated in a block, regfile_parent is specified as null. If the register file is instantiated in a register file, blk_parent must be the block parent of that register file and regfile_parent is specified as that register file."}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "If the register file corresponds to a hierarchical RTL structure, its contribution to the HDL path is specified as the hdl_path. Otherwise, the register file does not correspond to a hierarchical RTL structure (e.g. it is physically flattened) and does not contribute to the hierarchical HDL path of any contained registers."}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Return the simple object name of this register file."}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Return the hierarchal name of this register file. The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "virtual function uvm_reg_block get_parent ()"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Get the parent block"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "virtual function uvm_reg_file get_regfile ()"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Get the parent register file"}
{"type": "text", "page_from": 594, "page_to": 594, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=594", "section_title": "Register Files", "content": "Returns null if this register file is instantiated in a block."}
{"type": "text", "page_from": 595, "page_to": 595, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=595", "section_title": "Register Files", "content": "Remove any previously specified HDL path to the register file instance for the specified design abstraction."}
{"type": "text", "page_from": 595, "page_to": 595, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=595", "section_title": "Register Files", "content": "Add the specified HDL path to the register file instance for the specified design abstraction. This method may be called more than once for the same design abstraction if the register file is physically duplicated in the design abstraction"}
{"type": "text", "page_from": 595, "page_to": 595, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=595", "section_title": "Register Files", "content": "Check if a HDL path is specified"}
{"type": "text", "page_from": 595, "page_to": 595, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=595", "section_title": "Register Files", "content": "Returns TRUE if the register file instance has a HDL path defined for the specified design abstraction. If no design abstraction is specified, uses the default design abstraction specified for the nearest enclosing register file or block"}
{"type": "text", "page_from": 595, "page_to": 595, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=595", "section_title": "Register Files", "content": "If no design abstraction is specified, the default design abstraction for this register file is used."}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "Get the full hierarchical HDL path(s)"}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "Returns the full hierarchical HDL path(s) defined for the specified design abstraction in the register file instance. If no design abstraction is specified, uses the default design abstraction specified for the nearest enclosing register file or block. There may be more than one path returned even if only one path was defined for the register file instance, if any of the parent components have more than one path defined for the same design abstraction"}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "If no design abstraction is specified, the default design abstraction for each ancestor register file or block is used to get each incremental path."}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "set_default_hdl_path"}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "Set the default design abstraction"}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "Set the default design abstraction for this register file instance."}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "get_default_hdl_path"}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "function string get_default_hdl_path ()"}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "Get the default design abstraction"}
{"type": "text", "page_from": 596, "page_to": 596, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=596", "section_title": "Register Files", "content": "Returns the default design abstraction for this register file instance. If a default design abstraction has not been explicitly set for this register file instance, returns the default design abstraction for the nearest register file or block ancestor. Returns “” if no default design abstraction has been specified."}
{"type": "text", "page_from": 597, "page_to": 597, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=597", "section_title": "Registers", "content": "Register abstraction base class"}
{"type": "text", "page_from": 597, "page_to": 597, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=597", "section_title": "Registers", "content": "A register represents a set of fields that are accessible as a single entity."}
{"type": "text", "page_from": 597, "page_to": 597, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=597", "section_title": "Registers", "content": "A register may be mapped to one or more address maps, each with different access rights and policy."}
{"type": "text", "page_from": 597, "page_to": 597, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=597", "section_title": "Registers", "content": "Register abstraction base class"}
{"type": "text", "page_from": 597, "page_to": 597, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=597", "section_title": "Registers", "content": "virtual class uvm_reg extends uvm_object"}
{"type": "text", "page_from": 597, "page_to": 597, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=597", "section_title": "Registers", "content": "new Create a new instance and type-specific configuration configure Instance-specific configuration set_offset Modify the offset of the register"}
{"type": "text", "page_from": 597, "page_to": 597, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=597", "section_title": "Registers", "content": "set Set the desired value for this register get Return the desired value of the fields in the register. get_mirrored_value Return the mirrored value of the fields in the register. needs_update Returns 1 if any of the fields need updating reset Reset the desired/mirrored value for this register. get_reset Get the specified reset value for this register has_reset Check if any field in the register has a reset value specified for the specified reset kind."}
{"type": "text", "page_from": 598, "page_to": 598, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=598", "section_title": "Registers", "content": "post_read Called after register read."}
{"type": "text", "page_from": 598, "page_to": 598, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=598", "section_title": "Registers", "content": "Create a new instance and type-specific configuration"}
{"type": "text", "page_from": 598, "page_to": 598, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=598", "section_title": "Registers", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "Creates an instance of a register abstraction class with the specified name."}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "n_bits specifies the total number of bits in the register. Not all bits need to be implemented. This value is usually a multiple of 8."}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "has_coverage specifies which functional coverage models are present in the extension of the register abstraction class. Multiple functional coverage models may be specified by adding their symbolic names, as defined by the uvm_coverage_model_e type."}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "Instance-specific configuration"}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "Specify the parent block of this register. May also set a parent register file for this register,"}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "If the register is implemented in a single HDL variable, its name is specified as the hdl_path. Otherwise, if the register is implemented as a concatenation of variables (usually one per field), then the HDL path must be specified using the add_hdl_path() or add_hdl_path_slice method."}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "virtual function void set_offset ( uvm_reg_map map, uvm_reg_addr_t offset, bit unmapped = 0"}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "Modify the offset of the register"}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "The offset of a register within an address map is set using the uvm_reg_map::add_reg() method. This method is used to modify that offset dynamically."}
{"type": "text", "page_from": 599, "page_to": 599, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=599", "section_title": "Registers", "content": "Modifying the offset of a register will make the register model diverge from the specification that was used to create it."}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Return the hierarchal name of this register. The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "virtual function uvm_reg_block get_parent ()"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Get the parent block"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "virtual function uvm_reg_file get_regfile ()"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Get the parent register file"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Returns null if this register is instantiated in a block."}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "virtual function int get_n_maps ()"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Returns the number of address maps this register is mapped in"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "function bit is_in_map ( uvm_reg_map map"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Returns 1 if this register is in the specified address map"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "virtual function void get_maps ref uvm_reg_map maps[\\$]"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Returns all of the address maps where this register is mapped"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "virtual function string get_rights ( uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "Returns the accessibility $( \\ \" { \\sf R W } , \\ \\ \" { \\sf R O ^ { \\prime \\prime } }$ , or $\" \\mathsf { W } \\mathsf { O } ^ { \\prime \\prime } )$ of this register in the given map."}
{"type": "text", "page_from": 600, "page_to": 600, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=600", "section_title": "Registers", "content": "If no address map is specified and the register is mapped in only one address map, that address map is used. If the register is mapped in more than one address map, the"}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "default address map of the parent block is used."}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Whether a register field can be read or written depends on both the field’s configured access policy (refer to uvm_reg_field::configure) and the register’s accessibility rights in the map being used to access the field."}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "If an address map is specified and the register is not mapped in the specified address map, an error message is issued and $\\ \" \\mathsf { R W } ^ { \\prime \\prime }$ is returned."}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "virtual function int unsigned get_n_bits ()"}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Returns the width, in bits, of this register."}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "virtual function int unsigned get_n_bytes()"}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Returns the width, in bytes, of this register. Rounds up to next whole byte if register is not a multiple of 8."}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "static function int unsigned get_max_size()"}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Returns the maximum width, in bits, of all registers."}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "virtual function void get_fields ref uvm_reg_field fields[\\$]"}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Return the fields in this register"}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Fills the specified array with the abstraction class for all of the fields contained in this register. Fields are ordered from least-significant position to most-significant position within the register."}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Return the named field in this register"}
{"type": "text", "page_from": 601, "page_to": 601, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=601", "section_title": "Registers", "content": "Finds a field with the specified name in this register and returns its abstraction class. If no fields are found, returns null."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "Returns the offset of this register"}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "Returns the offset of this register in an address map."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "If no address map is specified and the register is mapped in only one address map, that address map is used. If the register is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "If an address map is specified and the register is not mapped in the specified address map, an error message is issued."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "virtual function uvm_reg_addr_t get_address ( uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "Returns the base external physical address of this register"}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "Returns the base external physical address of this register if accessed through the specified address map."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "If no address map is specified and the register is mapped in only one address map, that address map is used. If the register is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "If an address map is specified and the register is not mapped in the specified address map, an error message is issued."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "virtual function int get_addresses ( uvm_reg_map map = null, ref uvm_reg_addr_t addr[]"}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "Identifies the external physical address(es) of this register"}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "Computes all of the external physical addresses that must be accessed to completely read or write this register. The addressed are specified in little endian order. Returns the number of bytes transferred on each access."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "If no address map is specified and the register is mapped in only one address map, that address map is used. If the register is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 602, "page_to": 602, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=602", "section_title": "Registers", "content": "If an address map is specified and the register is not mapped in the specified address map, an error message is issued."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Set the desired value for this register"}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Sets the desired value of the fields in the register to the specified value. Does not actually set the value of the register in the design, only the desired value in its corresponding abstraction class in the RegModel model. Use the uvm_reg::update() method to update the actual register with the mirrored value or the uvm_reg::write() method to set the actual register and its mirrored value."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Unless this method is used, the desired value is equal to the mirrored value."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Refer uvm_reg_field::set() for more details on the effect of setting mirror values on fields with different access policies."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "To modify the mirrored field values to a specific value, and thus use the mirrored as a scoreboard for the register values in the DUT, use the uvm_reg::predict() method."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Return the desired value of the fields in the register."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Does not actually read the value of the register in the design, only the desired value in the abstraction class. Unless set to a different value using the uvm_reg::set(), the desired value and the mirrored value are identical."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Use the uvm_reg::read() or uvm_reg::peek() method to get the actual register value."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "If the register contains write-only fields, the desired/mirrored value for those fields are the value last written and assumed to reside in the bits implementing these fields. Although a physical read operation would something different for these fields, the returned value is the actual content."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Return the mirrored value of the fields in the register."}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "Does not actually read the value of the register in the design"}
{"type": "text", "page_from": 603, "page_to": 603, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=603", "section_title": "Registers", "content": "If the register contains write-only fields, the desired/mirrored value for those fields are the value last written and assumed to reside in the bits implementing these fields. Although a physical read operation would something different for these fields, the returned value is the actual content."}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "virtual function bit needs_update()"}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Returns 1 if any of the fields need updating"}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "See uvm_reg_field::needs_update() for details. Use the uvm_reg::update() to actually update the DUT register."}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Reset the desired/mirrored value for this register."}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Sets the desired and mirror value of the fields in this register to the reset value for the specified reset kind. See uvm_reg_field.reset() for more details."}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Also resets the semaphore that prevents concurrent access to the register. This semaphore must be explicitly reset if a thread accessing this register array was killed in before the access was completed"}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Get the specified reset value for this register"}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Return the reset value for this register for the specified reset kind."}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "virtual function bit has_reset( string kind $=$ \"HARD\" bit delete $\\qquad = \\quad 0$"}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Check if any field in the register has a reset value specified for the specified reset kind. If delete is TRUE, removes the reset value, if any."}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Specify or modify the reset value for this register"}
{"type": "text", "page_from": 604, "page_to": 604, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=604", "section_title": "Registers", "content": "Specify or modify the reset value for all the fields in the register corresponding to the cause specified by kind."}
{"type": "text", "page_from": 605, "page_to": 605, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=605", "section_title": "Registers", "content": "Write the specified value in this register"}
{"type": "text", "page_from": 605, "page_to": 605, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=605", "section_title": "Registers", "content": "Write value in the DUT register that corresponds to this abstraction class instance using the specified access path. If the register is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access). If a back-door access path is used, the effect of writing the register through a physical access is mimicked. For example, read-only bits in the registers will not be written."}
{"type": "text", "page_from": 605, "page_to": 605, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=605", "section_title": "Registers", "content": "The mirrored value will be updated using the uvm_reg::predict() method."}
{"type": "text", "page_from": 605, "page_to": 605, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=605", "section_title": "Registers", "content": "Read the current value from this register"}
{"type": "text", "page_from": 605, "page_to": 605, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=605", "section_title": "Registers", "content": "Read and return value from the DUT register that corresponds to this abstraction class instance using the specified access path. If the register is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access). If a back-door access path is used, the effect of reading the register through a physical access is mimicked. For example, clear-on-read bits in the registers will be set to zero."}
{"type": "text", "page_from": 605, "page_to": 605, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=605", "section_title": "Registers", "content": "The mirrored value will be updated using the uvm_reg::predict() method."}
{"type": "text", "page_from": 605, "page_to": 605, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=605", "section_title": "Registers", "content": "Deposit the specified value in this register"}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "Deposit the value in the DUT register corresponding to this abstraction class instance, asis, using a back-door access."}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "Uses the HDL path for the design abstraction specified by kind."}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "The mirrored value will be updated using the uvm_reg::predict() method."}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "Read the current value from this register"}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "Sample the value in the DUT register corresponding to this abstraction class instance using a back-door access. The register value is sampled, not modified."}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "Uses the HDL path for the design abstraction specified by kind."}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "The mirrored value will be updated using the uvm_reg::predict() method."}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "Updates the content of the register in the design to match the desired value"}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "This method performs the reverse operation of uvm_reg::mirror(). Write this register if the DUT register is out-of-date with the desired/mirrored value in the abstraction class, as determined by the uvm_reg::needs_update() method."}
{"type": "text", "page_from": 606, "page_to": 606, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=606", "section_title": "Registers", "content": "The update can be performed using the using the physical interfaces (frontdoor) or uvm_reg::poke() (backdoor) access. If the register is mapped in multiple address maps and physical access is used (front-door), an address map must be specified."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "Read the register and update/check its mirror value"}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "Read the register and optionally compared the readback value with the current mirrored value if check is UVM_CHECK. The mirrored value will be updated using the uvm_reg::predict() method based on the readback value."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "The mirroring can be performed using the physical interfaces (frontdoor) or uvm_reg::peek() (backdoor)."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "If check is specified as UVM_CHECK, an error message is issued if the current mirrored value does not match the readback value. Any field whose check has been disabled with uvm_reg_field::set_compare() will not be considered in the comparison."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "If the register is mapped in multiple address maps and physical access is used (frontdoor access), an address map must be specified. If the register contains write-only fields, their content is mirrored and optionally checked only if a UVM_BACKDOOR access path is used to read the register."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "Update the mirrored and desired value for this register."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "Predict the mirror (and desired) value of the fields in the register based on the specified observed value on a specified address $m a p$ , or based on a calculated value. See uvm_reg_field::predict() for more details."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "Returns TRUE if the prediction was successful for each field in the register."}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "function bit is_busy()"}
{"type": "text", "page_from": 607, "page_to": 607, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=607", "section_title": "Registers", "content": "Returns 1 if register is currently being read or written."}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "Set a user-defined frontdoor for this register"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "By default, registers are mapped linearly into the address space of the address maps that instantiate them. If registers are accessed using a different mechanism, a user-defined access mechanism must be defined and associated with the corresponding register abstraction class"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "If the register is mapped in multiple address maps, an address map must be specified."}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "function uvm_reg_frontdoor get_frontdoor( uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "Returns the user-defined frontdoor for this register"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "If null, no user-defined frontdoor has been defined. A user-defined frontdoor is defined by using the uvm_reg::set_frontdoor() method."}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "If the register is mapped in multiple address maps, an address map must be specified."}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "Set a user-defined backdoor for this register"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "By default, registers are accessed via the built-in string-based DPI routines if an HDL path has been specified using the uvm_reg::configure() or uvm_reg::add_hdl_path() method."}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "If this default mechanism is not suitable (e.g. because the register is not implemented in pure SystemVerilog) a user-defined access mechanism must be defined and associated with the corresponding register abstraction class"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "A user-defined backdoor is required if active update of the mirror of this register abstraction class, based on observed changes of the corresponding DUT register, is used."}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "function uvm_reg_backdoor get_backdoor( bit inherited $\\dot { { \\bf \\Phi } } = { \\bf \\Phi } 1$"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "Returns the user-defined backdoor for this register"}
{"type": "text", "page_from": 608, "page_to": 608, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=608", "section_title": "Registers", "content": "If null, no user-defined backdoor has been defined. A user-defined backdoor is defined by using the uvm_reg::set_backdoor() method."}
{"type": "text", "page_from": 609, "page_to": 609, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=609", "section_title": "Registers", "content": "If inherited is TRUE, returns the backdoor of the parent block if none have been specified for this register."}
{"type": "text", "page_from": 609, "page_to": 609, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=609", "section_title": "Registers", "content": "function void clear_hdl_path ( string kind $=$ \"RTL\""}
{"type": "text", "page_from": 609, "page_to": 609, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=609", "section_title": "Registers", "content": "Remove any previously specified HDL path to the register instance for the specified design abstraction."}
{"type": "text", "page_from": 609, "page_to": 609, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=609", "section_title": "Registers", "content": "Add the specified HDL path to the register instance for the specified design abstraction. This method may be called more than once for the same design abstraction if the register is physically duplicated in the design abstraction"}
{"type": "text", "page_from": 609, "page_to": 609, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=609", "section_title": "Registers", "content": "For example, the following register"}
{"type": "text", "page_from": 609, "page_to": 609, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=609", "section_title": "Registers", "content": "would be specified using the following literal value"}
{"type": "text", "page_from": 609, "page_to": 609, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=609", "section_title": "Registers", "content": "If the register is implemented using a single HDL variable, The array should specify a single slice with its offset and size specified as -1. For example:"}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Append the specified HDL slice to the HDL path of the register instance for the specified design abstraction. If first is TRUE, starts the specification of a duplicate HDL implementation of the register."}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Check if a HDL path is specified"}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Returns TRUE if the register instance has a HDL path defined for the specified design abstraction. If no design abstraction is specified, uses the default design abstraction specified for the parent block."}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Get the incremental HDL path(s)"}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Returns the HDL path(s) defined for the specified design abstraction in the register instance. Returns only the component of the HDL paths that corresponds to the register, not a full hierarchical path"}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "If no design abstraction is specified, the default design abstraction for the parent block is used."}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Get design abstractions for which HDL paths have been defined"}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Get the full hierarchical HDL path(s)"}
{"type": "text", "page_from": 610, "page_to": 610, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=610", "section_title": "Registers", "content": "Returns the full hierarchical HDL path(s) defined for the specified design abstraction in the register instance. There may be more than one path returned even if only one path was defined for the register instance, if any of the parent components have more than"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "one path defined for the same design abstraction"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "If no design abstraction is specified, the default design abstraction for each ancestor block is used to get each incremental path."}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "virtual task backdoor_read( uvm_reg_item rw"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "User-define backdoor read access"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "Override the default string-based DPI backdoor access read for this register type. By default calls uvm_reg::backdoor_read_func()."}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "virtual task backdoor_write( uvm_reg_item rw )"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "User-defined backdoor read access"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "Override the default string-based DPI backdoor access write for this register type."}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "virtual function uvm_status_e backdoor_read_func( uvm_reg_item rw"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "User-defined backdoor read access"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "Override the default string-based DPI backdoor access read for this register type."}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "virtual task backdoor_watch()"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "User-defined DUT register change monitor"}
{"type": "text", "page_from": 611, "page_to": 611, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=611", "section_title": "Registers", "content": "Watch the DUT register corresponding to this abstraction class instance for any change in value and return when a value-change occurs. This may be implemented a string-based DPI access if the simulation tool provide a value-change callback facility. Such a facility does not exist in the standard SystemVerilog DPI and thus no default implementation for this method can be provided."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "static function void include_coverage( string scope, uvm_reg_cvr_t models, uvm_object accessor $=$ null )"}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "Specify which coverage model that must be included in various block, register or memory abstraction class instances."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "The coverage models are specified by OR’ing or adding the uvm_coverage_model_e coverage model identifiers corresponding to the coverage model to be included."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "The scope specifies a hierarchical name or pattern identifying a block, memory or register abstraction class instances. Any block, memory or register whose full hierarchical name matches the specified scope will have the specified functional coverage models included in them."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "The scope can be specified as a POSIX regular expression or simple pattern. See uvm_resource_base::Scope Interface for more details."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "The specification of which coverage model to include in which abstraction class is stored in a uvm_reg_cvr_t resource in the uvm_resource_db resource database, in the “uvm_reg::” scope namespace."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "protected function uvm_reg_cvr_t build_coverage( uvm_reg_cvr_t models"}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "Check if all of the specified coverage models must be built."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "Check which of the specified coverage model must be built in this instance of the register abstraction class, as specified by calls to uvm_reg::include_coverage()."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e. Returns the sum of all coverage models to be built in the register model."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "virtual protected function void add_coverage( uvm_reg_cvr_t models"}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "Specify that additional coverage models are available."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "Add the specified coverage model to the coverage models available in this class. Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e."}
{"type": "text", "page_from": 612, "page_to": 612, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=612", "section_title": "Registers", "content": "This method shall be called only in the constructor of subsequently derived classes."}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "Check if register has coverage model(s)"}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "Returns TRUE if the register abstraction class contains a coverage model for all of the models specified. Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e."}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "virtual function uvm_reg_cvr_t set_coverage( uvm_reg_cvr_t is_on"}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "Turns on coverage measurement."}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "Turns the collection of functional coverage measurements on or off for this register. The functional coverage measurement is turned on for every coverage model specified using uvm_coverage_model_e symbolic identifiers. Multiple functional coverage models can be specified by adding the functional coverage model identifiers. All other functional coverage models are turned off. Returns the sum of all functional coverage models whose measurements were previously on."}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "This method can only control the measurement of functional coverage models that are present in the register abstraction classes, then enabled during construction. See the uvm_reg::has_coverage() method to identify the available functional coverage models."}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "Check if coverage measurement is on."}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "Returns TRUE if measurement for all of the specified functional coverage models are currently on. Multiple functional coverage models can be specified by adding the functional coverage model identifiers."}
{"type": "text", "page_from": 613, "page_to": 613, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=613", "section_title": "Registers", "content": "See uvm_reg::set_coverage() for more details."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "Empty by default, this method may be extended by the abstraction class generator to perform the required sampling in any provided functional coverage model."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "virtual function void sample_values()"}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "Functional coverage measurement method for field values"}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "This method is invoked by the user or by the uvm_reg_block::sample_values() method of the parent block to trigger the sampling of the current field values in the register-level functional coverage model."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "This method may be extended by the abstraction class generator to perform the required sampling in any provided field-value functional coverage model."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "Called before register write."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "If the specified data value, access path or address map are modified, the updated data value, access path or address map will be used to perform the register operation. If the status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "The registered callback methods are invoked after the invocation of this method. All register callbacks are executed before the corresponding field callbacks"}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "Called after register write."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "If the specified status is modified, the updated status will be returned by the register operation."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "The registered callback methods are invoked before the invocation of this method. All register callbacks are executed before the corresponding field callbacks"}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "Called before register read."}
{"type": "text", "page_from": 614, "page_to": 614, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=614", "section_title": "Registers", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 615, "page_to": 615, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=615", "section_title": "Registers", "content": "If the specified access path or address map are modified, the updated access path or address map will be used to perform the register operation. If the status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 615, "page_to": 615, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=615", "section_title": "Registers", "content": "The registered callback methods are invoked after the invocation of this method. All register callbacks are executed before the corresponding field callbacks"}
{"type": "text", "page_from": 615, "page_to": 615, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=615", "section_title": "Registers", "content": "Called after register read."}
{"type": "text", "page_from": 615, "page_to": 615, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=615", "section_title": "Registers", "content": "If the specified readback data or status is modified, the updated readback data or status will be returned by the register operation."}
{"type": "text", "page_from": 615, "page_to": 615, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=615", "section_title": "Registers", "content": "The registered callback methods are invoked before the invocation of this method. All register callbacks are executed before the corresponding field callbacks"}
{"type": "text", "page_from": 616, "page_to": 616, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=616", "section_title": "Fields", "content": "Field abstraction class"}
{"type": "text", "page_from": 616, "page_to": 616, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=616", "section_title": "Fields", "content": "A field represents a set of bits that behave consistently as a single entity."}
{"type": "text", "page_from": 616, "page_to": 616, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=616", "section_title": "Fields", "content": "A field is contained within a single register, but may have different access policies depending on the address map use the access the register (thus the field)."}
{"type": "text", "page_from": 616, "page_to": 616, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=616", "section_title": "Fields", "content": "Field abstraction class"}
{"type": "text", "page_from": 616, "page_to": 616, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=616", "section_title": "Fields", "content": "Mirrored field value."}
{"type": "text", "page_from": 616, "page_to": 616, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=616", "section_title": "Fields", "content": "new Create a new field instance configure Instance-specific configuration"}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "rand uvm_reg_data_t value"}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "Mirrored field value. This value can be sampled in a functional coverage model or constrained when randomized."}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "Create a new field instance"}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "This method should not be used directly. The uvm_reg_field::type_id::create() factory method should be used instead."}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "Instance-specific configuration"}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "Specify the parent register of this field, its size in bits, the position of its least-significant bit within the register relative to the least-significant bit of the register, its access policy, volatility, “HARD” reset value, whether the field value is actually reset (the reset value is ignored if FALSE), whether the field value may be randomized and whether the field is the only one to occupy a byte lane in the register."}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "See set_access for a specification of the pre-defined field access policies."}
{"type": "text", "page_from": 617, "page_to": 617, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=617", "section_title": "Fields", "content": "If the field access policy is a pre-defined policy and NOT one of $\\ \" { \\sf R W } ^ { \\prime \\prime } , \\ \\ \" { \\sf W R C } ^ { \\prime \\prime } , \\ \\ \" { \\sf W R S } ^ { \\prime \\prime } ,$ “WO”, “W1”, or $\" \\mathrm { w o } 1 \\prime$ , the value of is_rand is ignored and the rand_mode() for the field instance is turned off since it cannot be written."}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Return the simple object name of this field"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Return the hierarchal name of this field The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "virtual function uvm_reg get_parent()"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Get the parent register"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "virtual function int unsigned get_lsb_pos()"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Return the position of the field"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Returns the index of the least significant bit of the field in the register that instantiates it. An offset of 0 indicates a field that is aligned with the least-significant bit of the register."}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "virtual function int unsigned get_n_bits()"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Returns the width, in number of bits, of the field."}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "static function int unsigned get_max_size()"}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "Returns the width, in number of bits, of the largest field."}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "virtual function string set_access("}
{"type": "text", "page_from": 618, "page_to": 618, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=618", "section_title": "Fields", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 619, "page_to": 619, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=619", "section_title": "Fields", "content": "Modify the access policy of the field"}
{"type": "text", "page_from": 619, "page_to": 619, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=619", "section_title": "Fields", "content": "Modify the access policy of the field to the specified one and return the previous access policy."}
{"type": "text", "page_from": 619, "page_to": 619, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=619", "section_title": "Fields", "content": "The pre-defined access policies are as follows. The effect of a read operation are applied after the current value of the field is sampled. The read operation will return the current value, not the value affected by the read operation (if any)."}
{"type": "text", "page_from": 619, "page_to": 619, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=619", "section_title": "Fields", "content": "”RO” W: no effect, R: no effect ”RW” W: as-is, R: no effect ”RC” W: no effect, R: clears all bits ”RS” W: no effect, R: sets all bits ”WRC” W: as-is, R: clears all bits ”WRS” W: as-is, R: sets all bits ”WC” W: clears all bits, R: no effect ”WS” W: sets all bits, R: no effect ”WSRC” W: sets all bits, R: clears all bits ”WCRS” W: clears all bits, R: sets all bits ”W1C” W: 1/0 clears/no effect on matching bit, R: no effect ”W1S” W: 1/0 sets/no effect on matching bit, R: no effect ”W1T” W: 1/0 toggles/no effect on matching bit, R: no effect ”W0C” W: 1/0 no effect on/clears matching bit, R: no effect ”W0S” W: 1/0 no effect on/sets matching bit, R: no effect ”W0T” W: 1/0 no effect on/toggles matching bit, R: no effect ”W1SRC” W: 1/0 sets/no effect on matching bit, R: clears all bits ”W1CRS” W: 1/0 clears/no effect on matching bit, R: sets all bits ”W0SRC” W: 1/0 no effect on/sets matching bit, R: clears all bits ”W0CRS” W: 1/0 no effect on/clears matching bit, R: sets all bits ”WO” W: as-is, R: error ”WOC” W: clears all bits, R: error ”WOS” W: sets all bits, R: error ”W1” W: first one after HARD reset is as-is, other W have no e R: no effect ”WO1” W: first one after HARD reset is as-is, other W have no e R: error ”NOACCESS” W: no effect, R: no effect"}
{"type": "text", "page_from": 619, "page_to": 619, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=619", "section_title": "Fields", "content": "It is important to remember that modifying the access of a field will make the register model diverge from the specification that was used to create it."}
{"type": "text", "page_from": 619, "page_to": 619, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=619", "section_title": "Fields", "content": "static function bit define_access( string name"}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Define a new access policy value"}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Because field access policies are specified using string values, there is no way for SystemVerilog to verify if a specific access value is valid or not. To help catch typing errors, user-defined access values must be defined using this method to avoid begin reported as an invalid access policy."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "The name of field access policies are always converted to all uppercase."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Returns TRUE if the new access policy was not previously defined. Returns FALSE otherwise but does not issue an error message."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "virtual function string get_access( uvm_reg_map map $=$ nul"}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Get the access policy of the field"}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Returns the current access policy of the field when written and read through the specified address map. If the register containing the field is mapped in multiple address map, an address map must be specified. The access policy of a field from a specific address map may be restricted by the register’s access policy in that address map. For example, a RW field may only be writable through one of the address maps and read-only through all of the other maps. If the field access contradicts the map’s access value (field access of WO, and map access value of RO, etc), the method’s return value is NOACCESS."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Check if access policy is a built-in one."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Returns TRUE if the current access policy of the field, when written and read through the specified address map, is a built-in access policy."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "virtual function void set_volatility( bit volatile"}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Modify the volatility of the field to the specified one."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "It is important to remember that modifying the volatility of a field will make the register model diverge from the specification that was used to create it."}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "virtual function bit is_volatile()"}
{"type": "text", "page_from": 620, "page_to": 620, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=620", "section_title": "Fields", "content": "Indicates if the field value is volatile"}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "UVM uses the IEEE 1685-2009 IP-XACT definition of “volatility”. If TRUE, the value of the register is not predictable because it may change between consecutive accesses. This typically indicates a field whose value is updated by the DUT. The nature or cause of the change is not specified. If FALSE, the value of the register is not modified between consecutive accesses."}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "Set the desired value for this field"}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "It sets the desired value of the field to the specified value modified by the field access policy. It does not actually set the value of the field in the design, only the desired value in the abstraction class. Use the uvm_reg::update() method to update the actual register with the desired value or the uvm_reg_field::write() method to actually write the field and update its mirrored value."}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "The final desired value in the mirror is a function of the field access policy and the set value, just like a normal physical write operation to the corresponding bits in the hardware. As such, this method (when eventually followed by a call to uvm_reg::update()) is a zero-time functional replacement for the uvm_reg_field::write() method. For example, the desired value of a read-only field is not modified by this method and the desired value of a write-once field can only be set if the field has not yet been written to using a physical (for example, front-door) write operation."}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "Use the uvm_reg_field::predict() to modify the mirrored value of the field."}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "Return the desired value of the field"}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "It does not actually read the value of the field in the design, only the desired value in the abstraction class. Unless set to a different value using the uvm_reg_field::set(), the desired value and the mirrored value are identical."}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "Use the uvm_reg_field::read() or uvm_reg_field::peek() method to get the actual field value."}
{"type": "text", "page_from": 621, "page_to": 621, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=621", "section_title": "Fields", "content": "If the field is write-only, the desired/mirrored value is the value last written and assumed to reside in the bits implementing it. Although a physical read operation would something different, the returned value is the actual content."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "Return the mirrored value of the field"}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "It does not actually read the value of the field in the design, only the mirrored value in the abstraction class."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "If the field is write-only, the desired/mirrored value is the value last written and assumed to reside in the bits implementing it. Although a physical read operation would something different, the returned value is the actual content."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "Reset the desired/mirrored value for this field."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "It sets the desired and mirror value of the field to the reset event specified by kind. If the field does not have a reset value specified for the specified reset kind the field is unchanged."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "It does not actually reset the value of the field in the design, only the value mirrored in the field abstraction class."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "Write-once fields can be modified after a “HARD” reset operation."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "Get the specified reset value for this field"}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "Return the reset value for this field for the specified reset kind. Returns the current field value is no reset value has been specified for the specified reset event."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "Check if the field has a reset value specified"}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "Return TRUE if this field has a reset value specified for the specified reset kind. If delete is TRUE, removes the reset value, if any."}
{"type": "text", "page_from": 622, "page_to": 622, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=622", "section_title": "Fields", "content": "virtual function void set_reset("}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "Specify or modify the reset value for this field"}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "Specify or modify the reset value for this field corresponding to the cause specified by kind."}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "virtual function bit needs_update()"}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "Check if the abstract model contains different desired and mirrored values."}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "If a desired field value has been modified in the abstraction class without actually updating the field in the DUT, the state of the DUT (more specifically what the abstraction class thinks the state of the DUT is) is outdated. This method returns TRUE if the state of the field in the DUT needs to be updated to match the desired value. The mirror values or actual content of DUT field are not modified. Use the uvm_reg::update() to actually update the DUT field."}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "Write the specified value in this field"}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "Write value in the DUT field that corresponds to this abstraction class instance using the specified access path. If the register containing this field is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access). If a back-door access path is used, the effect of writing the field through a physical access is mimicked. For example, read-only bits in the field will not be written."}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "The mirrored value will be updated using the uvm_reg_field::predict() method."}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "If a front-door access is used, and if the field is the only field in a byte lane and if the physical interface corresponding to the address map used to access the field support byte-enabling, then only the field is written. Otherwise, the entire register containing the field is written, and the mirrored values of the other fields in the same register are used in a best-effort not to modify their value."}
{"type": "text", "page_from": 623, "page_to": 623, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=623", "section_title": "Fields", "content": "If a backdoor access is used, a peek-modify-poke process is used. in a best-effort not to modify the value of the other fields in the register."}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "Read the current value from this field"}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "Read and return value from the DUT field that corresponds to this abstraction class instance using the specified access path. If the register containing this field is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access). If a back-door access path is used, the effect of reading the field through a physical access is mimicked. For example, clear-on-read bits in the field will be set to zero."}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "The mirrored value will be updated using the uvm_reg_field::predict() method."}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "If a front-door access is used, and if the field is the only field in a byte lane and if the physical interface corresponding to the address map used to access the field support byte-enabling, then only the field is read. Otherwise, the entire register containing the field is read, and the mirrored values of the other fields in the same register are updated."}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "If a backdoor access is used, the entire containing register is peeked and the mirrored value of the other fields in the register is updated."}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "Deposit the specified value in this field"}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "Deposit the value in the DUT field corresponding to this abstraction class instance, as-is, using a back-door access. A peek-modify-poke process is used in a best-effort not to modify the value of the other fields in the register."}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "The mirrored value will be updated using the uvm_reg_field::predict() method."}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "Read the current value from this field"}
{"type": "text", "page_from": 624, "page_to": 624, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=624", "section_title": "Fields", "content": "Sample the value in the DUT field corresponding to this abstraction class instance using a"}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "back-door access. The field value is sampled, not modified."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "Uses the HDL path for the design abstraction specified by kind."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "The entire containing register is peeked and the mirrored value of the other fields in the register are updated using the uvm_reg_field::predict() method."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "Read the field and update/check its mirror value"}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "Read the field and optionally compared the readback value with the current mirrored value if check is UVM_CHECK. The mirrored value will be updated using the predict() method based on the readback value."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "The path argument specifies whether to mirror using the UVM_FRONTDOOR (read) or UVM_BACKDOOR (peek())."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "If check is specified as UVM_CHECK, an error message is issued if the current mirrored value does not match the readback value, unless set_compare was used disable the check."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "If the containing register is mapped in multiple address maps and physical access is used (front-door access), an address map must be specified. For write-only fields, their content is mirrored and optionally checked only if a UVM_BACKDOOR access path is used to read the field."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "function void set_compare( uvm_check_e check $=$ UVM_CHECK"}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "Sets the compare policy during a mirror update. The field value is checked against its mirror only when both the check argument in uvm_reg_block::mirror, uvm_reg::mirror, or uvm_reg_field::mirror and the compare policy for the field is UVM_CHECK."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "function uvm_check_e get_compare()"}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "Returns the compare policy for this field."}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "function bit is indv accessible ("}
{"type": "text", "page_from": 625, "page_to": 625, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=625", "section_title": "Fields", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "uvm_path_e path, uvm_reg_map local_map )"}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "Check if this field can be written individually, i.e. without affecting other fields in the containing register."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "Update the mirrored and desired value for this field."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "Predict the mirror and desired value of the field based on the specified observed value on a bus using the specified address map."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "If kind is specified as UVM_PREDICT_READ, the value was observed in a read transaction on the specified address map or backdoor (if path is UVM_BACKDOOR). If kind is specified as UVM_PREDICT_WRITE, the value was observed in a write transaction on the specified address map or backdoor (if path is UVM_BACKDOOR). If kind is specified as UVM_PREDICT_DIRECT, the value was computed and is updated as-is, without regard to any access policy. For example, the mirrored value of a read-only field is modified by this method if kind is specified as UVM_PREDICT_DIRECT."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "This method does not allow an update of the mirror (or desired) when the register containing this field is busy executing a transaction because the results are unpredictable and indicative of a race condition in the testbench."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "Returns TRUE if the prediction was successful."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "Called before field write."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "If the specified data value, access path or address map are modified, the updated data value, access path or address map will be used to perform the register operation. If the status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 626, "page_to": 626, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=626", "section_title": "Fields", "content": "The field callback methods are invoked after the callback methods on the containing register. The registered callback methods are invoked after the invocation of this method."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "Called after field write."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "If the specified status is modified, the updated status will be returned by the register operation."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "The field callback methods are invoked after the callback methods on the containing register. The registered callback methods are invoked before the invocation of this method."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "Called before field read."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "If the access path or address map in the rw argument are modified, the updated access path or address map will be used to perform the register operation. If the status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "The field callback methods are invoked after the callback methods on the containing register. The registered callback methods are invoked after the invocation of this method."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "Called after field read."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "If the specified readback data or\\~status\\~ in the rw argument is modified, the updated readback data or status will be returned by the register operation."}
{"type": "text", "page_from": 627, "page_to": 627, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=627", "section_title": "Fields", "content": "The field callback methods are invoked after the callback methods on the containing register. The registered callback methods are invoked before the invocation of this method."}
{"type": "text", "page_from": 628, "page_to": 628, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=628", "section_title": "Memories", "content": "Memory abstraction base class"}
{"type": "text", "page_from": 628, "page_to": 628, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=628", "section_title": "Memories", "content": "A memory is a collection of contiguous locations. A memory may be accessible via more than one address map."}
{"type": "text", "page_from": 628, "page_to": 628, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=628", "section_title": "Memories", "content": "Unlike registers, memories are not mirrored because of the potentially large data space: tests that walk the entire memory space would negate any benefit from sparse memory modelling techniques. Rather than relying on a mirror, it is recommended that backdoor access be used instead."}
{"type": "text", "page_from": 628, "page_to": 628, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=628", "section_title": "Memories", "content": "Memory abstraction base class"}
{"type": "text", "page_from": 628, "page_to": 628, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=628", "section_title": "Memories", "content": "class uvm_mem extends uvm_object"}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "Create a new instance and type-specific configuration"}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "Creates an instance of a memory abstraction class with the specified name."}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "size specifies the total number of memory locations. n_bits specifies the total number of bits in each memory location. access specifies the access policy of this memory and may be one of “RW for RAMs and $\\ \" \\mathsf { R O } ^ { \\prime \\prime }$ for ROMs."}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "has_coverage specifies which functional coverage models are present in the extension of the register abstraction class. Multiple functional coverage models may be specified by adding their symbolic names, as defined by the uvm_coverage_model_e type."}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "Instance-specific configuration"}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "Specify the parent block of this memory."}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "If this memory is implemented in a single HDL variable, its name is specified as the hdl_path. Otherwise, if the memory is implemented as a concatenation of variables (usually one per bank), then the HDL path must be specified using the add_hdl_path() or add_hdl_path_slice() method."}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "Modify the offset of the memory"}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "The offset of a memory within an address map is set using the uvm_reg_map::add_mem() method. This method is used to modify that offset dynamically."}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "Modifying the offset of a memory will make the abstract model"}
{"type": "text", "page_from": 630, "page_to": 630, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=630", "section_title": "Memories", "content": "diverge from the specification that was used to create it."}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "Memory allocation manager for the memory corresponding to this abstraction class instance. Can be used to allocate regions of consecutive addresses of specific sizes, such as DMA buffers, or to locate virtual register array."}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "Return the simple object name of this memory."}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "Return the hierarchal name of this memory. The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "virtual function uvm_reg_block get_parent ()"}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "Get the parent block"}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "virtual function int get_n_maps ()"}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "Returns the number of address maps this memory is mapped in"}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "function bit is_in_map ( uvm_reg_map map )"}
{"type": "text", "page_from": 631, "page_to": 631, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=631", "section_title": "Memories", "content": "Return TRUE if this memory is in the specified address map"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "virtual function string get_rights uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "Returns the access rights of this memory."}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "Returns $\\ \" \\mathsf { R W } ^ { \\prime \\prime }$ , $\\ \" \\mathsf { R O } ^ { \\prime \\prime }$ or $\\ \" \\mathsf { W O ^ { \\prime \\prime } }$ . The access rights of a memory is always $\\ \" \\mathsf { R W } ^ { \\prime \\prime }$ , unless it is a shared memory with access restriction in a particular address map."}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "If no address map is specified and the memory is mapped in only one address map, that address map is used. If the memory is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "If an address map is specified and the memory is not mapped in the specified address map, an error message is issued and $\\ \" \\mathsf { R W } ^ { \\prime \\prime }$ is returned."}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "virtual function string get_access( uvm_reg_map map $=$ nul"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "Returns the access policy of the memory when written and read via an address map."}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "If the memory is mapped in more than one address map, an address map must be specified. If access restrictions are present when accessing a memory through the specified address map, the access mode returned takes the access restrictions into account. For example, a read-write memory accessed through a domain with read-only restrictions would return $\\ \" \\mathsf { R O } ^ { \\prime \\prime }$ ."}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "function longint unsigned get_size()"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "Returns the number of unique memory locations in this memory."}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "function int unsigned get_n_bytes()"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "Return the width, in number of bytes, of each memory location"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "function int unsigned get_n_bits()"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "Returns the width, in number of bits, of each memory location"}
{"type": "text", "page_from": 632, "page_to": 632, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=632", "section_title": "Memories", "content": "static function int unsigned get_max_size()"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Returns the maximum width, in number of bits, of all memories"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "get_virtual_registers"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "virtual function void get_virtual_registers( ref uvm_vreg regs[\\$]"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Return the virtual registers in this memory"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Fills the specified array with the abstraction class for all of the virtual registers implemented in this memory. The order in which the virtual registers are located in the array is not specified."}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Return the virtual fields in the memory"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Fills the specified dynamic array with the abstraction class for all of the virtual fields implemented in this memory. The order in which the virtual fields are located in the array is not specified."}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "virtual function uvm_vreg get_vreg_by_name( string name"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Find the named virtual register"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Finds a virtual register with the specified name implemented in this memory and returns its abstraction class instance. If no virtual register with the specified name is found, returns null."}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Find the named virtual field"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "Finds a virtual field with the specified name implemented in this memory and returns its abstraction class instance. If no virtual field with the specified name is found, returns null."}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "virtual function uvm_vreg get_vreg_by_offset( uvm_reg_addr_t offset,"}
{"type": "text", "page_from": 633, "page_to": 633, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=633", "section_title": "Memories", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Find the virtual register implemented at the specified offset"}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Finds the virtual register implemented in this memory at the specified offset in the specified address map and returns its abstraction class instance. If no virtual register at the offset is found, returns null."}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Returns the base offset of a memory location"}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Returns the base offset of the specified location in this memory in an address map."}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "If no address map is specified and the memory is mapped in only one address map, that address map is used. If the memory is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "If an address map is specified and the memory is not mapped in the specified address map, an error message is issued."}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Returns the base external physical address of a memory location"}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Returns the base external physical address of the specified location in this memory if accessed through the specified address map."}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "If no address map is specified and the memory is mapped in only one address map, that address map is used. If the memory is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "If an address map is specified and the memory is not mapped in the specified address map, an error message is issued."}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "virtual function int get_addresses( uvm_reg_addr_t offset $=$ 0, uvm_reg_map map $=$ null, ref uvm_reg_addr_t addr[] )"}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Identifies the external physical address(es) of a memory location"}
{"type": "text", "page_from": 634, "page_to": 634, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=634", "section_title": "Memories", "content": "Computes all of the external physical addresses that must be accessed to completely read or write the specified location in this memory. The addressed are specified in little endian order. Returns the number of bytes transferred on each access."}
{"type": "text", "page_from": 635, "page_to": 635, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=635", "section_title": "Memories", "content": "If no address map is specified and the memory is mapped in only one address map, that address map is used. If the memory is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 635, "page_to": 635, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=635", "section_title": "Memories", "content": "If an address map is specified and the memory is not mapped in the specified address map, an error message is issued."}
{"type": "text", "page_from": 635, "page_to": 635, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=635", "section_title": "Memories", "content": "Write the specified value in a memory location"}
{"type": "text", "page_from": 635, "page_to": 635, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=635", "section_title": "Memories", "content": "Write value in the memory location that corresponds to this abstraction class instance at the specified offset using the specified access path. If the memory is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access). If a back-door access path is used, the effect of writing the register through a physical access is mimicked. For example, a read-only memory will not be written."}
{"type": "text", "page_from": 635, "page_to": 635, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=635", "section_title": "Memories", "content": "Read the current value from a memory location"}
{"type": "text", "page_from": 635, "page_to": 635, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=635", "section_title": "Memories", "content": "Read and return value from the memory location that corresponds to this abstraction class instance at the specified offset using the specified access path. If the register is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access)."}
{"type": "text", "page_from": 636, "page_to": 636, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=636", "section_title": "Memories", "content": "Write the specified values in memory locations"}
{"type": "text", "page_from": 636, "page_to": 636, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=636", "section_title": "Memories", "content": "Burst-write the specified values in the memory locations beginning at the specified offset. If the memory is mapped in more than one address map, an address map must be specified if not using the backdoor. If a back-door access path is used, the effect of writing the register through a physical access is mimicked. For example, a read-only memory will not be written."}
{"type": "text", "page_from": 636, "page_to": 636, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=636", "section_title": "Memories", "content": "Read values from memory locations"}
{"type": "text", "page_from": 636, "page_to": 636, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=636", "section_title": "Memories", "content": "Burst-read into values the data the memory locations beginning at the specified offset. If the memory is mapped in more than one address map, an address map must be specified if not using the backdoor. If a back-door access path is used, the effect of writing the register through a physical access is mimicked. For example, a read-only memory will not be written."}
{"type": "text", "page_from": 636, "page_to": 636, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=636", "section_title": "Memories", "content": "Deposit the specified value in a memory location"}
{"type": "text", "page_from": 636, "page_to": 636, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=636", "section_title": "Memories", "content": "Deposit the value in the DUT memory location corresponding to this abstraction class instance at the specified offset, as-is, using a back-door access."}
{"type": "text", "page_from": 636, "page_to": 636, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=636", "section_title": "Memories", "content": "Uses the HDL path for the design abstraction specified by kind."}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "Read the current value from a memory location"}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "Sample the value in the DUT memory location corresponding to this abstraction class instance at the specified offset using a back-door access. The memory location value is sampled, not modified."}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "Uses the HDL path for the design abstraction specified by kind."}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "Set a user-defined frontdoor for this memory"}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "By default, memories are mapped linearly into the address space of the address maps that instantiate them. If memories are accessed using a different mechanism, a userdefined access mechanism must be defined and associated with the corresponding memory abstraction class"}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "If the memory is mapped in multiple address maps, an address map must be specified."}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "function uvm_reg_frontdoor get_frontdoor( uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "Returns the user-defined frontdoor for this memory"}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "If null, no user-defined frontdoor has been defined. A user-defined frontdoor is defined by using the uvm_mem::set_frontdoor() method."}
{"type": "text", "page_from": 637, "page_to": 637, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=637", "section_title": "Memories", "content": "If the memory is mapped in multiple address maps, an address map must be specified."}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "Set a user-defined backdoor for this memory"}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "By default, memories are accessed via the built-in string-based DPI routines if an HDL path has been specified using the uvm_mem::configure() or uvm_mem::add_hdl_path() method. If this default mechanism is not suitable (e.g. because the memory is not implemented in pure SystemVerilog) a user-defined access mechanism must be defined and associated with the corresponding memory abstraction class"}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "Returns the user-defined backdoor for this memory"}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "If null, no user-defined backdoor has been defined. A user-defined backdoor is defined by using the uvm_reg::set_backdoor() method."}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "If inherit is TRUE, returns the backdoor of the parent block if none have been specified for this memory."}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "Remove any previously specified HDL path to the memory instance for the specified design abstraction."}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "Add the specified HDL path to the memory instance for the specified design abstraction. This method may be called more than once for the same design abstraction if the memory is physically duplicated in the design abstraction"}
{"type": "text", "page_from": 638, "page_to": 638, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=638", "section_title": "Memories", "content": "function void add_hdl_path_slice( string name, int offset,"}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "Add the specified HDL slice to the HDL path for the specified design abstraction. If first is TRUE, starts the specification of a duplicate HDL implementation of the memory."}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "Check if a HDL path is specified"}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "Returns TRUE if the memory instance has a HDL path defined for the specified design abstraction. If no design abstraction is specified, uses the default design abstraction specified for the parent block."}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "Get the incremental HDL path(s)"}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "Returns the HDL path(s) defined for the specified design abstraction in the memory instance. Returns only the component of the HDL paths that corresponds to the memory, not a full hierarchical path"}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "If no design abstraction is specified, the default design abstraction for the parent block is used."}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "Get the full hierarchical HDL path(s)"}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "Returns the full hierarchical HDL path(s) defined for the specified design abstraction in the memory instance. There may be more than one path returned even if only one path was defined for the memory instance, if any of the parent components have more than one path defined for the same design abstraction"}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "If no design abstraction is specified, the default design abstraction for each ancestor block is used to get each incremental path."}
{"type": "text", "page_from": 639, "page_to": 639, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=639", "section_title": "Memories", "content": "function void get_hdl_path_kinds ( ref string kinds[\\$]"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "Get design abstractions for which HDL paths have been defined"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "virtual protected task backdoor_read( uvm_reg_item rw"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "User-define backdoor read access"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "Override the default string-based DPI backdoor access read for this memory type. By default calls uvm_mem::backdoor_read_func()."}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "virtual task backdoor_write( uvm_reg_item rw"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "User-defined backdoor read access"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "Override the default string-based DPI backdoor access write for this memory type."}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "virtual function uvm_status_e backdoor_read_func( uvm_reg_item rw"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "User-defined backdoor read access"}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "Override the default string-based DPI backdoor access read for this memory type."}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "Called before memory write."}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "If the offset, value, access path, or address map are modified, the updated offset, data value, access path or address map will be used to perform the memory operation. If the status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 640, "page_to": 640, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=640", "section_title": "Memories", "content": "The registered callback methods are invoked after the invocation of this method."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "Called after memory write."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "If the status is modified, the updated status will be returned by the memory operation."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "The registered callback methods are invoked before the invocation of this method."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "Called before memory read."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "If the offset, access path or address map are modified, the updated offset, access path or address map will be used to perform the memory operation. If the status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "The registered callback methods are invoked after the invocation of this method."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "Called after memory read."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "If the readback data or status is modified, the updated readback //data or status will be returned by the memory operation."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "The registered callback methods are invoked before the invocation of this method."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "protected function uvm_reg_cvr_t build_coverage( uvm_reg_cvr_t models"}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "Check if all of the specified coverage model must be built."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "Check which of the specified coverage model must be built in this instance of the memory abstraction class, as specified by calls to uvm_reg::include_coverage()."}
{"type": "text", "page_from": 641, "page_to": 641, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=641", "section_title": "Memories", "content": "Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e. Returns the sum of all coverage models to be built in the memory model."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "virtual protected function void add_coverage( uvm_reg_cvr_t models"}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Specify that additional coverage models are available."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Add the specified coverage model to the coverage models available in this class. Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "This method shall be called only in the constructor of subsequently derived classes."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "virtual function bit has_coverage( uvm_reg_cvr_t models"}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Check if memory has coverage model(s)"}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Returns TRUE if the memory abstraction class contains a coverage model for all of the models specified. Models are specified by adding the symbolic value of individual coverage model as defined in uvm_coverage_model_e."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "virtual function uvm_reg_cvr_t set_coverage( uvm_reg_cvr_t is_on"}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Turns on coverage measurement."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Turns the collection of functional coverage measurements on or off for this memory. The functional coverage measurement is turned on for every coverage model specified using uvm_coverage_model_e symbolic identifiers. Multiple functional coverage models can be specified by adding the functional coverage model identifiers. All other functional coverage models are turned off. Returns the sum of all functional coverage models whose measurements were previously on."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "This method can only control the measurement of functional coverage models that are present in the memory abstraction classes, then enabled during construction. See the uvm_mem::has_coverage() method to identify the available functional coverage models."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Check if coverage measurement is on."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "Returns TRUE if measurement for all of the specified functional coverage models are currently on. Multiple functional coverage models can be specified by adding the functional coverage model identifiers."}
{"type": "text", "page_from": 642, "page_to": 642, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=642", "section_title": "Memories", "content": "See uvm_mem::set_coverage() for more details."}
{"type": "text", "page_from": 643, "page_to": 643, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=643", "section_title": "Memories", "content": "Functional coverage measurement method"}
{"type": "text", "page_from": 643, "page_to": 643, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=643", "section_title": "Memories", "content": "This method is invoked by the memory abstraction class whenever an address within one of its address map is successfully read or written. The specified offset is the offset within the memory, not an absolute address."}
{"type": "text", "page_from": 643, "page_to": 643, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=643", "section_title": "Memories", "content": "Empty by default, this method may be extended by the abstraction class generator to perform the required sampling in any provided functional coverage model."}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "uvm_reg_indirect_data", "header_path": ["25", "7"], "chapter": "25", "section": "25.7", "content": "25.7 uvm_reg_indirect_data"}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "Indirect data access abstraction class"}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "Models the behavior of a register used to indirectly access a register array, indexed by a second address register."}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "This class should not be instantiated directly. A type-specific class extension should be used to provide a factory-enabled constructor and specify the n_bits and coverage models."}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "uvm_reg_indirect_data"}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "Indirect data access abstraction class"}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "class uvm_reg_indirect_data extends uvm_reg"}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "new Create an instance of this class configure Configure the indirect data register."}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "Create an instance of this class"}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "Should not be called directly, other than via super.new(). The value of n_bits must match the number of bits in the indirect register array."}
{"type": "text", "page_from": 644, "page_to": 644, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=644", "section_title": "Indirect Registers", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 645, "page_to": 645, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=645", "section_title": "Indirect Registers", "content": "Configure the indirect data register."}
{"type": "text", "page_from": 645, "page_to": 645, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=645", "section_title": "Indirect Registers", "content": "The idx register specifies the index, in the reg_a register array, of the register to access. The idx must be written to first. A read or write operation to this register will subsequently read or write the indexed register in the register array."}
{"type": "text", "page_from": 645, "page_to": 645, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=645", "section_title": "Indirect Registers", "content": "The number of bits in each register in the register array must be equal to n_bits of this register."}
{"type": "text", "page_from": 645, "page_to": 645, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=645", "section_title": "Indirect Registers", "content": "See uvm_reg::configure() for the remaining arguments."}
{"type": "text", "page_from": 646, "page_to": 646, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=646", "section_title": "FIFO Registers", "content": "This special register models a DUT FIFO accessed via write/read, where writes push to the FIFO and reads pop from it."}
{"type": "text", "page_from": 646, "page_to": 646, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=646", "section_title": "FIFO Registers", "content": "Backdoor access is not enabled, as it is not yet possible to force complete FIFO state, i.e. the write and read indexes used to access the FIFO data."}
{"type": "text", "page_from": 646, "page_to": 646, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=646", "section_title": "FIFO Registers", "content": "This special register models a DUT FIFO accessed via write/read, where writes push to the FIFO and reads pop from it."}
{"type": "text", "page_from": 646, "page_to": 646, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=646", "section_title": "FIFO Registers", "content": "rand uvm_reg_data_t fifo[\\$]"}
{"type": "text", "page_from": 646, "page_to": 646, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=646", "section_title": "FIFO Registers", "content": "The abstract representation of the FIFO. Constrained to be no larger than the size"}
{"type": "text", "page_from": 647, "page_to": 647, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=647", "section_title": "FIFO Registers", "content": "parameter. It is public to enable subtypes to add constraints on it and randomize."}
{"type": "text", "page_from": 647, "page_to": 647, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=647", "section_title": "FIFO Registers", "content": "Creates an instance of a FIFO register having size elements of n_bits each."}
{"type": "text", "page_from": 647, "page_to": 647, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=647", "section_title": "FIFO Registers", "content": "Sets the compare policy during a mirror (read) of the DUT FIFO. The DUT read value is checked against its mirror only when both the check argument in the mirror() call and the compare policy for the field is UVM_CHECK."}
{"type": "text", "page_from": 647, "page_to": 647, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=647", "section_title": "FIFO Registers", "content": "function int unsigned size()"}
{"type": "text", "page_from": 647, "page_to": 647, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=647", "section_title": "FIFO Registers", "content": "The number of entries currently in the FIFO."}
{"type": "text", "page_from": 647, "page_to": 647, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=647", "section_title": "FIFO Registers", "content": "function int unsigned capacity()"}
{"type": "text", "page_from": 647, "page_to": 647, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=647", "section_title": "FIFO Registers", "content": "The maximum number of entries, or depth, of the FIFO."}
{"type": "text", "page_from": 648, "page_to": 648, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=648", "section_title": "FIFO Registers", "content": "uvm_reg_predictor class. If the write is via an update() operation, the abstract FIFO already contains the written value and is thus not affected by either prediction mode."}
{"type": "text", "page_from": 648, "page_to": 648, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=648", "section_title": "FIFO Registers", "content": "Reads the next value out of the DUT FIFO. If auto-prediction is enabled, the frontmost value in abstract FIFO is popped."}
{"type": "text", "page_from": 648, "page_to": 648, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=648", "section_title": "FIFO Registers", "content": "virtual function void set( uvm_reg_data_t value, string fname int lineno ="}
{"type": "text", "page_from": 648, "page_to": 648, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=648", "section_title": "FIFO Registers", "content": "Pushes the given value to the abstract FIFO. You may call this method several times before an update() as a means of preloading the DUT FIFO. Calls to set() to a full FIFO are ignored. You must call update() to update the DUT FIFO with your set values."}
{"type": "text", "page_from": 648, "page_to": 648, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=648", "section_title": "FIFO Registers", "content": "Pushes (writes) all values preloaded using set() to the DUT. You must update after set before any blocking statements, else other reads/writes to the DUT FIFO may cause the mirror to become out of sync with the DUT."}
{"type": "text", "page_from": 648, "page_to": 648, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=648", "section_title": "FIFO Registers", "content": "Reads the next value out of the DUT FIFO. If auto-prediction is enabled, the frontmost value in abstract FIFO is popped. If the check argument is set and comparison is enabled with set_compare()."}
{"type": "text", "page_from": 649, "page_to": 649, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=649", "section_title": "FIFO Registers", "content": "virtual function void do_predict( uvm_reg_item rw, uvm_predict_e kind $=$ UVM_PREDICT_DIRECT, uvm_reg_byte_en_t be = -1 )"}
{"type": "text", "page_from": 649, "page_to": 649, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=649", "section_title": "FIFO Registers", "content": "Updates the abstract (mirror) FIFO based on write() and read() operations. When autoprediction is on, this method is called before each read, write, peek, or poke operation returns. When auto-prediction is off, this method is called by a uvm_reg_predictor upon receipt and conversion of an observed bus operation to this register."}
{"type": "text", "page_from": 649, "page_to": 649, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=649", "section_title": "FIFO Registers", "content": "If a write prediction, the observed write value is pushed to the abstract FIFO as long as it is not full and the operation did not originate from an update(). If a read prediction, the observed read value is compared with the frontmost value in the abstract FIFO if set_compare() enabled comparison and the FIFO is not empty."}
{"type": "text", "page_from": 649, "page_to": 649, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=649", "section_title": "FIFO Registers", "content": "virtual task pre_write( uvm_reg_item rw"}
{"type": "text", "page_from": 649, "page_to": 649, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=649", "section_title": "FIFO Registers", "content": "Special pre-processing for a write() or update(). Called as a result of a write() or update(). It is an error to attempt a write to a full FIFO or a write while an update is still pending. An update is pending after one or more calls to set(). If in your application the DUT allows writes to a full FIFO, you must override pre_write as appropriate."}
{"type": "text", "page_from": 649, "page_to": 649, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=649", "section_title": "FIFO Registers", "content": "virtual task pre_read( uvm_reg_item rw"}
{"type": "text", "page_from": 649, "page_to": 649, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=649", "section_title": "FIFO Registers", "content": "Special post-processing for a write() or update(). Aborts the operation if the internal FIFO is empty. If in your application the DUT does not behave this way, you must override pre_write as appropriate."}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "header_path": ["25", "9"], "chapter": "25", "section": "25.9", "content": "25.9 Virtual Registers"}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "A virtual register is a collection of fields, overlaid on top of a memory, usually in an array. The semantics and layout of virtual registers comes from an agreement between the software and the hardware, not any physical structures in the DUT."}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "A virtual register is a collection of fields, overlaid on top of a memory, usually in an array."}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "uvm_vreg Virtual register abstraction base class uvm_vreg_cbs Pre/post read/write callback facade class"}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "Virtual register abstraction base class"}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "A virtual register represents a set of fields that are logically implemented in consecutive memory locations."}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "All virtual register accesses eventually turn into memory accesses."}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "A virtual register array may be implemented on top of any memory abstraction class and possibly dynamically resized and/or relocated."}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "Virtual register abstraction base class"}
{"type": "text", "page_from": 650, "page_to": 650, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=650", "section_title": "Virtual Registers", "content": "class uvm_vreg extends uvm_object"}
{"type": "text", "page_from": 651, "page_to": 651, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=651", "section_title": "Virtual Registers", "content": "Create a new instance and type-specific configuration"}
{"type": "text", "page_from": 651, "page_to": 651, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=651", "section_title": "Virtual Registers", "content": "Creates an instance of a virtual register abstraction class with the specified name."}
{"type": "text", "page_from": 651, "page_to": 651, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=651", "section_title": "Virtual Registers", "content": "n_bits specifies the total number of bits in a virtual register. Not all bits need to be mapped to a virtual field. This value is usually a multiple of 8."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "Instance-specific configuration"}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "Specify the parent block of this virtual register array. If one of the other parameters are specified, the virtual register is assumed to be dynamic and can be later (re)implemented using the uvm_vreg::implement() method."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "If mem is specified, then the virtual register array is assumed to be statically implemented in the memory corresponding to the specified memory abstraction class and size, offset and incr must also be specified. Static virtual register arrays cannot be reimplemented."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "Dynamically implement, resize or relocate a virtual register array"}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "Implement an array of virtual registers of the specified size, in the specified memory and offset. If an offset increment is specified, each virtual register is implemented at the specified offset increment from the previous one. If an offset increment of 0 is specified, virtual registers are packed as closely as possible in the memory."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "If no memory is specified, the virtual register array is in the same memory, at the same base offset using the same offset increment as originally implemented. Only the number of virtual registers in the virtual register array is modified."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "The initial value of the newly-implemented or relocated set of virtual registers is whatever values are currently stored in the memory now implementing them."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "Returns TRUE if the memory can implement the number of virtual registers at the specified base offset and offset increment. Returns FALSE otherwise."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "The memory region used to implement a virtual register array is reserved in the memory allocation manager associated with the memory to prevent it from being allocated for another purpose."}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "Randomly implement, resize or relocate a virtual register array"}
{"type": "text", "page_from": 652, "page_to": 652, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=652", "section_title": "Virtual Registers", "content": "Implement a virtual register array of the specified size in a randomly allocated region of the appropriate size in the address space managed by the specified memory allocation manager. If a memory allocation policy is specified, it is passed to the uvm_mem_mam::request_region() method."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "The initial value of the newly-implemented or relocated set of virtual registers is whatever values are currently stored in the memory region now implementing them."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Returns a reference to a uvm_mem_region memory region descriptor if the memory allocation manager was able to allocate a region that can implement the virtual register array with the specified allocation policy. Returns null otherwise."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "A region implementing a virtual register array must not be released using the uvm_mem_mam::release_region() method. It must be released using the uvm_vreg::release_region() method."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "virtual function uvm_mem_region get_region()"}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Get the region where the virtual register array is implemented"}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Returns a reference to the uvm_mem_region memory region descriptor that implements the virtual register array."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Returns null if the virtual registers array is not currently implemented. A region implementing a virtual register array must not be released using the uvm_mem_mam::release_region() method. It must be released using the uvm_vreg::release_region() method."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "virtual function void release_region()"}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Dynamically un-implement a virtual register array"}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Release the memory region used to implement a virtual register array and return it to the pool of available memory that can be allocated by the memory’s default allocation manager. The virtual register array is subsequently considered as unimplemented and can no longer be accessed."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Statically-implemented virtual registers cannot be released."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Get the simple name Return the simple object name of this register."}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 653, "page_to": 653, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=653", "section_title": "Virtual Registers", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Return the hierarchal name of this register. The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "virtual function uvm_reg_block get_parent()"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Get the parent block"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "virtual function uvm_mem get_memory()"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Get the memory where the virtual register array is implemented"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "virtual function int get_n_maps ()"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Returns the number of address maps this virtual register array is mapped in"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "function bit is_in_map ( uvm_reg_map map"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Return TRUE if this virtual register array is in the specified address map"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "virtual function void get_maps ( ref uvm_reg_map maps[\\$]"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Returns all of the address maps where this virtual register array is mapped"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "virtual function string get_rights( uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Returns the access rights of this virtual register array"}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "Returns “RW”, $\\ \" \\mathsf { R O } ^ { \\prime \\prime }$ or $\\ \" \\mathsf { W O ^ { \\prime \\prime } }$ . The access rights of a virtual register array is always $\\ \" { \\sf R W } ^ { \\prime \\prime } ,$ , unless it is implemented in a shared memory with access restriction in a particular address map."}
{"type": "text", "page_from": 654, "page_to": 654, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=654", "section_title": "Virtual Registers", "content": "If no address map is specified and the memory is mapped in only one address map, that address map is used. If the memory is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "If an address map is specified and the memory is not mapped in the specified address map, an error message is issued and $\\ \" \\mathsf { R W } ^ { \\prime \\prime }$ is returned."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "virtual function string get_access( uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "Returns the access policy of the virtual register array when written and read via an address map."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "If the memory implementing the virtual register array is mapped in more than one address map, an address map must be specified. If access restrictions are present when accessing a memory through the specified address map, the access mode returned takes the access restrictions into account. For example, a read-write memory accessed through an address map with read-only restrictions would return $\\ \" \\mathsf { R O } ^ { \\prime \\prime }$ ."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "virtual function int unsigned get_size()"}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "Returns the size of the virtual register array."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "virtual function int unsigned get_n_bytes()"}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "Returns the width, in bytes, of a virtual register."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "The width of a virtual register is always a multiple of the width of the memory locations used to implement it. For example, a virtual register containing two 1-byte fields implemented in a memory with 4-bytes memory locations is 4-byte wide."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "virtual function int unsigned get_n_memlocs()"}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "Returns the number of memory locations used by a single virtual register."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "virtual function int unsigned get_incr()"}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "Returns the number of memory locations between two individual virtual registers in the same array."}
{"type": "text", "page_from": 655, "page_to": 655, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=655", "section_title": "Virtual Registers", "content": "virtual function void get_fields( ref uvm_vreg_field fields[\\$]"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Return the virtual fields in this virtual register"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Fills the specified array with the abstraction class for all of the virtual fields contained in this virtual register. Fields are ordered from least-significant position to most-significant position within the register."}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "virtual function uvm_vreg_field get_field_by_name( string name"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Return the named virtual field in this virtual register"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Finds a virtual field with the specified name in this virtual register and returns its abstraction class. If no fields are found, returns null."}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "get_offset_in_memory"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "virtual function uvm_reg_addr_t get_offset_in_memory( longint unsigned idx"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Returns the offset of a virtual register"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Returns the base offset of the specified virtual register, in the overall address space of the memory that implements the virtual register array."}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "virtual function uvm_reg_addr_t get_address( longint unsigned idx, uvm_reg_map map $=$ null )"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Returns the base external physical address of a virtual register"}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "Returns the base external physical address of the specified virtual register if accessed through the specified address map."}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "If no address map is specified and the memory implementing the virtual register array is mapped in only one address map, that address map is used. If the memory is mapped in more than one address map, the default address map of the parent block is used."}
{"type": "text", "page_from": 656, "page_to": 656, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=656", "section_title": "Virtual Registers", "content": "If an address map is specified and the memory is not mapped in the specified address map, an error message is issued."}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "Write the specified value in a virtual register"}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "Write value in the DUT memory location(s) that implements the virtual register array that corresponds to this abstraction class instance using the specified access path."}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "If the memory implementing the virtual register array is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access)."}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "The operation is eventually mapped into set of memory-write operations at the location where the virtual register specified by idx in the virtual register array is implemented."}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "Read the current value from a virtual register"}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "Read from the DUT memory location(s) that implements the virtual register array that corresponds to this abstraction class instance using the specified access path and return the readback value."}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "If the memory implementing the virtual register array is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access)."}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "The operation is eventually mapped into set of memory-read operations at the location where the virtual register specified by idx in the virtual register array is implemented."}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "Deposit the specified value in a virtual register"}
{"type": "text", "page_from": 657, "page_to": 657, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=657", "section_title": "Virtual Registers", "content": "Deposit value in the DUT memory location(s) that implements the virtual register array"}
{"type": "text", "page_from": 658, "page_to": 658, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=658", "section_title": "Virtual Registers", "content": "that corresponds to this abstraction class instance using the memory backdoor access."}
{"type": "text", "page_from": 658, "page_to": 658, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=658", "section_title": "Virtual Registers", "content": "The operation is eventually mapped into set of memory-poke operations at the location where the virtual register specified by idx in the virtual register array is implemented."}
{"type": "text", "page_from": 658, "page_to": 658, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=658", "section_title": "Virtual Registers", "content": "Sample the current value in a virtual register"}
{"type": "text", "page_from": 658, "page_to": 658, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=658", "section_title": "Virtual Registers", "content": "Sample the DUT memory location(s) that implements the virtual register array that corresponds to this abstraction class instance using the memory backdoor access, and return the sampled value."}
{"type": "text", "page_from": 658, "page_to": 658, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=658", "section_title": "Virtual Registers", "content": "The operation is eventually mapped into set of memory-peek operations at the location where the virtual register specified by idx in the virtual register array is implemented."}
{"type": "text", "page_from": 658, "page_to": 658, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=658", "section_title": "Virtual Registers", "content": "Reset the access semaphore"}
{"type": "text", "page_from": 658, "page_to": 658, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=658", "section_title": "Virtual Registers", "content": "Reset the semaphore that prevents concurrent access to the virtual register. This semaphore must be explicitly reset if a thread accessing this virtual register array was killed in before the access was completed"}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "Called after virtual register write."}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "If the specified status is modified, the updated status will be returned by the virtual register operation."}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "The registered callback methods are invoked before the invocation of this method. All register callbacks are executed before the corresponding field callbacks The post-write virtual register and field callbacks are executed after the corresponding post-write memory callbacks"}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "Called before virtual register read."}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "If the specified access path or address map are modified, the updated access path or address map will be used to perform the register operation."}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "The registered callback methods are invoked after the invocation of this method. All register callbacks are executed after the corresponding field callbacks The pre-read virtual register and field callbacks are executed before the corresponding pre-read memory callbacks"}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "Called after virtual register read."}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "If the specified readback data or status is modified, the updated readback data or status will be returned by the register operation."}
{"type": "text", "page_from": 659, "page_to": 659, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=659", "section_title": "Virtual Registers", "content": "The registered callback methods are invoked before the invocation of this method. All register callbacks are executed before the corresponding field callbacks The post-read virtual register and field callbacks are executed after the corresponding post-read memory callbacks"}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "Pre/post read/write callback facade class"}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "Pre/post read/write callback facade class"}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "class uvm_vreg_cbs extends uvm_callback"}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "pre_write Callback called before a write operation. post_write Called after register write. pre_read Called before register read. post_read Called after register read."}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "uvm_vreg_cb Convenience callback type declaration uvm_vreg_cb_iter Convenience callback iterator type declaration"}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "Callback called before a write operation."}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "The registered callback methods are invoked after the invocation of the uvm_vreg::pre_write() method. All virtual register callbacks are executed after the corresponding virtual field callbacks The pre-write virtual register and field callbacks are executed before the corresponding pre-write memory callbacks"}
{"type": "text", "page_from": 660, "page_to": 660, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=660", "section_title": "Virtual Registers", "content": "The written value wdat, access path and address $m a p$ , if modified, modifies the actual value, access path or address map used in the virtual register operation."}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "Called after register write."}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "The registered callback methods are invoked before the invocation of the uvm_reg::post_write() method. All register callbacks are executed before the corresponding virtual field callbacks The post-write virtual register and field callbacks are executed after the corresponding post-write memory callbacks"}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "The status of the operation, if modified, modifies the actual returned status."}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "Called before register read."}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "The registered callback methods are invoked after the invocation of the uvm_reg::pre_read() method. All register callbacks are executed after the corresponding virtual field callbacks The pre-read virtual register and field callbacks are executed before the corresponding pre-read memory callbacks"}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "The access path and address map, if modified, modifies the actual access path or address map used in the register operation."}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "Called after register read."}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "The registered callback methods are invoked before the invocation of the uvm_reg::post_read() method. All register callbacks are executed before the corresponding virtual field callbacks The post-read virtual register and field callbacks are executed after the corresponding post-read memory callbacks"}
{"type": "text", "page_from": 661, "page_to": 661, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=661", "section_title": "Virtual Registers", "content": "The readback value rdat and the status of the operation, if modified, modifies the actual returned readback value and status."}
{"type": "text", "page_from": 662, "page_to": 662, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=662", "section_title": "Virtual Registers", "content": "Convenience callback type declaration"}
{"type": "text", "page_from": 662, "page_to": 662, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=662", "section_title": "Virtual Registers", "content": "Use this declaration to register virtual register callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 662, "page_to": 662, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=662", "section_title": "Virtual Registers", "content": "Convenience callback iterator type declaration"}
{"type": "text", "page_from": 662, "page_to": 662, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=662", "section_title": "Virtual Registers", "content": "Use this declaration to iterate over registered virtual register callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Register Field Classes", "header_path": ["25", "10"], "chapter": "25", "section": "25.10", "content": "25.10 Virtual Register Field Classes"}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Fields", "content": "This section defines the virtual field and callback classes."}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Fields", "content": "A virtual field is set of contiguous bits in one or more memory locations. The semantics and layout of virtual fields comes from an agreement between the software and the hardware, not any physical structures in the DUT."}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Fields", "content": "Virtual field abstraction class"}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Fields", "content": "A virtual field represents a set of adjacent bits that are logically implemented in consecutive memory locations."}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Fields", "content": "Virtual field abstraction class"}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Fields", "content": "class uvm_vreg_field extends uvm_object"}
{"type": "text", "page_from": 663, "page_to": 663, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=663", "section_title": "Virtual Fields", "content": "new Create a new virtual field instance configure Instance-specific configuration"}
{"type": "text", "page_from": 664, "page_to": 664, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=664", "section_title": "Virtual Fields", "content": "Create a new virtual field instance"}
{"type": "text", "page_from": 664, "page_to": 664, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=664", "section_title": "Virtual Fields", "content": "This method should not be used directly. The uvm_vreg_field::type_id::create() method should be used instead."}
{"type": "text", "page_from": 664, "page_to": 664, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=664", "section_title": "Virtual Fields", "content": "Instance-specific configuration"}
{"type": "text", "page_from": 664, "page_to": 664, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=664", "section_title": "Virtual Fields", "content": "Specify the parent virtual register of this virtual field, its size in bits, and the position of its least-significant bit within the virtual register relative to the least-significant bit of the virtual register."}
{"type": "text", "page_from": 664, "page_to": 664, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=664", "section_title": "Virtual Fields", "content": "Return the simple object name of this virtual field"}
{"type": "text", "page_from": 664, "page_to": 664, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=664", "section_title": "Virtual Fields", "content": "virtual function string get_full_name()"}
{"type": "text", "page_from": 664, "page_to": 664, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=664", "section_title": "Virtual Fields", "content": "Get the hierarchical name"}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "Return the hierarchal name of this virtual field The base of the hierarchical name is the root block."}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "virtual function uvm_vreg get_parent()"}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "Get the parent virtual register"}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "get_lsb_pos_in_register"}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "virtual function int unsigned get_lsb_pos_in_register()"}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "Return the position of the virtual field / Returns the index of the least significant bit of the virtual field in the virtual register that instantiates it. An offset of 0 indicates a field that is aligned with the least-significant bit of the register."}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "virtual function int unsigned get_n_bits()"}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "Returns the width, in bits, of the virtual field."}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "virtual function string get_access( uvm_reg_map map $=$ null"}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "Returns the access policy of the virtual field register when written and read via an address map."}
{"type": "text", "page_from": 665, "page_to": 665, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=665", "section_title": "Virtual Fields", "content": "If the memory implementing the virtual field is mapped in more than one address map, an address map must be specified. If access restrictions are present when accessing a memory through the specified address map, the access mode returned takes the access restrictions into account. For example, a read-write memory accessed through an address map with read-only restrictions would return $\\ \" \\mathsf { R O } ^ { \\prime \\prime }$ ."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "Write the specified value in a virtual field"}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "Write value in the DUT memory location(s) that implements the virtual field that corresponds to this abstraction class instance using the specified access path."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "If the memory implementing the virtual register array containing this virtual field is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access)."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "The operation is eventually mapped into memory read-modify-write operations at the location where the virtual register specified by idx in the virtual register array is implemented. If a backdoor is available for the memory implementing the virtual field, it will be used for the memory-read operation."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "Read the current value from a virtual field"}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "Read from the DUT memory location(s) that implements the virtual field that corresponds to this abstraction class instance using the specified access path, and return the readback value."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "If the memory implementing the virtual register array containing this virtual field is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access)."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "The operation is eventually mapped into memory read operations at the location(s) where the virtual register specified by idx in the virtual register array is implemented."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "Deposit the specified value in a virtual field"}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "Deposit value in the DUT memory location(s) that implements the virtual field that corresponds to this abstraction class instance using the specified access path."}
{"type": "text", "page_from": 666, "page_to": 666, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=666", "section_title": "Virtual Fields", "content": "The operation is eventually mapped into memory peek-modify-poke operations at the location where the virtual register specified by idx in the virtual register array is implemented."}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "Sample the current value from a virtual field"}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "Sample from the DUT memory location(s) that implements the virtual field that corresponds to this abstraction class instance using the specified access $p a t h$ , and return the readback value."}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "If the memory implementing the virtual register array containing this virtual field is mapped in more than one address map, an address map must be specified if a physical access is used (front-door access)."}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "The operation is eventually mapped into memory peek operations at the location(s) where the virtual register specified by idx in the virtual register array is implemented."}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "Called before virtual field write."}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "If the specified data value, access path or address map are modified, the updated data value, access path or address map will be used to perform the virtual register operation."}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "The virtual field callback methods are invoked before the callback methods on the containing virtual register. The registered callback methods are invoked after the invocation of this method. The pre-write virtual register and field callbacks are executed before the corresponding pre-write memory callbacks"}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "Called after virtual field write"}
{"type": "text", "page_from": 667, "page_to": 667, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=667", "section_title": "Virtual Fields", "content": "If the specified status is modified, the updated status will be returned by the virtual"}
{"type": "text", "page_from": 668, "page_to": 668, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=668", "section_title": "Virtual Fields", "content": "The virtual field callback methods are invoked after the callback methods on the containing virtual register. The registered callback methods are invoked before the invocation of this method. The post-write virtual register and field callbacks are executed after the corresponding post-write memory callbacks"}
{"type": "text", "page_from": 668, "page_to": 668, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=668", "section_title": "Virtual Fields", "content": "Called before virtual field read."}
{"type": "text", "page_from": 668, "page_to": 668, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=668", "section_title": "Virtual Fields", "content": "If the specified access path or address map are modified, the updated access path or address map will be used to perform the virtual register operation."}
{"type": "text", "page_from": 668, "page_to": 668, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=668", "section_title": "Virtual Fields", "content": "The virtual field callback methods are invoked after the callback methods on the containing virtual register. The registered callback methods are invoked after the invocation of this method. The pre-read virtual register and field callbacks are executed before the corresponding pre-read memory callbacks"}
{"type": "text", "page_from": 668, "page_to": 668, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=668", "section_title": "Virtual Fields", "content": "Called after virtual field read."}
{"type": "text", "page_from": 668, "page_to": 668, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=668", "section_title": "Virtual Fields", "content": "If the specified readback data rdat or status is modified, the updated readback data or status will be returned by the virtual register operation."}
{"type": "text", "page_from": 668, "page_to": 668, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=668", "section_title": "Virtual Fields", "content": "The virtual field callback methods are invoked after the callback methods on the containing virtual register. The registered callback methods are invoked before the invocation of this method. The post-read virtual register and field callbacks are executed after the corresponding post-read memory callbacks"}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "class uvm_vreg_field_cbs extends uvm_callback"}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "pre_write Callback called before a write operation. post_write Called after a write operation pre_read Called before a virtual field read. post_read Called after a virtual field read."}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "uvm_vreg_field_cb Convenience callback type declaration uvm_vreg_field_cb_iter Convenience callback iterator type declaration"}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "Callback called before a write operation."}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "The registered callback methods are invoked before the invocation of the virtual register pre-write callbacks and after the invocation of the uvm_vreg_field::pre_write() method."}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "The written value wdat, access path and address $m a p _ { \\ l }$ , if modified, modifies the actual value, access path or address map used in the register operation."}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "Called after a write operation"}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "The registered callback methods are invoked after the invocation of the virtual register post-write callbacks and before the invocation of the uvm_vreg_field::post_write() method."}
{"type": "text", "page_from": 669, "page_to": 669, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=669", "section_title": "Virtual Fields", "content": "The status of the operation, if modified, modifies the actual returned status."}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "Called before a virtual field read."}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "The registered callback methods are invoked after the invocation of the virtual register pre-read callbacks and after the invocation of the uvm_vreg_field::pre_read() method."}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "The access path and address $m a p$ , if modified, modifies the actual access path or address map used in the register operation."}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "Called after a virtual field read."}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "The registered callback methods are invoked after the invocation of the virtual register post-read callbacks and before the invocation of the uvm_vreg_field::post_read() method."}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "The readback value rdat and the status of the operation, if modified, modifies the actual returned readback value and status."}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "Convenience callback type declaration"}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "Use this declaration to register virtual field callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "uvm_vreg_field_cb_iter"}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "Convenience callback iterator type declaration"}
{"type": "text", "page_from": 670, "page_to": 670, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=670", "section_title": "Virtual Fields", "content": "Use this declaration to iterate over registered virtual field callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 671, "page_to": 671, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=671", "section_title": "Callbacks", "content": "This section defines the base class used for all register callback extensions. It also includes pre-defined callback extensions for use on read-only and write-only registers."}
{"type": "text", "page_from": 671, "page_to": 671, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=671", "section_title": "Callbacks", "content": "Facade class for field, register, memory and backdoor access callback methods."}
{"type": "text", "page_from": 671, "page_to": 671, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=671", "section_title": "Callbacks", "content": "Facade class for field, register, memory and backdoor access callback methods."}
{"type": "text", "page_from": 671, "page_to": 671, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=671", "section_title": "Callbacks", "content": "virtual class uvm_reg_cbs extends uvm_callback"}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "Called before a write operation."}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "All registered pre_write callback methods are invoked after the invocation of the pre_write method of associated object (uvm_reg, uvm_reg_field, uvm_mem, or uvm_reg_backdoor). If the element being written is a uvm_reg, all pre_write callback methods are invoked before the contained uvm_reg_fields."}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "Backdoor uvm_reg_backdoor::pre_write, uvm_reg_cbs::pre_write cbs for backdoor. Register uvm_reg::pre_write, uvm_reg_cbs::pre_write cbs for reg, then foreach field: uvm_reg_field::pre_write, uvm_reg_cbs::pre_write cbs for field RegField uvm_reg_field::pre_write, uvm_reg_cbs::pre_write cbs for field Memory uvm_mem::pre_write, uvm_reg_cbs::pre_write cbs for mem"}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "The rw argument holds information about the operation."}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "Modifying the value modifies the actual value written. For memories, modifying the offset modifies the offset used in the operation. For non-backdoor operations, modifying the access path or address map modifies the actual path or map used in the operation."}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "If the rw.status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "See uvm_reg_item for details on rw information."}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "Called after a write operation."}
{"type": "text", "page_from": 672, "page_to": 672, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=672", "section_title": "Callbacks", "content": "All registered post_write callback methods are invoked before the invocation of the post_write method of the associated object (uvm_reg, uvm_reg_field, uvm_mem, or"}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "uvm_reg_backdoor). If the element being written is a uvm_reg, all post_write callback methods are invoked before the contained uvm_reg_fields."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "Summary of callback order"}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "Backdoor uvm_reg_cbs::post_write cbs for backdoor, uvm_reg_backdoor::post_write Register uvm_reg_cbs::post_write cbs for reg, uvm_reg::post_write, then foreach field: uvm_reg_cbs::post_write cbs for field, uvm_reg_field::post_read RegField uvm_reg_cbs::post_write cbs for field, uvm_reg_field::post_write Memory uvm_reg_cbs::post_write cbs for mem, uvm_mem::post_write"}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "The rw argument holds information about the operation."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "Modifying the status member modifies the returned status. Modifying the value or offset members has no effect, as the operation has already completed."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "See uvm_reg_item for details on rw information."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "virtual task pre_read( uvm_reg_item rw )"}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "Callback called before a read operation."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "All registered pre_read callback methods are invoked after the invocation of the pre_read method of associated object (uvm_reg, uvm_reg_field, uvm_mem, or uvm_reg_backdoor). If the element being read is a uvm_reg, all pre_read callback methods are invoked before the contained uvm_reg_fields."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "Backdoor uvm_reg_backdoor::pre_read, uvm_reg_cbs::pre_read cbs for backdoor Register uvm_reg::pre_read, uvm_reg_cbs::pre_read cbs for reg, then foreach field: uvm_reg_field::pre_read, uvm_reg_cbs::pre_read cbs for field RegField uvm_reg_field::pre_read, uvm_reg_cbs::pre_read cbs for field Memory uvm_mem::pre_read, uvm_reg_cbs::pre_read cbs for mem"}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "The rw argument holds information about the operation."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "The value member of rw is not used has no effect if modified. For memories, modifying the offset modifies the offset used in the operation. For non-backdoor operations, modifying the access path or address map modifies the actual path or map used in the operation."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "If the rw.status is modified to anything other than UVM_IS_OK, the operation is aborted."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "See uvm_reg_item for details on rw information."}
{"type": "text", "page_from": 673, "page_to": 673, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=673", "section_title": "Callbacks", "content": "virtual task post_read("}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "Callback called after a read operation."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "All registered post_read callback methods are invoked before the invocation of the post_read method of the associated object (uvm_reg, uvm_reg_field, uvm_mem, or uvm_reg_backdoor). If the element being read is a uvm_reg, all post_read callback methods are invoked before the contained uvm_reg_fields."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "Backdoor uvm_reg_cbs::post_read cbs for backdoor, uvm_reg_backdoor::post_read Register uvm_reg_cbs::post_read cbs for reg, uvm_reg::post_read, then foreach field: uvm_reg_cbs::post_read cbs for field, uvm_reg_field::post_read RegField uvm_reg_cbs::post_read cbs for field, uvm_reg_field::post_read Memory uvm_reg_cbs::post_read cbs for mem, uvm_mem::post_read"}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "The rw argument holds information about the operation."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "Modifying the readback value or status modifies the actual returned value and status. Modifying the value or offset members has no effect, as the operation has already completed."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "See uvm_reg_item for details on rw information."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "Called by the uvm_reg_field::predict() method after a successful UVM_PREDICT_READ or UVM_PREDICT_WRITE prediction."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "previous is the previous value in the mirror and value is the latest predicted value. Any change to value will modify the predicted mirror value."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "The registered callback methods are invoked in order of registration after all the pre_write methods have been called. The encoded data is passed through each invocation in sequence. This allows the pre_write methods to deal with clear-text data."}
{"type": "text", "page_from": 674, "page_to": 674, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=674", "section_title": "Callbacks", "content": "By default, the data is not modified."}
{"type": "text", "page_from": 675, "page_to": 675, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=675", "section_title": "Callbacks", "content": "The registered callback methods are invoked in reverse order of registration before all the post_read methods are called. The decoded data is passed through each invocation in sequence. This allows the post_read methods to deal with clear-text data."}
{"type": "text", "page_from": 675, "page_to": 675, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=675", "section_title": "Callbacks", "content": "The reversal of the invocation order is to allow the decoding of the data to be performed in the opposite order of the encoding with both operations specified in the same callback extension."}
{"type": "text", "page_from": 675, "page_to": 675, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=675", "section_title": "Callbacks", "content": "By default, the data is not modified."}
{"type": "text", "page_from": 675, "page_to": 675, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=675", "section_title": "Callbacks", "content": "Convenience callback type declaration for registers"}
{"type": "text", "page_from": 675, "page_to": 675, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=675", "section_title": "Callbacks", "content": "Use this declaration to register the register callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 675, "page_to": 675, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=675", "section_title": "Callbacks", "content": "Convenience callback iterator type declaration for registers"}
{"type": "text", "page_from": 675, "page_to": 675, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=675", "section_title": "Callbacks", "content": "Use this declaration to iterate over registered register callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Convenience callback type declaration for backdoor"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Use this declaration to register register backdoor callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Convenience callback iterator type declaration for backdoor"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Use this declaration to iterate over registered register backdoor callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Convenience callback type declaration for memories"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Use this declaration to register memory callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Convenience callback iterator type declaration for memories"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Use this declaration to iterate over registered memory callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Convenience callback type declaration for fields"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Use this declaration to register field callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "uvm_reg_field_cb_iter"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Convenience callback iterator type declaration for fields"}
{"type": "text", "page_from": 676, "page_to": 676, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=676", "section_title": "Callbacks", "content": "Use this declaration to iterate over registered field callbacks rather than the more verbose parameterized class"}
{"type": "text", "page_from": 677, "page_to": 677, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=677", "section_title": "Callbacks", "content": "uvm_reg_read_only_cbs"}
{"type": "text", "page_from": 677, "page_to": 677, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=677", "section_title": "Callbacks", "content": "Pre-defined register callback method for read-only registers that will issue an error if a write() operation is attempted."}
{"type": "text", "page_from": 677, "page_to": 677, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=677", "section_title": "Callbacks", "content": "virtual task pre_write( uvm_reg_item rw"}
{"type": "text", "page_from": 677, "page_to": 677, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=677", "section_title": "Callbacks", "content": "Produces an error message and sets status to UVM_NOT_OK."}
{"type": "text", "page_from": 677, "page_to": 677, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=677", "section_title": "Callbacks", "content": "Add this callback to the specified register and its contained fields."}
{"type": "text", "page_from": 677, "page_to": 677, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=677", "section_title": "Callbacks", "content": "Remove this callback from the specified register and its contained fields."}
{"type": "text", "page_from": 678, "page_to": 678, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=678", "section_title": "Callbacks", "content": "Pre-defined register callback method for write-only registers that will issue an error if a read() operation is attempted."}
{"type": "text", "page_from": 678, "page_to": 678, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=678", "section_title": "Callbacks", "content": "uvm_reg_write_only_cbs"}
{"type": "text", "page_from": 678, "page_to": 678, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=678", "section_title": "Callbacks", "content": "Pre-defined register callback method for write-only registers that will issue an error if a read() operation is attempted."}
{"type": "text", "page_from": 678, "page_to": 678, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=678", "section_title": "Callbacks", "content": "class uvm_reg_write_only_cbs extends uvm_reg_cbs"}
{"type": "text", "page_from": 678, "page_to": 678, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=678", "section_title": "Callbacks", "content": "Produces an error message and sets status to UVM_NOT_OK."}
{"type": "text", "page_from": 679, "page_to": 679, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=679", "section_title": "Callbacks", "content": "Remove this callback from the specified register and its contained fields."}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "header_path": ["25", "12"], "chapter": "25", "section": "25.12", "content": "25.12 Memory Allocation Manager"}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "Manages the exclusive allocation of consecutive memory locations called regions. The regions can subsequently be accessed like little memories of their own, without knowing in which memory or offset they are actually located."}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "The memory allocation manager should be used by any application-level process that requires reserved space in the memory, such as DMA buffers."}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "A region will remain reserved until it is explicitly released."}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "Memory allocation manager"}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "Memory allocation management utility class similar to C’s malloc() and free(). A single instance of this class is used to manage a single, contiguous address space."}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "Memory allocation manager"}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "alloc_mode_e Memory allocation mode locality_e Location of memory regions default_alloc Region allocation policy new Create a new manager instance reconfigure Reconfigure the manager"}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "reserve_region Reserve a specific memory region request_region Request and reserve a memory region release_region Release the specified region release_all_regions Forcibly release all allocated memory regions."}
{"type": "text", "page_from": 680, "page_to": 680, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=680", "section_title": "Memory Allocation Manager", "content": "convert2string Image of the state of the manager for_each Iterate over all currently allocated regions get_memory Get the managed memory implementation"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "Memory allocation mode"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "Specifies how to allocate a memory region"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "GREEDY Consume new, previously unallocated memory THRIFTY Reused previously released memory as much as possible (not yet implemented)"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "Location of memory regions"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "Specifies where to locate new memory regions"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "BROAD Locate new regions randomly throughout the address space NEARBY Locate new regions adjacent to existing regions"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "uvm_mem_mam_policy default_alloc"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "Region allocation policy"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "This object is repeatedly randomized when allocating new regions."}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "Create a new manager instance"}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "Create an instance of a memory allocation manager with the specified name and configuration. This instance manages all memory region allocation within the address range specified in the configuration descriptor."}
{"type": "text", "page_from": 681, "page_to": 681, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=681", "section_title": "Memory Allocation Manager", "content": "If a reference to a memory abstraction class is provided, the memory locations within the regions can be accessed through the region descriptor, using the uvm_mem_region::read() and uvm_mem_region::write() methods."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Reconfigure the manager"}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Modify the maximum and minimum addresses of the address space managed by the allocation manager, allocation mode, or locality. The number of bytes per memory location cannot be modified once an allocation manager has been constructed. All currently allocated regions must fall within the new address space."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Returns the previous configuration."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "if no new configuration is specified, simply returns the current configuration."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Reserve a specific memory region"}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Reserve a memory region of the specified number of bytes starting at the specified offset. A descriptor of the reserved region is returned. If the specified region cannot be reserved, null is returned."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "It may not be possible to reserve a region because it overlaps with an already-allocated region or it lies outside the address range managed by the memory manager."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Regions can be reserved to create “holes” in the managed address space."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Request and reserve a memory region"}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "Request and reserve a memory region of the specified number of bytes starting at a random location. If an policy is specified, it is randomized to determine the start offset of the region. If no policy is specified, the policy found in the uvm_mem_mam::default_alloc class property is randomized."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "A descriptor of the allocated region is returned. If no region can be allocated, null is returned."}
{"type": "text", "page_from": 682, "page_to": 682, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=682", "section_title": "Memory Allocation Manager", "content": "It may not be possible to allocate a region because there is no area in the memory with enough consecutive locations to meet the size requirements or because there is another contradiction when randomizing the policy."}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "If the memory allocation is configured to THRIFTY or NEARBY, a suitable region is first sought procedurally."}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "function void release_region( uvm_mem_region region"}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "Release the specified region"}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "Release a previously allocated memory region. An error is issued if the specified region has not been previously allocated or is no longer allocated."}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "function void release_all_regions()"}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "Forcibly release all allocated memory regions."}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "function string convert2string()"}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "Image of the state of the manager"}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "Create a human-readable description of the state of the memory manager and the currently allocated regions."}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "function uvm_mem_region for_each( bit reset $=$"}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "Iterate over all currently allocated regions"}
{"type": "text", "page_from": 683, "page_to": 683, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=683", "section_title": "Memory Allocation Manager", "content": "If reset is TRUE, reset the iterator and return the first allocated region. Returns null when there are no additional allocated regions to iterate on."}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "Allocated memory region descriptor"}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "Each instance of this class describes an allocated memory region. Instances of this class are created only by the memory manager, and returned by the uvm_mem_mam::reserve_region() and uvm_mem_mam::request_region() methods."}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "Allocated memory region descriptor"}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "class uvm_mem_region"}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "function bit [63:0] get_start_offset()"}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "Get the start offset of the region"}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "Return the address offset, within the memory, where this memory region starts."}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "function bit [63:0] get_end_offset()"}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "Get the end offset of the region"}
{"type": "text", "page_from": 684, "page_to": 684, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=684", "section_title": "Memory Allocation Manager", "content": "Return the address offset, within the memory, where this memory region ends."}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "function int unsigned get_len()"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Size of the memory region"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Return the number of consecutive memory locations (not necessarily bytes) in the allocated region."}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "function int unsigned get_n_bytes()"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Number of bytes in the region"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Return the number of consecutive bytes in the allocated region. If the managed memory contains more than one byte per address, the number of bytes in an allocated region may be greater than the number of requested or reserved bytes."}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "function void release_region()"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "function uvm_mem get_memory()"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Get the memory where the region resides"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Return a reference to the memory abstraction class for the memory implementing this allocated memory region. Returns null if no memory abstraction class was specified for the allocation manager that allocated this region."}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "get_virtual_registers"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "function uvm_vreg get_virtual_registers()"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Get the virtual register array in this region"}
{"type": "text", "page_from": 685, "page_to": 685, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=685", "section_title": "Memory Allocation Manager", "content": "Return a reference to the virtual register array abstraction class implemented in this region. Returns null if the memory region is not known to implement virtual registers."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "Write to a memory location in the region."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "Write to the memory location that corresponds to the specified offset within this region. Requires that the memory abstraction class be associated with the memory allocation manager that allocated this region."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "See uvm_mem::write() for more details."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "Read from a memory location in the region."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "Read from the memory location that corresponds to the specified offset within this region. Requires that the memory abstraction class be associated with the memory allocation manager that allocated this region."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "See uvm_mem::read() for more details."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "Write to a set of memory location in the region."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "Write to the memory locations that corresponds to the specified burst within this region. Requires that the memory abstraction class be associated with the memory allocation manager that allocated this region."}
{"type": "text", "page_from": 686, "page_to": 686, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=686", "section_title": "Memory Allocation Manager", "content": "See uvm_mem::burst_write() for more details."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "Read from a set of memory location in the region."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "Read from the memory locations that corresponds to the specified burst within this region. Requires that the memory abstraction class be associated with the memory allocation manager that allocated this region."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "See uvm_mem::burst_read() for more details."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "Deposit in a memory location in the region."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "Deposit the specified value in the memory location that corresponds to the specified offset within this region. Requires that the memory abstraction class be associated with the memory allocation manager that allocated this region."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "See uvm_mem::poke() for more details."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "Sample a memory location in the region."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "Sample the memory location that corresponds to the specified offset within this region. Requires that the memory abstraction class be associated with the memory allocation manager that allocated this region."}
{"type": "text", "page_from": 687, "page_to": 687, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=687", "section_title": "Memory Allocation Manager", "content": "See uvm_mem::peek() for more details."}
{"type": "text", "page_from": 688, "page_to": 688, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=688", "section_title": "Memory Allocation Manager", "content": "An instance of this class is randomized to determine the starting offset of a randomly allocated memory region. This class can be extended to provide additional constraints on the starting offset, such as word alignment or location of the region within a memory page. If a procedural region allocation policy is required, it can be implemented in the pre/post_randomize() method."}
{"type": "text", "page_from": 688, "page_to": 688, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=688", "section_title": "Memory Allocation Manager", "content": "An instance of this class is randomized to determine the starting offset of a randomly allocated memory region."}
{"type": "text", "page_from": 688, "page_to": 688, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=688", "section_title": "Memory Allocation Manager", "content": "class uvm_mem_mam_policy"}
{"type": "text", "page_from": 688, "page_to": 688, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=688", "section_title": "Memory Allocation Manager", "content": "len Number of addresses required start_offset The starting offset of the region min_offset Minimum address offset in the managed address space max_offset Maximum address offset in the managed address space in_use Regions already allocated in the managed address space"}
{"type": "text", "page_from": 688, "page_to": 688, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=688", "section_title": "Memory Allocation Manager", "content": "Number of addresses required rand bit [63:0] start_offset"}
{"type": "text", "page_from": 688, "page_to": 688, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=688", "section_title": "Memory Allocation Manager", "content": "The starting offset of the region uvm_mem_region in_use[\\$]"}
{"type": "text", "page_from": 689, "page_to": 689, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=689", "section_title": "Memory Allocation Manager", "content": "Regions already allocated in the managed address space"}
{"type": "text", "page_from": 689, "page_to": 689, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=689", "section_title": "Memory Allocation Manager", "content": "Specifies the memory managed by an instance of a uvm_mem_mam memory allocation manager class."}
{"type": "text", "page_from": 689, "page_to": 689, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=689", "section_title": "Memory Allocation Manager", "content": "Specifies the memory managed by an instance of a uvm_mem_mam memoryallocation manager class."}
{"type": "text", "page_from": 689, "page_to": 689, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=689", "section_title": "Memory Allocation Manager", "content": "class uvm_mem_mam_cfg"}
{"type": "text", "page_from": 689, "page_to": 689, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=689", "section_title": "Memory Allocation Manager", "content": "n_bytes Number of bytes in each memory location end_offset Last address of managed space mode Region allocation mode locality Region location mode"}
{"type": "text", "page_from": 689, "page_to": 689, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=689", "section_title": "Memory Allocation Manager", "content": "rand int unsigned n_bytes"}
{"type": "text", "page_from": 689, "page_to": 689, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=689", "section_title": "Memory Allocation Manager", "content": "Number of bytes in each memory location"}
{"type": "text", "page_from": 690, "page_to": 690, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=690", "section_title": "Memory Allocation Manager", "content": "rand uvm_mem_mam::locality_e locality"}
{"type": "text", "page_from": 690, "page_to": 690, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=690", "section_title": "Memory Allocation Manager", "content": "Region location mode"}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "header_path": ["26", "1"], "chapter": "26", "section": "26.1", "content": "26.1 Generic Register Operation Descriptors"}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "content": "This section defines the abstract register transaction item. It also defines a descriptor for a physical bus operation that is used by uvm_reg_adapter subtypes to convert from a protocol-specific address/data/rw operation to a bus-independent, canonical r/w operation."}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "content": "Generic Register Operation Descriptors"}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "content": "This section defines the abstract register transaction item."}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "content": "uvm_reg_item Defines an abstract register transaction item. uvm_reg_bus_op Struct that defines a generic bus transaction for register and memory accesses, having kind (read or write), address, data, and byte enable information."}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "content": "Defines an abstract register transaction item. No bus-specific information is present, although a handle to a uvm_reg_map is provided in case a user wishes to implement a custom address translation algorithm."}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "content": "Defines an abstract register transaction item."}
{"type": "text", "page_from": 691, "page_to": 691, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=691", "section_title": "Generic Register Operation Descriptors", "content": "class uvm_reg_item extends uvm_sequence_item"}
{"type": "text", "page_from": 692, "page_to": 692, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=692", "section_title": "Generic Register Operation Descriptors", "content": "uvm_elem_kind_e element_kind"}
{"type": "text", "page_from": 692, "page_to": 692, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=692", "section_title": "Generic Register Operation Descriptors", "content": "Kind of element being accessed: REG, MEM, or FIELD. See uvm_elem_kind_e."}
{"type": "text", "page_from": 692, "page_to": 692, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=692", "section_title": "Generic Register Operation Descriptors", "content": "A handle to the RegModel model element associated with this transaction. Use element_kind to determine the type to cast to: uvm_reg, uvm_mem, or uvm_reg_field."}
{"type": "text", "page_from": 692, "page_to": 692, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=692", "section_title": "Generic Register Operation Descriptors", "content": "rand uvm_access_e kind"}
{"type": "text", "page_from": 692, "page_to": 692, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=692", "section_title": "Generic Register Operation Descriptors", "content": "Kind of access: READ or WRITE."}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "rand uvm_reg_addr_t offset"}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "For memory accesses, the offset address. For bursts, the starting offset address."}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "The result of the transaction: IS_OK, HAS_X, or ERROR. See uvm_status_e."}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "uvm_reg_map local_map"}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "The local map used to obtain addresses. Users may customize address-translation using this map. Access to the sequencer and bus adapter can be obtained by getting this map’s root map, then calling uvm_reg_map::get_sequencer and uvm_reg_map::get_adapter."}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "The original map specified for the operation. The actual map used may differ when a test or sequence written at the block level is reused at the system level."}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "The path being used: UVM_FRONTDOOR or UVM_BACKDOOR."}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "rand uvm_sequence_base parent"}
{"type": "text", "page_from": 693, "page_to": 693, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=693", "section_title": "Generic Register Operation Descriptors", "content": "The sequence from which the operation originated."}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "update() used to trigger the operation."}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "If path is UVM_BACKDOOR, this member specifies the abstraction kind for the backdoor access, e.g. “RTL” or “GATES”."}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "The file name from where this transaction originated, if provided at the call site."}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "The file name from where this transaction originated, if provided at the call site."}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "function new( string name $=$ )"}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "Create a new instance of this type, giving it the optional name."}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "virtual function string convert2string()"}
{"type": "text", "page_from": 694, "page_to": 694, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=694", "section_title": "Generic Register Operation Descriptors", "content": "Returns a string showing the contents of this transaction."}
{"type": "text", "page_from": 695, "page_to": 695, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=695", "section_title": "Generic Register Operation Descriptors", "content": "Struct that defines a generic bus transaction for register and memory accesses, having kind (read or write), address, data, and byte enable information. If the bus is narrower than the register or memory location being accessed, there will be multiple of these bus operations for every abstract uvm_reg_item transaction. In this case, data represents the portion of uvm_reg_item::value being transferred during this bus cycle. If the bus is wide enough to perform the register or memory operation in a single cycle, data will be the same as uvm_reg_item::value."}
{"type": "text", "page_from": 695, "page_to": 695, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=695", "section_title": "Generic Register Operation Descriptors", "content": "Struct that defines a generic bus transaction for register and memory accesses, having kind (read or write), address, data, and byte enable information."}
{"type": "text", "page_from": 695, "page_to": 695, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=695", "section_title": "Generic Register Operation Descriptors", "content": "Kind of access: READ or WRITE."}
{"type": "text", "page_from": 696, "page_to": 696, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=696", "section_title": "Generic Register Operation Descriptors", "content": "The number of bits of uvm_reg_item::value being transferred by this transaction."}
{"type": "text", "page_from": 696, "page_to": 696, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=696", "section_title": "Generic Register Operation Descriptors", "content": "uvm_reg_byte_en_t byte_en"}
{"type": "text", "page_from": 696, "page_to": 696, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=696", "section_title": "Generic Register Operation Descriptors", "content": "Enables for the byte lanes on the bus. Meaningful only when the bus supports byte enables and the operation originates from a field write/read."}
{"type": "text", "page_from": 696, "page_to": 696, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=696", "section_title": "Generic Register Operation Descriptors", "content": "The result of the transaction: UVM_IS_OK, UVM_HAS_X, UVM_NOT_OK. See uvm_status_e."}
{"type": "text", "page_from": 697, "page_to": 697, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=697", "section_title": "Classes for Adapting Between Register and Bus Operations", "header_path": ["26", "2"], "chapter": "26", "section": "26.2", "content": "26.2 Classes for Adapting Between Register and Bus Operations"}
{"type": "text", "page_from": 697, "page_to": 697, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=697", "section_title": "Register Model Adaptor", "content": "This section defines classes used to convert transaction streams between generic register address/data reads and writes and physical bus accesses."}
{"type": "text", "page_from": 697, "page_to": 697, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=697", "section_title": "Register Model Adaptor", "content": "This class defines an interface for converting between uvm_reg_bus_op and a specific bus transaction."}
{"type": "text", "page_from": 697, "page_to": 697, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=697", "section_title": "Register Model Adaptor", "content": "This class defines an interface for converting between uvm_reg_bus_op and a specific bus transaction."}
{"type": "text", "page_from": 697, "page_to": 697, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=697", "section_title": "Register Model Adaptor", "content": "virtual class uvm_reg_adapter extends uvm_object"}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "Create a new instance of this type, giving it the optional name."}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "supports_byte_enable"}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "bit supports_byte_enable"}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "Set this bit in extensions of this class if the bus protocol supports byte enables."}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "bit provides_responses"}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "Set this bit in extensions of this class if the bus driver provides separate response items."}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "uvm_sequence_base parent_sequence"}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "Set this member in extensions of this class if the bus driver requires bus items be executed via a particular sequence base type. The sequence assigned to this member must implement do_clone()."}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "pure virtual function uvm_sequence_item reg2bus( const ref uvm_reg_bus_op rw"}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "Extensions of this class must implement this method to convert the specified uvm_reg_bus_op to a corresponding uvm_sequence_item subtype that defines the bus transaction."}
{"type": "text", "page_from": 698, "page_to": 698, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=698", "section_title": "Register Model Adaptor", "content": "The method must allocate a new bus-specific uvm_sequence_item, assign its members from the corresponding members from the given generic rw bus operation, then return it."}
{"type": "text", "page_from": 699, "page_to": 699, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=699", "section_title": "Register Model Adaptor", "content": "pure virtual function void bus2reg( uvm_sequence_item bus_item, ref uvm_reg_bus_op rw )"}
{"type": "text", "page_from": 699, "page_to": 699, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=699", "section_title": "Register Model Adaptor", "content": "Extensions of this class must implement this method to copy members of the given busspecific bus_item to corresponding members of the provided bus_rw instance. Unlike reg2bus, the resulting transaction is not allocated from scratch. This is to accommodate applications where the bus response must be returned in the original request."}
{"type": "text", "page_from": 699, "page_to": 699, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=699", "section_title": "Register Model Adaptor", "content": "virtual function uvm_reg_item get_item()"}
{"type": "text", "page_from": 699, "page_to": 699, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=699", "section_title": "Register Model Adaptor", "content": "Returns the bus-independent read/write information that corresponds to the generic bus transaction currently translated to a bus-specific transaction. This function returns a value reference only when called in the uvm_reg_adapter::reg2bus() method. It returns null at all other times. The content of the return uvm_reg_item instance must not be modified and used strictly to obtain additional information about the operation."}
{"type": "text", "page_from": 699, "page_to": 699, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=699", "section_title": "Register Model Adaptor", "content": "The following example illustrates how to implement a RegModel-BUS adapter class for the APB bus protocol."}
{"type": "text", "page_from": 700, "page_to": 700, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=700", "section_title": "Register Model Adaptor", "content": "For converting between uvm_reg_bus_op and uvm_tlm_gp items."}
{"type": "text", "page_from": 700, "page_to": 700, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=700", "section_title": "Register Model Adaptor", "content": "class uvm_reg_tlm_adapter extends uvm_reg_adapter"}
{"type": "text", "page_from": 700, "page_to": 700, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=700", "section_title": "Register Model Adaptor", "content": "reg2bus Converts a uvm_reg_bus_op struct to a uvm_tlm_gp item. bus2reg Converts a uvm_tlm_gp item to a uvm_reg_bus_op."}
{"type": "text", "page_from": 700, "page_to": 700, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=700", "section_title": "Register Model Adaptor", "content": "virtual function uvm_sequence_item reg2bus( const ref uvm_reg_bus_op rw"}
{"type": "text", "page_from": 700, "page_to": 700, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=700", "section_title": "Register Model Adaptor", "content": "Converts a uvm_reg_bus_op struct to a uvm_tlm_gp item."}
{"type": "text", "page_from": 700, "page_to": 700, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=700", "section_title": "Register Model Adaptor", "content": "virtual function void bus2reg( uvm_sequence_item bus_item, ref uvm_reg_bus_op rw"}
{"type": "text", "page_from": 700, "page_to": 700, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=700", "section_title": "Register Model Adaptor", "content": "Converts a uvm_tlm_gp item to a uvm_reg_bus_op. into the provided rw transaction."}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "header_path": ["26", "3"], "chapter": "26", "section": "26.3", "content": "26.3 Explicit Register Predictor"}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "The uvm_reg_predictor class defines a predictor component, which is used to update the register model’s mirror values based on transactions explicitly observed on a physical bus."}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "Explicit Register Predictor"}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "The uvm_reg_predictor class defines a predictor component, which is used to update the register model’s mirror values based on transactions explicitly observed on a physical bus."}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "Updates the register model mirror based on observed bus transactions"}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "This class converts observed bus transactions of type BUSTYPE to generic registers transactions, determines the register being accessed based on the bus address, then updates the register’s mirror value with the observed bus data, subject to the register’s access mode. See uvm_reg::predict for details."}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "Memories can be large, so their accesses are not predicted."}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "Updates the register model mirror based on observed bus transactions"}
{"type": "text", "page_from": 701, "page_to": 701, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=701", "section_title": "Explicit Register Predictor", "content": "class uvm_reg_predictor #( type BUSTYPE $=$ int ) extends uvm_component"}
{"type": "text", "page_from": 702, "page_to": 702, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=702", "section_title": "Explicit Register Predictor", "content": "uvm_analysis_imp #( BUSTYPE, uvm_reg_predictor #(BUSTYPE) ) bus_in"}
{"type": "text", "page_from": 702, "page_to": 702, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=702", "section_title": "Explicit Register Predictor", "content": "Observed bus transactions of type BUSTYPE are received from this port and processed."}
{"type": "text", "page_from": 702, "page_to": 702, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=702", "section_title": "Explicit Register Predictor", "content": "For each incoming transaction, the predictor will attempt to get the register or memory handle corresponding to the observed bus address."}
{"type": "text", "page_from": 702, "page_to": 702, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=702", "section_title": "Explicit Register Predictor", "content": "If there is a match, the predictor calls the register or memory’s predict method, passing in the observed bus data. The register or memory mirror will be updated with this data, subject to its configured access behavior--RW, RO, WO, etc. The predictor will also convert the bus transaction to a generic uvm_reg_item and send it out the reg_ap analysis port."}
{"type": "text", "page_from": 702, "page_to": 702, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=702", "section_title": "Explicit Register Predictor", "content": "If the register is wider than the bus, the predictor will collect the multiple bus transactions needed to determine the value being read or written."}
{"type": "text", "page_from": 702, "page_to": 702, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=702", "section_title": "Explicit Register Predictor", "content": "uvm_analysis_port #( uvm_reg_item reg_ap"}
{"type": "text", "page_from": 702, "page_to": 702, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=702", "section_title": "Explicit Register Predictor", "content": "Analysis output port that publishes uvm_reg_item transactions converted from bus transactions received on bus_in."}
{"type": "text", "page_from": 703, "page_to": 703, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=703", "section_title": "Explicit Register Predictor", "content": "The adapter used to convey the parameters of a bus operation in terms of a canonical uvm_reg_bus_op datum. The uvm_reg_adapter must be configured before the run phase."}
{"type": "text", "page_from": 703, "page_to": 703, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=703", "section_title": "Explicit Register Predictor", "content": "function new ( string name, uvm_component parent"}
{"type": "text", "page_from": 703, "page_to": 703, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=703", "section_title": "Explicit Register Predictor", "content": "Create a new instance of this type, giving it the optional name and parent."}
{"type": "text", "page_from": 703, "page_to": 703, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=703", "section_title": "Explicit Register Predictor", "content": "virtual function void pre_predict( uvm_reg_item rw"}
{"type": "text", "page_from": 703, "page_to": 703, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=703", "section_title": "Explicit Register Predictor", "content": "Override this method to change the value or re-direct the target register"}
{"type": "text", "page_from": 703, "page_to": 703, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=703", "section_title": "Explicit Register Predictor", "content": "virtual function void check_phase( uvm_phase phase"}
{"type": "text", "page_from": 703, "page_to": 703, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=703", "section_title": "Explicit Register Predictor", "content": "Checks that no pending register transactions are still queued."}
{"type": "text", "page_from": 704, "page_to": 704, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=704", "section_title": "Register Sequence Classes", "header_path": ["26", "4"], "chapter": "26", "section": "26.4", "content": "26.4 Register Sequence Classes"}
{"type": "text", "page_from": 704, "page_to": 704, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=704", "section_title": "Register Sequences", "content": "This section defines the base classes used for register stimulus generation."}
{"type": "text", "page_from": 704, "page_to": 704, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=704", "section_title": "Register Sequences", "content": "This class provides base functionality for both user-defined RegModel test sequences and “register translation sequences”."}
{"type": "text", "page_from": 704, "page_to": 704, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=704", "section_title": "Register Sequences", "content": "When used as a base for user-defined RegModel test sequences, this class provides convenience methods for reading and writing registers and memories. Users implement the body() method to interact directly with the RegModel model (held in the model property) or indirectly via the delegation methods in this class. When used as a translation sequence, objects of this class are executed directly on a bus sequencer which are used in support of a layered sequencer use model, a pre-defined convert-and-execute algorithm is provided."}
{"type": "text", "page_from": 704, "page_to": 704, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=704", "section_title": "Register Sequences", "content": "Register operations do not require extending this class if none of the above services are needed. Register test sequences can be extend from the base uvm_sequence #(REQ,RSP) base class or even from outside a sequence."}
{"type": "text", "page_from": 704, "page_to": 704, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=704", "section_title": "Register Sequences", "content": "Note- The convenience API not yet implemented."}
{"type": "text", "page_from": 704, "page_to": 704, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=704", "section_title": "Register Sequences", "content": "This class provides base functionality for both user-defined RegModel test sequences and “register translation sequences”."}
{"type": "text", "page_from": 705, "page_to": 705, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=705", "section_title": "Register Sequences", "content": "Specifies the sequence type to extend from."}
{"type": "text", "page_from": 705, "page_to": 705, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=705", "section_title": "Register Sequences", "content": "When used as a translation sequence running on a bus sequencer, BASE must be compatible with the sequence type expected by the bus sequencer."}
{"type": "text", "page_from": 705, "page_to": 705, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=705", "section_title": "Register Sequences", "content": "When used as a test sequence running on a particular sequencer, BASE must be compatible with the sequence type expected by that sequencer."}
{"type": "text", "page_from": 705, "page_to": 705, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=705", "section_title": "Register Sequences", "content": "When used as a virtual test sequence without a sequencer, BASE does not need to be specified, i.e. the default specialization is adequate."}
{"type": "text", "page_from": 705, "page_to": 705, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=705", "section_title": "Register Sequences", "content": "To maximize opportunities for reuse, user-defined RegModel sequences should “promote” the BASE parameter."}
{"type": "text", "page_from": 705, "page_to": 705, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=705", "section_title": "Register Sequences", "content": "This way, the RegModel sequence can be extended from user-defined base sequences."}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "Block abstraction this sequence executes on, defined only when this sequence is a userdefined test sequence."}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "uvm_reg_adapter adapter"}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "Adapter to use for translating between abstract register transactions and physical bus transactions, defined only when this sequence is a translation sequence."}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "uvm_sequencer #( uvm_reg_item reg_seqr"}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "Layered upstream “register” sequencer."}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "Specifies the upstream sequencer between abstract register transactions and physical bus transactions. Defined only when this sequence is a translation sequence, and we want to “pull” from an upstream sequencer."}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "function new ( string name $=$ \"uvm_reg_sequence_inst\" )"}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "Create a new instance, giving it the optional name."}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "Continually gets a register transaction from the configured upstream sequencer, reg_seqr, and executes the corresponding bus transaction via do_reg_item."}
{"type": "text", "page_from": 706, "page_to": 706, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=706", "section_title": "Register Sequences", "content": "User-defined RegModel test sequences must override body() and not call super.body(), else a warning will be issued and the calling process not return."}
{"type": "text", "page_from": 707, "page_to": 707, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=707", "section_title": "Register Sequences", "content": "The following methods delegate to the corresponding method in the register or memory element. They allow a sequence body() to do reads and writes without having to explicitly supply itself to parent sequence argument. Thus, a register write"}
{"type": "text", "page_from": 707, "page_to": 707, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=707", "section_title": "Register Sequences", "content": "can be written instead as"}
{"type": "text", "page_from": 707, "page_to": 707, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=707", "section_title": "Register Sequences", "content": "Writes the given register rg using uvm_reg::write, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 707, "page_to": 707, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=707", "section_title": "Register Sequences", "content": "model.regA.write(status, value, .parent(this));"}
{"type": "text", "page_from": 707, "page_to": 707, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=707", "section_title": "Register Sequences", "content": "Reads the given register rg using uvm_reg::read, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 707, "page_to": 707, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=707", "section_title": "Register Sequences", "content": "read_reg(model.regA, status, value);"}
{"type": "text", "page_from": 708, "page_to": 708, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=708", "section_title": "Register Sequences", "content": "model.regA.read(status, value, .parent(this));"}
{"type": "text", "page_from": 708, "page_to": 708, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=708", "section_title": "Register Sequences", "content": "Pokes the given register rg using uvm_reg::poke, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 708, "page_to": 708, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=708", "section_title": "Register Sequences", "content": "Peeks the given register rg using uvm_reg::peek, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 708, "page_to": 708, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=708", "section_title": "Register Sequences", "content": "model.regA.peek(status, value, .parent(this));"}
{"type": "text", "page_from": 709, "page_to": 709, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=709", "section_title": "Register Sequences", "content": "Updates the given register $r g$ using uvm_reg::update, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 709, "page_to": 709, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=709", "section_title": "Register Sequences", "content": "Mirrors the given register rg using uvm_reg::mirror, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 709, "page_to": 709, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=709", "section_title": "Register Sequences", "content": "virtual task write_mem( input uvm_mem mem, output uvm status e status,"}
{"type": "text", "page_from": 709, "page_to": 709, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=709", "section_title": "Register Sequences", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 710, "page_to": 710, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=710", "section_title": "Register Sequences", "content": "Writes the given memory mem using uvm_mem::write, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 710, "page_to": 710, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=710", "section_title": "Register Sequences", "content": "Reads the given memory mem using uvm_mem::read, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 710, "page_to": 710, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=710", "section_title": "Register Sequences", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "Pokes the given memory mem using uvm_mem::poke, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "model.regA.poke(status, offset, value, .parent(this));"}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "Peeks the given memory mem using uvm_mem::peek, supplying ‘this’ as the parent argument. Thus,"}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "odel.regA.peek(status, offset, value, .parent(this))"}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "Facade class for register and memory frontdoor access."}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "User-defined frontdoor access sequence"}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "Base class for user-defined access to register and memory reads and writes through a physical interface."}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "By default, different registers and memories are mapped to different addresses in the address space and are accessed via those exclusively through physical addresses."}
{"type": "text", "page_from": 711, "page_to": 711, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=711", "section_title": "Register Sequences", "content": "The frontdoor allows access using a non-linear and/or non-mapped mechanism. Users can extend this class to provide the physical access to these registers."}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "Facade class for register and memory frontdoor access."}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "virtual class uvm_reg_frontdoor extends uvm_reg_sequence #( uvm_sequence #(uvm_sequence_item) )"}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "rw_info Holds information about the register being read or written sequencer Sequencer executing the operation"}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "Constructor, new object given optional name."}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "uvm_reg_item rw_info"}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "Holds information about the register being read or written"}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "uvm_sequencer_base sequencer"}
{"type": "text", "page_from": 712, "page_to": 712, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=712", "section_title": "Register Sequences", "content": "Sequencer executing the operation"}
{"type": "text", "page_from": 713, "page_to": 713, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=713", "section_title": "uvm_reg_backdoor", "header_path": ["26", "5"], "chapter": "26", "section": "26.5", "content": "26.5 uvm_reg_backdoor"}
{"type": "text", "page_from": 713, "page_to": 713, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=713", "section_title": "Backdoors", "content": "Base class for user-defined back-door register and memory access."}
{"type": "text", "page_from": 713, "page_to": 713, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=713", "section_title": "Backdoors", "content": "This class can be extended by users to provide user-specific back-door access to registers and memories that are not implemented in pure SystemVerilog or that are not accessible using the default DPI backdoor mechanism."}
{"type": "text", "page_from": 713, "page_to": 713, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=713", "section_title": "Backdoors", "content": "Base class for user-defined back-door register and memory access."}
{"type": "text", "page_from": 713, "page_to": 713, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=713", "section_title": "Backdoors", "content": "class uvm_reg_backdoor extends uvm_object"}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "protected task do_pre_read( uvm_reg_item rw"}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "Execute the pre-read callbacks"}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "This method must be called as the first statement in a user extension of the read() method."}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "protected task do_post_read( uvm_reg_item rw"}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "Execute the post-read callbacks"}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "This method must be called as the last statement in a user extension of the read() method."}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "Execute the pre-write callbacks"}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "This method must be called as the first statement in a user extension of the write() method."}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "Execute the post-write callbacks"}
{"type": "text", "page_from": 714, "page_to": 714, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=714", "section_title": "Backdoors", "content": "This method must be called as the last statement in a user extension of the write() method."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "User-defined backdoor read operation."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "Overload this method only if the backdoor requires the use of task."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "Call do_pre_read(). Peek the current value of the specified HDL implementation. Call do_post_read(). Returns the current value and an indication of the success of the operation."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "By default, calls read_func()."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "User-defined backdoor read operation."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "Peek the current value in the HDL implementation. Returns the current value and an indication of the success of the operation."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "virtual function bit is_auto_updated( uvm_reg_field field"}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "Indicates if wait_for_change() method is implemented"}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "Implement to return TRUE if and only if wait_for_change() is implemented to watch for changes in the HDL implementation of the specified field"}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "Wait for a change in the value of the register or memory element in the DUT."}
{"type": "text", "page_from": 715, "page_to": 715, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=715", "section_title": "Backdoors", "content": "When this method returns, the mirror value for the register corresponding to this instance of the backdoor class will be updated via a backdoor read operation."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "The registered callback methods are invoked after the invocation of this method."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "virtual task post_read( uvm_reg_item rw )"}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "Called after user-defined backdoor register read."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "The registered callback methods are invoked before the invocation of this method."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "Called before user-defined backdoor register write."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "The registered callback methods are invoked after the invocation of this method."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "The written value, if modified, modifies the actual value that will be written."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "Called after user-defined backdoor register write."}
{"type": "text", "page_from": 716, "page_to": 716, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=716", "section_title": "Backdoors", "content": "The registered callback methods are invoked before the invocation of this method."}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "UVM HDL Backdoor Access support routines", "header_path": ["26", "6"], "chapter": "26", "section": "26.6", "content": "26.6 UVM HDL Backdoor Access support routines"}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "These routines provide an interface to the DPI/PLI implementation of backdoor access used by registers."}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "If you DON’T want to use the DPI HDL API, then compile your SystemVerilog code with the vlog switch"}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "UVM HDL Backdoor Access support routines."}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "These routines provide an interface to the DPI/PLI implementation of backdoor access used by registers."}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "Sets the maximum size bit vector for backdoor access."}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "parameter int UVM_HDL_MAX_WIDTH $=$ \\`UVM_HDL_MAX_WIDTH"}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "Sets the maximum size bit vector for backdoor access. This parameter will be looked up by the DPI-C code using: vpi_handle_by_name( “uvm_pkg::UVM_HDL_MAX_WIDTH”, 0);"}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "import \"DPI-C\" context function int uvm_hdl_check_path( string path"}
{"type": "text", "page_from": 717, "page_to": 717, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=717", "section_title": "HDL Access", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "Checks that the given HDL path exists. Returns 0 if NOT found, 1 otherwise."}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "import \"DPI-C\" context function int uvm_hdl_deposit( string path, uvm_hdl_data_t value )"}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "Sets the given HDL path to the specified value. Returns 1 if the call succeeded, 0 otherwise."}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "import \"DPI-C\" context function int uvm_hdl_force( string path, uvm_hdl_data_t value )"}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "Forces the value on the given path. Returns 1 if the call succeeded, 0 otherwise."}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "task uvm_hdl_force_time( string path, uvm_hdl_data_t value, time force_time = 0 )"}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "Forces the value on the given path for the specified amount of force_time. If force_time is 0, uvm_hdl_deposit is called. Returns 1 if the call succeeded, 0 otherwise."}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "uvm_hdl_release_and_read"}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "import \"DPI-C\" context function int uvm_hdl_release_and_read( string path, inout uvm_hdl_data_t value"}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "Releases a value previously set with uvm_hdl_force. Returns 1 if the call succeeded, 0 otherwise. value is set to the HDL value after the release. For ‘reg’, the value will still be the forced value until it has been procedurally reassigned. For ‘wire’, the value will change immediately to the resolved value of its continuous drivers, if any. If none, its value remains as forced until the next direct assignment."}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "import \"DPI-C\" context function int uvm_hdl_release( string path"}
{"type": "text", "page_from": 718, "page_to": 718, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=718", "section_title": "HDL Access", "content": "Releases a value previously set with uvm_hdl_force. Returns 1 if the call succeeded, 0 otherwise."}
{"type": "text", "page_from": 719, "page_to": 719, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=719", "section_title": "HDL Access", "content": "import \"DPI-C\" context function int uvm_hdl_read( string path, output uvm_hdl_data_t value )"}
{"type": "text", "page_from": 719, "page_to": 719, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=719", "section_title": "HDL Access", "content": "Gets the value at the given path. Returns 1 if the call succeeded, 0 otherwise."}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "Sequence that executes a user-defined selection of pre-defined register and memory test sequences."}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "uvm_reg_mem_built_in_seq"}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "Sequence that executes a user-defined selection of pre-defined register and memory test sequences."}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "class uvm_reg_mem_built_in_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "model The block to be tested. tests The pre-defined test sequences to be executed."}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "ody Executes any or all the built-in register and memory sequences."}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "The block to be tested. Declared in the base class."}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "bit [63:0] tests $=$ UVM_DO_ALL_REG_MEM_TESTS"}
{"type": "text", "page_from": 720, "page_to": 720, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=720", "section_title": "Run All Built-In", "content": "The pre-defined test sequences to be executed."}
{"type": "text", "page_from": 721, "page_to": 721, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=721", "section_title": "Run All Built-In", "content": "Executes any or all the built-in register and memory sequences. Do not call directly. Use seq.start() instead."}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "uvm_reg_hw_reset_seq", "header_path": ["27", "2"], "chapter": "27", "section": "27.2", "content": "27.2 uvm_reg_hw_reset_seq"}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "Test the hard reset values of registers"}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "The test sequence performs the following steps"}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "1. resets the DUT and the block abstraction class associated with this sequence."}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "2. reads all of the registers in the block, via all of the available address maps, comparing the value read with the expected reset value."}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "If bit-type resource named “NO_REG_TESTS” or “NO_REG_HW_RESET_TEST” in the “REG::” namespace matches the full name of the block or register, the block or register is not tested."}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "This is usually the first test executed on any DUT."}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "uvm_reg_hw_reset_seq"}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "Test the hard reset values of registers"}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "class uvm_reg_hw_reset_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item)"}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "model The block to be tested. body Executes the Hardware Reset sequence."}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "do_block Test all of the registers in a given block reset_blk Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 722, "page_to": 722, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=722", "section_title": "Reset", "content": "The block to be tested. Declared in the base class."}
{"type": "text", "page_from": 723, "page_to": 723, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=723", "section_title": "Reset", "content": "Executes the Hardware Reset sequence. Do not call directly. Use seq.start() instead."}
{"type": "text", "page_from": 723, "page_to": 723, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=723", "section_title": "Reset", "content": "protected virtual task do_block( uvm_reg_block blk"}
{"type": "text", "page_from": 723, "page_to": 723, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=723", "section_title": "Reset", "content": "Test all of the registers in a given block"}
{"type": "text", "page_from": 723, "page_to": 723, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=723", "section_title": "Reset", "content": "Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 723, "page_to": 723, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=723", "section_title": "Reset", "content": "Currently empty. Will rollback the environment’s phase to the reset phase once the new phasing is available."}
{"type": "text", "page_from": 723, "page_to": 723, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=723", "section_title": "Reset", "content": "In the meantime, the DUT should be reset before executing this test sequence or this method should be implemented in an extension to reset the DUT."}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Bit Bashing Test Sequences", "header_path": ["27", "3"], "chapter": "27", "section": "27.3", "content": "27.3 Bit Bashing Test Sequences"}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "This section defines classes that test individual bits of the registers defined in a register model."}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "Verify the implementation of a single register by attempting to write 1’s and $0 ^ { \\prime } s$ to every bit in it, via every address map in which the register is mapped, making sure that the resulting value matches the mirrored value."}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "If bit-type resource named “NO_REG_TESTS” or “NO_REG_BIT_BASH_TEST” in the “REG::” namespace matches the full name of the register, the register is not tested."}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "Registers that contain fields with unknown access policies cannot be tested."}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "The DUT should be idle and not modify any register during this test."}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "uvm_reg_single_bit_bash_seq"}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "Verify the implementation of a single register by attempting to write 1’s and $0 ^ { \\prime } s$ to every bit in it, via every address map in which the register is mapped, making sure that the resulting value matches the mirrored value."}
{"type": "text", "page_from": 724, "page_to": 724, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=724", "section_title": "Register Bit Bash", "content": "class uvm_reg_single_bit_bash_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item)"}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "The register to be tested"}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "Verify the implementation of all registers in a block by executing the uvm_reg_single_bit_bash_seq sequence on it."}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "If bit-type resource named “NO_REG_TESTS” or “NO_REG_BIT_BASH_TEST” in the “REG::” namespace matches the full name of the block, the block is not tested."}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "uvm_reg_bit_bash_seq"}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "Verify the implementation of all registers in a block by executing the uvm_reg_single_bit_bash_seq sequence on it."}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "class uvm_reg_bit_bash_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item)"}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "model The block to be tested. reg_seq The sequence used to test one register"}
{"type": "text", "page_from": 725, "page_to": 725, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=725", "section_title": "Register Bit Bash", "content": "body Executes the Register Bit Bash sequence. do_block Test all of the registers in a given block reset_blk Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "The block to be tested. Declared in the base class."}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "protected uvm_reg_single_bit_bash_seq reg_seq"}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "The sequence used to test one register"}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "Executes the Register Bit Bash sequence. Do not call directly. Use seq.start() instead."}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "protected virtual task do_block( uvm_reg_block blk"}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "Test all of the registers in a given block"}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "Currently empty. Will rollback the environment’s phase to the reset phase once the new phasing is available."}
{"type": "text", "page_from": 726, "page_to": 726, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=726", "section_title": "Register Bit Bash", "content": "In the meantime, the DUT should be reset before executing this test sequence or this method should be implemented in an extension to reset the DUT."}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access Test Sequences", "header_path": ["27", "4"], "chapter": "27", "section": "27.4", "content": "27.4 Register Access Test Sequences"}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "This section defines sequences that test DUT register access via the available frontdoor and backdoor paths defined in the provided register model."}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "Verify the accessibility of a register by writing through its default address map then reading it via the backdoor, then reversing the process, making sure that the resulting value matches the mirrored value."}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "If bit-type resource named “NO_REG_TESTS” or “NO_REG_ACCESS_TEST” in the “REG::” namespace matches the full name of the register, the register is not tested."}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "Registers without an available backdoor or that contain read-only fields only, or fields with unknown access policies cannot be tested."}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "The DUT should be idle and not modify any register during this test."}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "uvm_reg_single_access_seq"}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "Verify the accessibility of a register by writing through its default address map then reading it via the backdoor, then reversing the process, making sure that the resulting value matches the mirrored value."}
{"type": "text", "page_from": 727, "page_to": 727, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=727", "section_title": "Register Access", "content": "uvm_reg_sequence#(uvm_sequence#(uvm_reg_item))"}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "uvm_reg_single_access_seq"}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "class uvm_reg_single_access_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "The register to be tested"}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "The register to be tested"}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "Verify the accessibility of all registers in a block by executing the uvm_reg_single_access_seq sequence on every register within it."}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "If bit-type resource named “NO_REG_TESTS” or “NO_REG_ACCESS_TEST” in the “REG::” namespace matches the full name of the block, the block is not tested."}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "uvm_resource_db#(bit)::set({\"REG::\",regmodel.blk.get_full_name(),\".\\*\"}, \"NO_REG_TESTS\", 1, this);"}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "Verify the accessibility of all registers in a block by executing the uvm_reg_single_access_seq sequence on every register within it."}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "class uvm_reg_access_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item)"}
{"type": "text", "page_from": 728, "page_to": 728, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=728", "section_title": "Register Access", "content": "model The block to be tested. reg_seq The sequence used to test one register"}
{"type": "text", "page_from": 729, "page_to": 729, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=729", "section_title": "Register Access", "content": "The block to be tested. Declared in the base class."}
{"type": "text", "page_from": 729, "page_to": 729, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=729", "section_title": "Register Access", "content": "protected uvm_reg_single_access_seq reg_seq"}
{"type": "text", "page_from": 729, "page_to": 729, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=729", "section_title": "Register Access", "content": "The sequence used to test one register"}
{"type": "text", "page_from": 729, "page_to": 729, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=729", "section_title": "Register Access", "content": "Executes the Register Access sequence. Do not call directly. Use seq.start() instead."}
{"type": "text", "page_from": 729, "page_to": 729, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=729", "section_title": "Register Access", "content": "protected virtual task do_block( uvm_reg_block blk"}
{"type": "text", "page_from": 729, "page_to": 729, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=729", "section_title": "Register Access", "content": "Test all of the registers in a block"}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "phasing is available."}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "In the meantime, the DUT should be reset before executing this test sequence or this method should be implemented in an extension to reset the DUT."}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "uvm_reg_mem_access_seq"}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "Verify the accessibility of all registers and memories in a block by executing the uvm_reg_access_seq and uvm_mem_access_seq sequence respectively on every register and memory within it."}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "Blocks and registers with the NO_REG_TESTS or the NO_REG_ACCESS_TEST attribute are not verified."}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "uvm_reg_mem_access_seq"}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "Verify the accessibility of all registers and memories in a block by executing the uvm_reg_access_seq and uvm_mem_access_seq sequence respectively on every register and memory within it."}
{"type": "text", "page_from": 730, "page_to": 730, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=730", "section_title": "Register Access", "content": "class uvm_reg_mem_access_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 731, "page_to": 731, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=731", "section_title": "Shared Register and Memory Access Test Sequences", "header_path": ["27", "5"], "chapter": "27", "section": "27.5", "content": "27.5 Shared Register and Memory Access Test Sequences"}
{"type": "text", "page_from": 731, "page_to": 731, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=731", "section_title": "Shared Access", "content": "This section defines sequences for testing registers and memories that are shared between two or more physical interfaces, i.e. are associated with more than one uvm_reg_map instance."}
{"type": "text", "page_from": 731, "page_to": 731, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=731", "section_title": "Shared Access", "content": "Verify the accessibility of a shared register by writing through each address map then reading it via every other address maps in which the register is readable and the backdoor, making sure that the resulting value matches the mirrored value."}
{"type": "text", "page_from": 731, "page_to": 731, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=731", "section_title": "Shared Access", "content": "If bit-type resource named “NO_REG_TESTS” or “NO_REG_SHARED_ACCESS_TEST” in the “REG::” namespace matches the full name of the register, the register is not tested."}
{"type": "text", "page_from": 731, "page_to": 731, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=731", "section_title": "Shared Access", "content": "Registers that contain fields with unknown access policies cannot be tested."}
{"type": "text", "page_from": 731, "page_to": 731, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=731", "section_title": "Shared Access", "content": "The DUT should be idle and not modify any register during this test."}
{"type": "text", "page_from": 731, "page_to": 731, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=731", "section_title": "Shared Access", "content": "uvm_reg_shared_access_seq"}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "Verify the accessibility of a shared register by writing through each address map then reading it via every other address maps in which the register is readable and the backdoor, making sure that the resulting value matches the mirrored value."}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "class uvm_reg_shared_access_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "The register to be tested"}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "The register to be tested"}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "uvm_mem_shared_access_seq"}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "Verify the accessibility of a shared memory by writing through each address map then reading it via every other address maps in which the memory is readable and the backdoor, making sure that the resulting value matches the written value."}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "If bit-type resource named “NO_REG_TESTS”, “NO_MEM_TESTS”, “NO_REG_SHARED_ACCESS_TEST” or “NO_MEM_SHARED_ACCESS_TEST” in the “REG::” namespace matches the full name of the memory, the memory is not tested."}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "The DUT should be idle and not modify the memory during this test."}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "uvm_mem_shared_access_seq"}
{"type": "text", "page_from": 732, "page_to": 732, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=732", "section_title": "Shared Access", "content": "Verify the accessibility of a shared memory by writing through each address map then reading it via every other address maps in which the memory is readable and the backdoor, making sure that the resulting value matches the written value."}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "uvm_reg_sequence#(uvm_sequence#(uvm_reg_item))"}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "uvm_mem_shared_access_seq"}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "class uvm_mem_shared_access_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "The memory to be tested"}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "The memory to be tested"}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "Verify the accessibility of all shared registers and memories in a block by executing the uvm_reg_shared_access_seq and uvm_mem_shared_access_seq sequence respectively on every register and memory within it."}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "If bit-type resource named “NO_REG_TESTS”, “NO_MEM_TESTS”, “NO_REG_SHARED_ACCESS_TEST” or “NO_MEM_SHARED_ACCESS_TEST” in the “REG::” namespace matches the full name of the block, the block is not tested."}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "Verify the accessibility of all shared registers and memories in a block by executing the uvm_reg_shared_access_seq and uvm_mem_shared_access_seq sequence respectively on every register and memory within it."}
{"type": "text", "page_from": 733, "page_to": 733, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=733", "section_title": "Shared Access", "content": "class uvm_reg_mem_shared_access_seq extends uvm_reg_sequence #("}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "model The block to be tested reg_seq The sequence used to test one register mem_seq The sequence used to test one memory"}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "body Executes the Shared Register and Memory sequence do_block Test all of the registers and memories in a block reset_blk Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "The block to be tested"}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "uvm_reg_block model;"}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "protected uvm_reg_shared_access_seq reg_seq"}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "The sequence used to test one register"}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "protected uvm_mem_shared_access_seq mem_seq"}
{"type": "text", "page_from": 734, "page_to": 734, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=734", "section_title": "Shared Access", "content": "The sequence used to test one memory"}
{"type": "text", "page_from": 735, "page_to": 735, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=735", "section_title": "Shared Access", "content": "Test all of the registers and memories in a block"}
{"type": "text", "page_from": 735, "page_to": 735, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=735", "section_title": "Shared Access", "content": "Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 735, "page_to": 735, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=735", "section_title": "Shared Access", "content": "Currently empty. Will rollback the environment’s phase to the reset phase once the new phasing is available."}
{"type": "text", "page_from": 735, "page_to": 735, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=735", "section_title": "Shared Access", "content": "In the meantime, the DUT should be reset before executing this test sequence or this method should be implemented in an extension to reset the DUT."}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "Memory Access Test Sequence"}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "Verify the accessibility of a memory by writing through its default address map then reading it via the backdoor, then reversing the process, making sure that the resulting value matches the written value."}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "If bit-type resource named “NO_REG_TESTS”, “NO_MEM_TESTS”, or “NO_MEM_ACCESS_TEST” in the “REG::” namespace matches the full name of the memory, the memory is not tested."}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "Memories without an available backdoor cannot be tested."}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "The DUT should be idle and not modify the memory during this test."}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "uvm_mem_single_access_seq"}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "Verify the accessibility of a memory by writing through its default address map then reading it via the backdoor, then reversing the process, making sure that the resulting value matches the written value."}
{"type": "text", "page_from": 736, "page_to": 736, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=736", "section_title": "Memory Access", "content": "class uvm_mem_single_access_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "The memory to be tested"}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "The memory to be tested"}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "Verify the accessibility of all memories in a block by executing the uvm_mem_single_access_seq sequence on every memory within it."}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "If bit-type resource named “NO_REG_TESTS”, “NO_MEM_TESTS”, or “NO_MEM_ACCESS_TEST” in the “REG::” namespace matches the full name of the block, the block is not tested."}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "Verify the accessibility of all memories in a block by executing the uvm_mem_single_access_seq sequence on every memory within it."}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "class uvm_mem_access_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item)"}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "model The block to be tested. mem_seq The sequence used to test one memory"}
{"type": "text", "page_from": 737, "page_to": 737, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=737", "section_title": "Memory Access", "content": "body Execute the Memory Access sequence. do_block Test all of the memories in a given block reset_blk Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 738, "page_to": 738, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=738", "section_title": "Memory Access", "content": "The block to be tested. Declared in the base class."}
{"type": "text", "page_from": 738, "page_to": 738, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=738", "section_title": "Memory Access", "content": "protected uvm_mem_single_access_seq mem_seq"}
{"type": "text", "page_from": 738, "page_to": 738, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=738", "section_title": "Memory Access", "content": "The sequence used to test one memory"}
{"type": "text", "page_from": 738, "page_to": 738, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=738", "section_title": "Memory Access", "content": "Execute the Memory Access sequence. Do not call directly. Use seq.start() instead."}
{"type": "text", "page_from": 738, "page_to": 738, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=738", "section_title": "Memory Access", "content": "protected virtual task do_block( uvm_reg_block blk"}
{"type": "text", "page_from": 738, "page_to": 738, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=738", "section_title": "Memory Access", "content": "Test all of the memories in a given block"}
{"type": "text", "page_from": 739, "page_to": 739, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=739", "section_title": "Memory Walking-Ones Test Sequences", "header_path": ["27", "7"], "chapter": "27", "section": "27.7", "content": "27.7 Memory Walking-Ones Test Sequences"}
{"type": "text", "page_from": 739, "page_to": 739, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=739", "section_title": "Memory Walk", "content": "This section defines sequences for applying a “walking-ones” algorithm on one or more memories."}
{"type": "text", "page_from": 739, "page_to": 739, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=739", "section_title": "Memory Walk", "content": "Runs the walking-ones algorithm on the memory given by the mem property, which must be assigned prior to starting this sequence."}
{"type": "text", "page_from": 739, "page_to": 739, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=739", "section_title": "Memory Walk", "content": "If bit-type resource named “NO_REG_TESTS”, “NO_MEM_TESTS”, or “NO_MEM_WALK_TEST” in the “REG::” namespace matches the full name of the memory, the memory is not tested."}
{"type": "text", "page_from": 739, "page_to": 739, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=739", "section_title": "Memory Walk", "content": "The walking ones algorithm is performed for each map in which the memory is defined."}
{"type": "text", "page_from": 739, "page_to": 739, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=739", "section_title": "Memory Walk", "content": "uvm_mem_single_walk_seq"}
{"type": "text", "page_from": 739, "page_to": 739, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=739", "section_title": "Memory Walk", "content": "Runs the walking-ones algorithm on the memory given by the mem property, which must be assigned prior to starting this sequence."}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "class uvm_mem_single_walk_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "The memory to test; must be assigned prior to starting sequence."}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "Creates a new instance of the class with the given name. Performs the walking-ones algorithm on each map of the memory specified in mem."}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "The memory to test; must be assigned prior to starting sequence."}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "function new( string name $=$ \"uvm_mem_walk_seq\" )"}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "Creates a new instance of the class with the given name."}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "Performs the walking-ones algorithm on each map of the memory specified in mem."}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "Verifies the all memories in a block by executing the uvm_mem_single_walk_seq sequence on every memory within it."}
{"type": "text", "page_from": 740, "page_to": 740, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=740", "section_title": "Memory Walk", "content": "If bit-type resource named “NO_REG_TESTS”, “NO_MEM_TESTS”, or “NO_MEM_WALK_TEST” in the “REG::” namespace matches the full name of the block, the block is not tested."}
{"type": "text", "page_from": 741, "page_to": 741, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=741", "section_title": "Memory Walk", "content": "Verifies the all memories in a block by executing the uvm_mem_single_walk_seq sequence on every memory within it."}
{"type": "text", "page_from": 741, "page_to": 741, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=741", "section_title": "Memory Walk", "content": "class uvm_mem_walk_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item)"}
{"type": "text", "page_from": 741, "page_to": 741, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=741", "section_title": "Memory Walk", "content": "model The block to be tested. mem_seq The sequence used to test one memory"}
{"type": "text", "page_from": 741, "page_to": 741, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=741", "section_title": "Memory Walk", "content": "body Executes the mem walk sequence, one block at a time. do_block Test all of the memories in a given block reset_blk Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 741, "page_to": 741, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=741", "section_title": "Memory Walk", "content": "The block to be tested. Declared in the base class."}
{"type": "text", "page_from": 741, "page_to": 741, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=741", "section_title": "Memory Walk", "content": "protected uvm_mem_single_walk_seq mem_seq"}
{"type": "text", "page_from": 741, "page_to": 741, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=741", "section_title": "Memory Walk", "content": "The sequence used to test one memory"}
{"type": "text", "page_from": 742, "page_to": 742, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=742", "section_title": "Memory Walk", "content": "Executes the mem walk sequence, one block at a time. Do not call directly. Use seq.start() instead."}
{"type": "text", "page_from": 742, "page_to": 742, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=742", "section_title": "Memory Walk", "content": "Test all of the memories in a given block"}
{"type": "text", "page_from": 742, "page_to": 742, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=742", "section_title": "Memory Walk", "content": "Reset the DUT that corresponds to the specified block abstraction class."}
{"type": "text", "page_from": 742, "page_to": 742, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=742", "section_title": "Memory Walk", "content": "Currently empty. Will rollback the environment’s phase to the reset phase once the new phasing is available."}
{"type": "text", "page_from": 742, "page_to": 742, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=742", "section_title": "Memory Walk", "content": "In the meantime, the DUT should be reset before executing this test sequence or this method should be implemented in an extension to reset the DUT."}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking Test Sequence", "header_path": ["27", "8"], "chapter": "27", "section": "27.8", "content": "27.8 HDL Paths Checking Test Sequence"}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "HDL Paths Checking Test Sequence"}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "uvm_reg_mem_hdl_paths_seq"}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "Verify the correctness of HDL paths specified for registers and memories."}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "This sequence is be used to check that the specified backdoor paths are indeed accessible by the simulator. By default, the check is performed for the default design abstraction. If the simulation contains multiple models of the DUT, HDL paths for multiple design abstractions can be checked."}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "If a path is not accessible by the simulator, it cannot be used for read/write backdoor accesses. In that case a warning is produced. A simulator may have finer-grained access permissions such as separate read or write permissions. These extra access permissions are NOT checked."}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "The test is performed in zero time and does not require any reads/writes to/from the DUT."}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "uvm_reg_mem_hdl_paths_seq"}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "Verify the correctness of HDL paths specified for registers and memories."}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "Cl Ass DEcl ARAt ION"}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "class uvm_reg_mem_hdl_paths_seq extends uvm_reg_sequence #( uvm_sequence #(uvm_reg_item) )"}
{"type": "text", "page_from": 743, "page_to": 743, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=743", "section_title": "HDL Paths Checking", "content": "abstractions If set, check the HDL paths for the specified design abstractions."}
{"type": "text", "page_from": 745, "page_to": 745, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=745", "section_title": "Command Line Processor Class", "header_path": ["28", "1"], "chapter": "28", "section": "28.1", "content": "28.1 Command Line Processor Class"}
{"type": "text", "page_from": 745, "page_to": 745, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=745", "section_title": "CLP Overview", "content": "This class provides a general interface to the command line arguments that were provided for the given simulation. Users can retrieve the complete arguments using methods such as get_args() and get_arg_matches() but also retrieve the suffixes of arguments using get_arg_values()."}
{"type": "text", "page_from": 745, "page_to": 745, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=745", "section_title": "CLP Overview", "content": "The uvm_cmdline_processor class also provides support for setting various UVM variables from the command line such as components’ verbosities and configuration settings for integral types and strings. Command line arguments that are in uppercase should only have one setting to invocation. Command line arguments that in lowercase can have multiple settings per invocation."}
{"type": "text", "page_from": 745, "page_to": 745, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=745", "section_title": "CLP Overview", "content": "All of these capabilities are described in the uvm_cmdline_processor section."}
{"type": "text", "page_from": 745, "page_to": 745, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=745", "section_title": "CLP Overview", "content": "Command Line Processor Class"}
{"type": "text", "page_from": 745, "page_to": 745, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=745", "section_title": "CLP Overview", "content": "This class provides a general interface to the command line arguments that were provided for the given simulation."}
{"type": "text", "page_from": 746, "page_to": 746, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=746", "section_title": "uvm_cmdline_processor", "header_path": ["28", "2"], "chapter": "28", "section": "28.2", "content": "28.2 uvm_cmdline_processor"}
{"type": "text", "page_from": 746, "page_to": 746, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=746", "section_title": "uvm_cmdline_processor", "content": "This class provides an interface to the command line arguments that were provided for the given simulation. The class is intended to be used as a singleton, but that isn’t required. The generation of the data structures which hold the command line argument information happens during construction of the class object. A global variable called uvm_cmdline_proc is created at initialization time and may be used to access command line information."}
{"type": "text", "page_from": 746, "page_to": 746, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=746", "section_title": "uvm_cmdline_processor", "content": "The uvm_cmdline_processor class also provides support for setting various UVM variables from the command line such as components’ verbosities and configuration settings for integral types and strings. Each of these capabilities is described in the Built-in UVM Aware Command Line Arguments section."}
{"type": "text", "page_from": 746, "page_to": 746, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=746", "section_title": "uvm_cmdline_processor", "content": "uvm_cmdline_processor"}
{"type": "text", "page_from": 746, "page_to": 746, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=746", "section_title": "uvm_cmdline_processor", "content": "This class provides an interface to the command line arguments that were provided for the given simulation."}
{"type": "text", "page_from": 746, "page_to": 746, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=746", "section_title": "uvm_cmdline_processor", "content": "class uvm_cmdline_processor extends uvm_report_object"}
{"type": "text", "page_from": 747, "page_to": 747, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=747", "section_title": "uvm_cmdline_processor", "content": "static function uvm_cmdline_processor get_inst()"}
{"type": "text", "page_from": 747, "page_to": 747, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=747", "section_title": "uvm_cmdline_processor", "content": "Returns the singleton instance of the UVM command line processor."}
{"type": "text", "page_from": 748, "page_to": 748, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=748", "section_title": "uvm_cmdline_processor", "content": "This function returns a queue with all of the plus arguments that were used to start the simulation. Plusarguments may be used by the simulator vendor, or may be specific to a company or individual user. Plusargs never have extra arguments (i.e. if there is a plusarg as the second argument on the command line, the third argument is unrelated); this is not necessarily the case with vendor specific dash arguments."}
{"type": "text", "page_from": 748, "page_to": 748, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=748", "section_title": "uvm_cmdline_processor", "content": "This function returns a queue with all of the uvm arguments that were used to start the simulation. A UVM argument is taken to be any argument that starts with a - or $^ +$ and uses the keyword UVM (case insensitive) as the first three letters of the argument."}
{"type": "text", "page_from": 748, "page_to": 748, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=748", "section_title": "uvm_cmdline_processor", "content": "function int get_arg_matches string match, ref string args[\\$] )"}
{"type": "text", "page_from": 748, "page_to": 748, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=748", "section_title": "uvm_cmdline_processor", "content": "This function loads a queue with all of the arguments that match the input expression and returns the number of items that matched. If the input expression is bracketed with //, then it is taken as an extended regular expression otherwise, it is taken as the beginning of an argument to match. For example:"}
{"type": "text", "page_from": 748, "page_to": 748, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=748", "section_title": "uvm_cmdline_processor", "content": "function int get_arg_value ( string match, ref string value )"}
{"type": "text", "page_from": 748, "page_to": 748, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=748", "section_title": "uvm_cmdline_processor", "content": "This function finds the first argument which matches the match arg and returns the suffix of the argument. This is similar to the $\\$ 1$ value\\$plusargs system task, but does not take a formatting string. The return value is the number of command line arguments that match the match string, and value is the value of the first match."}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "function int get_arg_values ( string match, ref string values[\\$] )"}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "This function finds all the arguments which matches the match arg and returns the suffix of the arguments in a list of values. The return value is the number of matches that were found (it is the same as values.size() ). For example if $\\therefore f o o = 1$ ,yes,on $+ \\mathsf { f o o } = 5$ ,no,off’ was provided on the command line and the following code was executed:"}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "string foo_values[\\$] initial begin void'(uvm_cmdline_proc.get_arg_values(\"+foo $=$ \",foo_values));"}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "The foo_values queue would contain two entries. These entries are shown here:"}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "”1,yes,on” 1 ”5,no,off”", "header_path": ["0"], "chapter": "0", "content": "0 ”1,yes,on” 1 ”5,no,off”"}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "Splitting the resultant string is left to user but using the uvm_split_string() function is recommended."}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "function string get_tool_name ()"}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "Returns the simulation tool that is executing the simulation. This is a vendor specific string."}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "function string get_tool_version ()"}
{"type": "text", "page_from": 749, "page_to": 749, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=749", "section_title": "uvm_cmdline_processor", "content": "Returns the version of the simulation tool that is executing the simulation. This is a vendor specific string."}
{"type": "text", "page_from": 750, "page_to": 750, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=750", "section_title": "uvm_cmdline_processor", "content": "+UVM_TESTNAME $\\dot { } = \\mathbf { \\square }$ <class name> allows the user to specify which uvm_test (or uvm_component) should be created via the factory and cycled through the UVM phases. If multiple of these settings are provided, the first occurrence is used and a warning is issued for subsequent settings. For example:"}
{"type": "text", "page_from": 750, "page_to": 750, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=750", "section_title": "uvm_cmdline_processor", "content": "+UVM_VERBOSITY $\\succeq$ <verbosity> allows the user to specify the initial verbosity for all components. If multiple of these settings are provided, the first occurrence is used and a warning is issued for subsequent settings. For example:"}
{"type": "text", "page_from": 750, "page_to": 750, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=750", "section_title": "uvm_cmdline_processor", "content": "+uvm_set_verbosit $\\gamma = < c o m p > , < i d > , < v e r b o s i t y > , < p h a s e > $ and +uvm_set_verbosity $\\underline { { \\cdot } } =$ <comp>,<id>,<verbosity $\\mathbf { \\bar { \\rho } } >$ ,time,<time> allow the users to manipulate the verbosity of specific components at specific phases (and times during the “run” phases) of the simulation. The id argument can be either ALL for all IDs or a specific message id. Wildcarding is not supported for id due to performance concerns. Settings for non-”run” phases are executed in order of occurrence on the command line. Settings for “run” phases (times) are sorted by time and then executed in order of occurrence for settings of the same time. For example:"}
{"type": "text", "page_from": 750, "page_to": 750, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=750", "section_title": "uvm_cmdline_processor", "content": "+uvm_set_action $=$ <comp>,<id>,<severity>,<action $>$ provides the equivalent of various uvm_report_object’s set_report_\\*_action APIs. The special keyword, $\\Delta L L ,$ can be provided for both/either the id and/or severity arguments. The action can be UVM_NO_ACTION or a | separated list of the other UVM message actions. For example:"}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "special keyword, $\\Delta L L ,$ can be provided for both/either the id and/or current severity arguments. For example:"}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_TIMEOUT $\\succeq$ <timeout>,<overridable $>$ allows users to change the global timeout of the UVM framework. The $<$ <overridable $>$ argument (‘YES’ or $\\mathsf { N O ^ { \\prime } }$ ) specifies whether user code can subsequently change this value. If set to $\\because N O ^ { \\prime }$ and the user code tries to change the global timeout value, a warning message will be generated."}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_MA X_QUIT _COUNT"}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_MAX_QUIT_COUNT $\\mathbf { \\bar { \\alpha } } _ { = }$ <count>,<overridable $>$ allows users to change max quit count for the report server. The $<$ <overridable> argument (‘YES’ or $\\mathsf { N O ^ { \\prime } } )$ specifies whether user code can subsequently change this value. If set to $\\because N O ^ { \\prime }$ and the user code tries to change the max quit count value, a warning message will be generated."}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_PHASE_TRACE turns on tracing of phase executions. Users simply need to put the argument on the command line."}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_OBJECTION _TRA CE"}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_OBJECTION_TRACE turns on tracing of objection activity. Users simply need to put the argument on the command line."}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_RE SOUR CE_DB_TRA CE"}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_RESOURCE_DB_TRACE turns on tracing of resource DB access. Users simply need to put the argument on the command line."}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_CONFIG _DB_TRA CE"}
{"type": "text", "page_from": 751, "page_to": 751, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=751", "section_title": "uvm_cmdline_processor", "content": "+UVM_CONFIG_DB_TRACE turns on tracing of configuration DB access. Users simply need to put the argument on the command line."}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "+uvm_set_type_override"}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "+uvm_set_inst_override $=$ <req_type>,<override_type>, $<$ full_inst_path $>$ and +uvm_set_type_override $=$ <req_type>,<override_type>[,<replace>] work like the name based overrides in the factory--factory.set_inst_override_by_name() and factory.set_type_override_by_name(). For uvm_set_type_override, the third argument is 0 or 1 (the default is 1 if this argument is left off); this argument specifies whether previous type overrides for the type should be replaced. For example:"}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "+uvm_set_config_string"}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "+uvm_set_config_ $i n t { = } < c o m p { > } , < f i e I d { > } , < v a I u e { > }$ and $+ u v m \\_ s e t \\_ c o n f i g \\_ s t r i n g = < c o m p > , < f i e I d > , < v a l u e >$ > work like their procedural counterparts: set_config_int() and set_config_string(). For the value of int config settings, $\\boldsymbol { \\cdot } _ { \\mathrm { b } }$ (0b), $\\setminus ,$ ‘d, $\\boldsymbol { \\cdot } _ { \\mathrm { h } }$ (cd:) $\\ \" x$ or $0 \\times$ ) as the first two characters of the value are treated as base specifiers for interpreting the base of the number. Size specifiers are not used since SystemVerilog does not allow size specifiers in string to value conversions. For example:"}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "No equivalent of set_config_object() exists since no way exists to pass a uvm_object into the simulation via the command line."}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "+uvm_set_default_sequence"}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "The +uvm_set_default_sequence $=$ <seqr>,<phase>,<type> plusarg allows the user to define a default sequence from the command line, using the typename of that sequence. For example:"}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "This is functionally equivalent to calling the following in your test:"}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "uvm_coreservice_t cs $=$ uvm_coreservice_t::get(); uvm_factory f $= ^ { - }$ cs.get_factory(); uvm_config_db#(uvm_object_wrapper)::set(this, \"path.to.sequencer.main_phase\", \"default_sequence\","}
{"type": "text", "page_from": 752, "page_to": 752, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=752", "section_title": "uvm_cmdline_processor", "content": "f.find_wrapper_by_name(\"seq_type\"));"}
{"type": "text", "page_from": 753, "page_to": 753, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=753", "section_title": "Globals", "content": "29. Global Functionality"}
{"type": "text", "page_from": 753, "page_to": 753, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=753", "section_title": "Globals", "content": "UVM provides other functionality at the package scope including methods, enums, defines, and classes. Some of these are targeted towards specific aspects of the functionality described in the UVM standard, and others are useful across multiple aspects."}
{"type": "text", "page_from": 753, "page_to": 753, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=753", "section_title": "Globals", "content": "Global Functionality"}
{"type": "text", "page_from": 753, "page_to": 753, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=753", "section_title": "Globals", "content": "UVM provides other functionality at the package scope including methods, enums, defines, and classes."}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "\\`UVM_MA X_STREAMBI TS"}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "Defines the maximum bit vector size for integral types."}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "\\`UVM_PAC KER_MA X_BY TES"}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "Defines the maximum bytes to allocate for packing an object using the uvm_packer. Default is \\`UVM_MAX_STREAMBITS, in bytes."}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "\\`UVM_DEFAUL T_TIM EOU T"}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "The default timeout for simulation, if not overridden by uvm_root::set_timeout or uvm_cmdline_processor::+UVM_TIMEOUT"}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "The bitstream type is used as an argument type for passing integral values in such methods as uvm_object::set_int_local, uvm_config_int, uvm_printer::print_field, uvm_recorder::record_field, uvm_packer::pack_field and uvm_packer::unpack_field."}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "The integral type is used as an argument type for passing integral values of 64 bits or less in such methods as uvm_printer::print_field_int, uvm_recorder::record_field_int, uvm_packer::pack_field_int and uvm_packer::unpack_field_int."}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "Specifies the radix to print or record in."}
{"type": "text", "page_from": 755, "page_to": 755, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=755", "section_title": "Types and Enumerations", "content": "UVM_BIN Selects binary $( \\% \\mathsf { b } )$ format UVM_DEC Selects decimal $( \\% { } )$ format UVM_UNSIGNED Selects unsigned decimal $( \\% { \\mathfrak { u } } )$ format UVM_UNFORMAT2 Selects unformatted 2 value data $( \\% \\mu )$ format"}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "UVM_UNFORMAT4 Selects unformatted 4 value data $( \\% z )$ format UVM_OCT Selects octal $( \\% 0 )$ format UVM_HEX Selects hexadecimal $( \\% \\hphantom { . 0 0 0 } )$ format UVM_STRING Selects string $( \\% s )$ format UVM_TIME Selects time $( \\% t )$ format UVM_ENUM Selects enumeration value (name) format UVM_REAL Selects real $( \\% 9 )$ in exponential or decimal format, whichever format results in the shorter printed output UVM_REAL_DEC Selects real $( \\% \\mathsf { f } )$ in decimal format UVM_REAL_EXP Selects real $( \\% 0 \\% )$ in exponential format"}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "uvm_recursion_policy_enum"}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "Specifies the policy for copying objects."}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "UVM_DEEP Objects are deep copied (object must implement uvm_object::copy method) UVM_SHALLOW Objects are shallow copied using default SV copy. UVM_REFERENCE Only object handles are copied."}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "uvm_active_passive_enum"}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "Convenience value to define whether a component, usually an agent, is in “active” mode or “passive” mode."}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "UVM_PASSIVE ”Passive” mode UVM_ACTIVE ”Active” mode"}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "\\`uvm_field_\\* macro flags"}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "Defines what operations a given field should be involved in. Bitwise OR all that apply."}
{"type": "text", "page_from": 756, "page_to": 756, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=756", "section_title": "Types and Enumerations", "content": "UVM_DEFAULT All field operations turned on UVM_COPY Field will participate in uvm_object::copy UVM_COMPARE Field will participate in uvm_object::compare UVM_PRINT Field will participate in uvm_object::print UVM_RECORD Field will participate in uvm_object::record UVM_PACK Field will participate in uvm_object::pack UVM_NOCOPY Field will not participate in uvm_object::copy UVM_NOCOMPARE Field will not participate in uvm_object::compare UVM_NOPRINT Field will not participate in uvm_object::print UVM_NORECORD Field will not participate in uvm_object::record UVM_NOPACK Field will not participate in uvm_object::pack UVM_DEEP Object field will be deep copied UVM_SHALLOW Object field will be shallow copied UVM_REFERENCE Object field will copied by reference"}
{"type": "text", "page_from": 757, "page_to": 757, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=757", "section_title": "Types and Enumerations", "content": "Defines all possible values for report severity."}
{"type": "text", "page_from": 757, "page_to": 757, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=757", "section_title": "Types and Enumerations", "content": "UVM_INFO Informative message. UVM_WARNING Indicates a potential problem. UVM_ERROR Indicates a real problem. Simulation continues subject to the configured message action. UVM_FATAL Indicates a problem from which simulation cannot recover. Simulation exits via $\\$ 1$ finish after a #0 delay."}
{"type": "text", "page_from": 757, "page_to": 757, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=757", "section_title": "Types and Enumerations", "content": "Defines all possible values for report actions. Each report is configured to execute one or more actions, determined by the bitwise OR of any or all of the following enumeration constants."}
{"type": "text", "page_from": 757, "page_to": 757, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=757", "section_title": "Types and Enumerations", "content": "UVM_NO_ACTION No action is taken UVM_DISPLAY Sends the report to the standard output UVM_LOG Sends the report to the file(s) for this (severity,id) pair UVM_COUNT Counts the number of reports with the COUNT attribute. When this value reaches max_quit_count, the simulation terminates UVM_EXIT Terminates the simulation immediately. UVM_CALL_HOOK Callback the report hook methods UVM_STOP Causes \\$stop to be executed, putting the simulation into interactive mode. UVM_RM_RECORD Sends the report to the recorder"}
{"type": "text", "page_from": 757, "page_to": 757, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=757", "section_title": "Types and Enumerations", "content": "Defines standard verbosity levels for reports."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Specifies the type of port UVM_PORT"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The port requires the interface that is its type parameter."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The port provides the interface that is its type parameter via a connection to some other export or implementation."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The port provides the interface that is its type parameter, and it is bound to the component that implements the interface."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "uvm_sequencer_arb_mode"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Specifies a sequencer’s arbitration mode"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Requests are granted in FIFO order (default)"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Requests are granted randomly by weight"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "UVM_SEQ_ARB_WEIGHTED UVM_SEQ_ARB_RANDOM UVM_SEQ_ARB_STRICT_FIFO"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Requests are granted randomly"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Requests at highest priority granted in fifo order"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "UVM_SEQ_ARB_STRICT_RANDOM"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Requests at highest priority granted in randomly"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Arbitration is delegated to the user-defined function, user_priority_arbitration. That function will specify the next sequence to grant."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "uvm_sequence_state_enum"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "Defines current sequence state"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "UVM_CREATED UVM_PRE_START"}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The sequence has been allocated."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The sequence is started and the uvm_sequence_base::pre_start() task is being executed."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The sequence is started and the uvm_sequence_base::pre_body() task is being executed."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The sequence is started and the uvm_sequence_base::body() task is being executed."}
{"type": "text", "page_from": 758, "page_to": 758, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=758", "section_title": "Types and Enumerations", "content": "The sequence has completed the execution of the uvm_sequence_base::body() task."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "The sequence is started and the uvm_sequence_base::post_body() task is being executed."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "The sequence is started and the uvm_sequence_base::post_start() task is being executed."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "The sequence has been forcibly ended by issuing a uvm_sequence_base::kill() on the sequence."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "The sequence is completely finished executing."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "uvm_sequence_lib_mode"}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "Specifies the random selection mode of a sequence library"}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "UVM_SEQ_LIB_RAND UVM_SEQ_LIB_RANDC UVM_SEQ_LIB_ITEM UVM_SEQ_LIB_USER"}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "Random sequence selection Random cyclic sequence selection Emit only items, no sequence execution Apply a user-defined random-selection algorithm"}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "This is an attribute of a uvm_phase object which defines the phase type."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "The phase object is used to traverse the component hierarchy and call the component phase method as well as the phase_started and phase_ended callbacks. These nodes are created by the phase macros, \\`uvm_builtin_task_phase, \\`uvm_builtin_topdown_phase, and \\`uvm_builtin_bottomup_phase. These nodes represent the phase type, i.e. uvm_run_phase, uvm_main_phase."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "The object represents a simple node instance in the graph. These nodes will contain a reference to their corresponding IMP object."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "The object represents a portion of the phasing graph, typically consisting of several NODE types, in series, parallel, or both."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "This internal object serves as the termination NODE for a SCHEDULE phase object."}
{"type": "text", "page_from": 759, "page_to": 759, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=759", "section_title": "Types and Enumerations", "content": "This object represents an entire graph segment that executes in parallel with the ‘run’ phase. Domains may define any network of NODEs and SCHEDULEs. The built-in domain, uvm, consists of a single schedule of all the run-time phases, starting with pre_reset and ending with post_shutdown."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "The set of possible states of a phase. This is an attribute of a schedule node in the graph, not of a phase, to maintain independent per-domain state"}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "UVM_PHASE_UNINITIALIZED"}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "The state is uninitialized. This is the default state for phases, and for nodes which have not yet been added to a schedule."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "The schedule is not currently operating on the phase node, however it will be scheduled at some point in the future."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "At least one immediate predecessor has completed. Scheduled phases block until all predecessors complete or until a jump is executed."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "All predecessors complete, checking that all synced phases (e.g. across domains) are at or beyond this point"}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "UVM_PHASE_STARTED phase ready to execute, running phase_started() callback"}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "An executing phase is one where the phase callbacks are being executed. Its process is tracked by the phaser."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "UVM_PHASE_READY_TO_END no objections remain in this phase or in any predecessors of its successors or in any sync’d phases. This state indicates an opportunity for any phase that needs extra time for a clean exit to raise an objection, thereby causing a return to UVM_PHASE_EXECUTING. If no objection is raised, state will transition to UVM_PHASE_ENDED after a delta cycle. (An example of predecessors of successors: The successor to phase ‘run’ is ‘extract’, whose predecessors are ‘run’ and ‘post_shutdown’. Therefore, ‘run’ will go to this state when both its objections and those of ‘post_shutdown’ are all dropped."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "UVM_PHASE_ENDED phase completed execution, now running phase_ended() callback"}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "all processes related to phase are being killed and all predecessors are forced into the DONE state."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "UVM_PHASE_CLEANUPUVM_PHASE_DONE"}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "all processes related to phase are being killed"}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "A phase is done after it terminated execution. Becoming done may enable a waiting successor phase to execute."}
{"type": "text", "page_from": 760, "page_to": 760, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=760", "section_title": "Types and Enumerations", "content": "The state transitions occur as follows"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "Specifies the operand when using methods like uvm_phase::wait_for_state."}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "UVM_EQ equal UVM_NE not equal UVM_LT less than UVM_LTE less than or equal to UVM_GT greater than UVM_GTE greater than or equal to"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "Enumerated the possible objection events one could wait on. See uvm_objection::wait_for."}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "UVM_RAISED an objection was raised UVM_DROPPED an objection was raised UVM_ALL_DROPPED all objections have been dropped"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "Def AULt POLICY CLAsses"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "Policy classes copying, comparing, packing, unpacking, and recording uvm_object-based objects."}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "uvm_default_table_printer"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "uvm_table_printer uvm_default_table_printer $=$ new()"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "The table printer is a global object that can be used with uvm_object::do_print to get tabular style printing."}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "uvm_default_tree_printer"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "uvm_tree_printer uvm_default_tree_printer $=$ new()"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "The tree printer is a global object that can be used with uvm_object::do_print to get multi-line tree style printing."}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "uvm_default_line_printer"}
{"type": "text", "page_from": 761, "page_to": 761, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=761", "section_title": "Types and Enumerations", "content": "uvm_line_printer uvm_default_line_printer $=$ new()"}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "The line printer is a global object that can be used with uvm_object::do_print to get single-line style printing."}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "The default printer policy. Used when calls to uvm_object::print or uvm_object::sprint do not specify a printer policy."}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "The default printer may be set to any legal uvm_printer derived type, including the global line, tree, and table printers described above."}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "uvm_packer uvm_default_packer $=$ new()"}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "The default packer policy. Used when calls to uvm_object::pack and uvm_object::unpack do not specify a packer policy."}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "uvm_default_comparer"}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "uvm_comparer uvm_default_comparer $=$ new()"}
{"type": "text", "page_from": 762, "page_to": 762, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=762", "section_title": "Types and Enumerations", "content": "The default compare policy. Used when calls to uvm_object::compare do not specify a comparer policy."}
{"type": "text", "page_from": 763, "page_to": 763, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=763", "section_title": "Globals", "content": "task run_test ( string test_name )"}
{"type": "text", "page_from": 763, "page_to": 763, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=763", "section_title": "Globals", "content": "Convenience function for uvm_top.run_test(). See uvm_root for more information."}
{"type": "text", "page_from": 764, "page_to": 764, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=764", "section_title": "Globals", "content": "uvm_get_report_object"}
{"type": "text", "page_from": 764, "page_to": 764, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=764", "section_title": "Globals", "content": "function uvm_report_object uvm_get_report_object()"}
{"type": "text", "page_from": 764, "page_to": 764, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=764", "section_title": "Globals", "content": "Returns the nearest uvm_report_object when called. For the global version, it returns uvm_root."}
{"type": "text", "page_from": 764, "page_to": 764, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=764", "section_title": "Globals", "content": "Returns 1 if the configured verbosity in uvm_top for this severity/id is greater than or equal to verbosity else returns 0."}
{"type": "text", "page_from": 764, "page_to": 764, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=764", "section_title": "Globals", "content": "See also uvm_report_object::uvm_report_enabled."}
{"type": "text", "page_from": 764, "page_to": 764, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=764", "section_title": "Globals", "content": "Static methods of an extension of uvm_report_object, e.g. uvm_component-based objects, cannot call uvm_report_enabled because the call will resolve to the uvm_report_object::uvm_report_enabled, which is non-static. Static methods cannot call non-static methods of the same class."}
{"type": "text", "page_from": 764, "page_to": 764, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=764", "section_title": "Globals", "content": "function void uvm_report_warning( string id,"}
{"type": "text", "page_from": 765, "page_to": 765, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=765", "section_title": "Globals", "content": "function void uvm_report_fatal( string id, string message, int verbosity UVM_NONE, string filename \"\",0, string context_name bit report_enabled_checked = 0 )"}
{"type": "text", "page_from": 765, "page_to": 765, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=765", "section_title": "Globals", "content": "These methods, defined in package scope, are convenience functions that delegate to the corresponding component methods in uvm_top. They can be used in module-based code to use the same reporting mechanism as class-based components. See uvm_report_object for details on the reporting mechanism."}
{"type": "text", "page_from": 765, "page_to": 765, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=765", "section_title": "Globals", "content": "Note: Verbosity is ignored for warnings, errors, and fatals to ensure users do not inadvertently filter them out. It remains in the methods for backward compatibility."}
{"type": "text", "page_from": 765, "page_to": 765, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=765", "section_title": "Globals", "content": "uvm_process_report_message"}
{"type": "text", "page_from": 765, "page_to": 765, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=765", "section_title": "Globals", "content": "function void uvm_process_report_message( uvm_report_message report_message"}
{"type": "text", "page_from": 765, "page_to": 765, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=765", "section_title": "Globals", "content": "This method, defined in package scope, is a convenience function that delegate to the corresponding component method in uvm_top. It can be used in module-based code to use the same reporting mechanism as class-based components. See uvm_report_object for details on the reporting mechanism."}
{"type": "text", "page_from": 765, "page_to": 765, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=765", "section_title": "Globals", "content": "function bit uvm_is_match ( string expr, string str"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "Returns 1 if the two strings match, 0 otherwise."}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "The first string, expr, is a string that may contain $\\mathbf { \\omega } \\cdot \\mathbf { \\gamma } _ { \\ast } ,$ and $\\because 1$ characters. $\\mathsf { A } ^ { \\mathrm { ~ * ~ } }$ matches zero or more characters, and ? matches any single character. The 2nd argument, str, is the string begin matched against. It must not contain any wildcards."}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "function logic[UVM_LARGE_STRING:0] uvm_string_to_bits( string str"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "Converts an input string to its bit-vector equivalent. Max bit-vector length is approximately 14000 characters."}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "function string uvm_bits_to_string( logic [UVM_LARGE_STRING:0] str"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "Converts an input bit-vector to its string equivalent. Max bit-vector length is approximately 14000 characters."}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "uvm_wait_for_nba_region"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "task uvm_wait_for_nba_region"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "Callers of this task will not return until the NBA region, thus allowing other processes any number of delta cycles (#0) to settle out before continuing. See uvm_sequencer_base::wait_for_sequences for example usage."}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "function automatic void uvm_split_string ( string str, byte sep, ref string values[\\$] )"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "Returns a queue of strings, values, that is the result of the str split based on the sep. For example:"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "uvm_split_string(\"1,on,false\", \",\", splits);"}
{"type": "text", "page_from": 766, "page_to": 766, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=766", "section_title": "Globals", "content": "Results in the ‘splits’ queue containing the three elements: 1, on and false."}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "The uvm_enum_wrapper# $( T )$ class is a utility mechanism provided as a convenience to the end user. It provides a from_name method which is the logical inverse of the SystemVerilog name method which is built into all enumerations."}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "uvm_enum_wrapper#(T)"}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "The uvm_enum_wrapper# $( T )$ class is a utility mechanism provided as a convenience to the end user."}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "class uvm_enum_wrapper#( type T $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ uvm_active_passive_enum"}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "from_name Attempts to convert a string name to an enumerated value."}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "static function bit from_name( string name, ref T value )"}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "Attempts to convert a string name to an enumerated value."}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "If the conversion is successful, the method will return 1, otherwise 0."}
{"type": "text", "page_from": 767, "page_to": 767, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=767", "section_title": "Globals", "content": "Note that the name passed in to the method must exactly match the value which would be produced by enum::name, and is case sensitive."}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "uvm_coreservice_t", "header_path": ["29", "3"], "chapter": "29", "section": "29.3", "content": "29.3 uvm_coreservice_t"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "The singleton instance of uvm_coreservice_t provides a common point for all central uvm services such as uvm_factory, uvm_report_server, ... The service class provides a static ::get which returns an instance adhering to uvm_coreservice_t the rest of the set_facility get_facility pairs provide access to the internal uvm services"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "Custom implementations of uvm_coreservice_t can be included in uvm_pkg::\\* and can selected via the define UVM_CORESERVICE_TYPE. They cannot reside in another package."}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "pure virtual function uvm_factory get_factory()"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "intended to return the currently enabled uvm factory,"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "pure virtual function void set_factory( uvm_factory f"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "intended to set the current uvm factory"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "pure virtual function uvm_report_server get_report_server()"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "intended to return the current global report_server"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "pure virtual function void set_report_server( uvm_report_server server"}
{"type": "text", "page_from": 768, "page_to": 768, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=768", "section_title": "Core Service", "content": "intended to set the central report server to server"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "pure virtual function uvm_tr_database get_default_tr_database()"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "intended to return the current default record database"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "set_default_tr_database"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "pure virtual function void set_default_tr_database( uvm_tr_database db"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "intended to set the current default record database to db"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "set_component_visitor"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "pure virtual function void set_component_visitor( uvm_visitor#(uvm_component) v"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "intended to set the component visitor to $v$ (this visitor is being used for the traversal at end_of_elaboration_phase for instance for name checking)"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "get_component_visitor"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "pure virtual function uvm_visitor#( uvm_component get_component_visitor()"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "intended to retrieve the current component visitor see set_component_visitor"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "pure virtual function uvm_root get_root()"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "returns the uvm_root instance"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "static function uvm_coreservice_t get()"}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "Returns an instance providing the uvm_coreservice_t interface. The actual type of the instance is determined by the define \\`UVM_CORESERVICE_TYPE."}
{"type": "text", "page_from": 769, "page_to": 769, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=769", "section_title": "Core Service", "content": "\\`define UVM_CORESERVICE_TYPE uvm_blocking_coreservice class uvm_blocking_coreservice extends uvm_default_coreservice_t; virtual function void set_factory(uvm_factory f); \\`uvm_error(\"FACTORY\",\"you are not allowed to override the factory\") endfunction endclass"}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "uvm_default_coreservice_t provides a default implementation of the uvm_coreservice_t API. It instantiates uvm_default_factory, uvm_default_report_server, uvm_root."}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "uvm_default_coreservice_t"}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "uvm_default_coreservice_t provides a default implementation of the uvm_coreservice_t API."}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "class uvm_default_coreservice_t extends uvm_coreservice_t"}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "virtual function uvm_factory get_factory()"}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "Returns the currently enabled uvm factory. When no factory has been set before, instantiates a uvm_default_factory"}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "virtual function void set_factory( uvm_factory f"}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "Sets the current uvm factory. Please note: it is up to the user to preserve the contents"}
{"type": "text", "page_from": 770, "page_to": 770, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=770", "section_title": "Core Service", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "of the original factory or delegate calls to the original factory"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "get_default_tr_database"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "virtual function uvm_tr_database get_default_tr_database()"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "returns the current default record database"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "If no default record database has been set before this method is called, returns an instance of uvm_text_tr_database"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "set_default_tr_database"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "virtual function void set_default_tr_database( uvm_tr_database db"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "Sets the current default record database to db"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "virtual function uvm_report_server get_report_server()"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "returns the current global report_server if no report server has been set before, returns an instance of uvm_default_report_server"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "virtual function void set_report_server( uvm_report_server server"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "sets the central report server to server"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "set_component_visitor"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "virtual function void set_component_visitor( uvm_visitor#(uvm_component) v"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "sets the component visitor to $v$ (this visitor is being used for the traversal at end_of_elaboration_phase for instance for name checking)"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "get_component_visitor"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "virtual function uvm_visitor#( uvm_component ) get_component_visitor()"}
{"type": "text", "page_from": 771, "page_to": 771, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=771", "section_title": "Core Service", "content": "retrieves the current component visitor if unset(or null) returns a uvm_component_name_check_visitor instance"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "uvm_visitor #(NODE)", "header_path": ["29", "4"], "chapter": "29", "section": "29.4", "content": "29.4 uvm_visitor #(NODE)"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "Traversal", "content": "The uvm_visitor class provides an abstract base class for a visitor. The visitor visits instances of type NODE. For general information regarding the visitor pattern see http://en.wikipedia.org/wiki/Visitor_pattern"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "Traversal", "content": "virtual function void begin_v()"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "Traversal", "content": "This method will be invoked by the visitor before the first NODE is visited"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "Traversal", "content": "virtual function void end_v()"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "Traversal", "content": "This method will be invoked by the visitor after the last NODE is visited"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "Traversal", "content": "pure virtual function void visit( NODE node"}
{"type": "text", "page_from": 772, "page_to": 772, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=772", "section_title": "Traversal", "content": "UVM 1.2 Class Reference"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "This method will be invoked by the visitor for every visited node of the provided structure. The user is expected to provide the own functionality in this function."}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "class count_nodes_visitor#(type $\\mathbb { T } =$ uvm_component) extends uvm_visitor#(T); function new (string name $=$ \"\"); super.new(name); endfunction local int cnt; virtual function void begin_v(); cnt $\\qquad = \\quad 0$ ; endfunction virtual function void end_v(); \\`uvm_info(\"TEXT\",\\$sformatf(\"%d elements\",cnt),UVM_NONE) endfunction virtual function void visit(T node); cnt++; endfunction endclass"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "uvm_structure_proxy #(ST RUCTURE)"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "The uvm_structure_proxy is a wrapper and provides a set of elements of the STRUCTURE to the caller on demand. This is to decouple the retrieval of the STRUCTUREs subelements from the actual function being invoked on STRUCTURE"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "uvm_structure_proxy #(ST RUCTURE)"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "The uvm_structure_proxy is a wrapper and provides a set of elements of the STRUCTURE to the caller on demand."}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "get_immediate_children"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "This method will be return in children a set of the direct subelements of s"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "get_immediate_children"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "pure virtual function void get_immediate_children( STRUCTURE s, ref STRUCTURE children[\\$] )"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "This method will be return in children a set of the direct subelements of s"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "uvm_visitor_adapter#(ST RUCTURE,uvm_visitor#(ST RUCTURE))"}
{"type": "text", "page_from": 773, "page_to": 773, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=773", "section_title": "Traversal", "content": "The visitor adaptor traverses all nodes of the STRUCTURE and will invoke visitor.visit() on"}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "uvm_visitor_adapter#(ST RUCTURE,uvm_visitor#(ST RUCTURE))"}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "The visitor adaptor traverses all nodes of the STRUCTURE and will invoke visitor.visit() on every node."}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "Calling this function will traverse through s (and every subnode of s)."}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "pure virtual function void accept( STRUCTURE s, VISITOR v, uvm_structure_proxy#(STRUCTURE) p, bit invoke_begin_end = 1 )"}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "Calling this function will traverse through $s$ (and every subnode of s). For each node found v.visit(node) will be invoked. The children of s are recursively determined by invoking $p$ .get_immediate_children().\\~invoke_begin_end\\~ determines whether the visitors begin/end functions should be invoked prior to traversal."}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "uvm_top_down_visitor_adapter"}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "This uvm_top_down_visitor_adapter traverses the STRUCTURE s (and will invoke the visitor) in a hierarchical fashion. During traversal s will be visited before all subnodes of s will be visited."}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "uvm_top_down_visitor_adapter"}
{"type": "text", "page_from": 774, "page_to": 774, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=774", "section_title": "Traversal", "content": "This uvm_top_down_visitor_adapter traverses the STRUCTURE $s$ (and will invoke the visitor) in a hierarchical fashion."}
{"type": "text", "page_from": 775, "page_to": 775, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=775", "section_title": "Traversal", "content": "This uvm_bottom_up_visitor_adapter traverses the STRUCTURE $s$ (and will invoke the visitor) in a hierarchical fashion. During traversal all children of node $s$ will be visited $s$ will be visited."}
{"type": "text", "page_from": 775, "page_to": 775, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=775", "section_title": "Traversal", "content": "uvm_bottom_up_visitor_adapter"}
{"type": "text", "page_from": 775, "page_to": 775, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=775", "section_title": "Traversal", "content": "This uvm_bottom_up_visitor_adapter traverses the STRUCTURE s (and will invoke the visitor) in a hierarchical fashion."}
{"type": "text", "page_from": 775, "page_to": 775, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=775", "section_title": "Traversal", "content": "This uvm_by_level_visitor_adapter traverses the STRUCTURE s (and will invoke the visitor) in a hierarchical fashion. During traversal will visit all direct children of s before all grand-children are visited."}
{"type": "text", "page_from": 775, "page_to": 775, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=775", "section_title": "Traversal", "content": "uvm_by_level_visitor_adapter"}
{"type": "text", "page_from": 775, "page_to": 775, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=775", "section_title": "Traversal", "content": "This uvm_by_level_visitor_adapter traverses the STRUCTURE s (and will invoke the visitor) in a hierarchical fashion."}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "The class is providing the proxy to extract the direct subcomponents of s"}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "The class is providing the proxy to extract the direct subcomponents of s"}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "class uvm_component_proxy extends uvm_structure_proxy#( uvm_component )"}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "This specialized visitor analyze the naming of the current component. The established rule set ensures that a component.get_full_name() is parsable, unique, printable to order to avoid any ambiguities when messages are being emitted."}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "ruleset a legal name is composed of"}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "allowed charset $^ { \\mathrm { w } } \\mathsf { A } \\mathsf { - } \\mathsf { Z } \\colon \\mathsf { \\_ { 0 } } \\mathsf { - } \\mathsf { 9 } [ ] ( ) \\{ \\mathsf { \\beta } \\} \\cdots ^ { \\mathrm { w } }$ whitespace-as-is, no-balancing delimiter semantic, no escape sequences path delimiter not allowed anywhere in the name"}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "the check is coded here as a function to complete it in a single function call otherwise save/restore issues with the used dpi could occur"}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "uvm_component_name_check_visitor"}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "This specialized visitor analyze the naming of the current component."}
{"type": "text", "page_from": 776, "page_to": 776, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=776", "section_title": "Traversal", "content": "class uvm_component_name_check_visitor extends uvm_visitor#("}
{"type": "text", "page_from": 777, "page_to": 777, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=777", "section_title": "Traversal", "content": "This method should return a regex for what is being considered a valid/good component name."}
{"type": "text", "page_from": 777, "page_to": 777, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=777", "section_title": "Traversal", "content": "virtual function string get_name_constraint()"}
{"type": "text", "page_from": 777, "page_to": 777, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=777", "section_title": "Traversal", "content": "This method should return a regex for what is being considered a valid/good component name. The visitor will check all component names using this regex and report failing names"}
{"type": "text", "page_from": 778, "page_to": 778, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=778", "section_title": "Bibliography", "content": "[B1] IEEE Std $1 6 6 6 ^ { \\mathrm { T M } }$ , IEEE Standard for SystemC Language Reference Manual."}
{"type": "text", "page_from": 778, "page_to": 778, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=778", "section_title": "Bibliography", "content": "[B2] IEEE Std $1 6 8 5 ^ { \\mathrm { T M } }$ , IEEE Standard for IP-XACT, Standard Structure for Packaging, Integrating, and Reusing IP within Tool Flows."}
{"type": "text", "page_from": 779, "page_to": 779, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=779", "section_title": "Everything", "content": "+UVM_CONFIG_DB_TRACE uvm_cmdline_processor"}
{"type": "text", "page_from": 779, "page_to": 779, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=779", "section_title": "Everything", "content": "+UVM_DUMP_CMDLINE_ARGS uvm_cmdline_processor"}
{"type": "text", "page_from": 779, "page_to": 779, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=779", "section_title": "Everything", "content": "+UVM_MAX_QUIT_COUNT uvm_cmdline_processor +UVM_OBJECTION_TRACE uvm_cmdline_processor"}
{"type": "text", "page_from": 779, "page_to": 779, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=779", "section_title": "Everything", "content": "+UVM_PHASE_TRACE uvm_cmdline_processor +UVM_RESOURCE_DB_TRACE uvm_cmdline_processor"}
{"type": "text", "page_from": 779, "page_to": 779, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=779", "section_title": "Everything", "content": "+uvm_set_action uvm_cmdline_processor +uvm_set_config_int uvm_cmdline_processor +uvm_set_config_string uvm_cmdline_processor +uvm_set_default_sequence uvm_cmdline_processor"}
{"type": "text", "page_from": 779, "page_to": 779, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=779", "section_title": "Everything", "content": "+uvm_set_inst_override uvm_cmdline_processor +uvm_set_severity uvm_cmdline_processor +uvm_set_type_override uvm_cmdline_processor +uvm_set_verbosity uvm_cmdline_processor +UVM_TESTNAME uvm_cmdline_processor +UVM_TIMEOUT uvm_cmdline_processor +UVM_VERBOSITY uvm_cmdline_processor \\`uvm_add_to_sequence_library \\`uvm_analysis_imp_decl \\`uvm_blocking_get_imp_decl uvm_blocking_get_peek_imp_decl \\`uvm_blocking_master_imp_decl \\`uvm_blocking_peek_imp_decl \\`uvm_blocking_put_imp_decl \\`uvm_blocking_slave_imp_decl \\`uvm_blocking_transport_imp_decl uvm_component_end"}
{"type": "text", "page_from": 780, "page_to": 780, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=780", "section_title": "Everything", "content": "\\`uvm_component_param_utils \\`uvm_component_param_utils_begin \\`uvm_component_registry \\`uvm_component_utils \\`uvm_component_utils_begin uvm_create \\`uvm_create_on \\`uvm_declare_p_sequencer \\`UVM_DEFAULT_TIMEOUT \\`uvm_do \\`uvm_do_callbacks \\`uvm_do_callbacks_exit_on \\`uvm_do_obj_callbacks \\`uvm_do_obj_callbacks_exit_on \\`uvm_do_on \\`uvm_do_on_pri \\`uvm_do_on_pri_with \\`uvm_do_on_with \\`uvm_do_pri \\`uvm_do_pri_with uvm_do_with \\`uvm_error \\`uvm_error_begin \\`uvm_error_context \\`uvm_error_context_begin uvm_error_context_end \\`uvm_error_end uvm_fatal \\`uvm_fatal_begin uvm_fatal_context \\`uvm_fatal_context_begin \\`uvm_fatal_context_end uvm_fatal_end \\`uvm_field_\\*macro flags \\`uvm_field_\\*macros \\`uvm_field_aa_\\*_int macros \\`uvm_field_aa_\\*_string macros \\`uvm_field_aa_int_byte \\`uvm_field_aa_int_byte_unsigned \\`uvm_field_aa_int_enumkey \\`uvm_field_aa_int_int \\`uvm_field_aa_int_int_unsigned \\`uvm_field_aa_int_integer \\`uvm_field_aa_int_integer_unsigned \\`uvm_field_aa_int_key \\`uvm_field_aa_int_longint \\`uvm_field_aa_int_longint_unsigned \\`uvm_field_aa_int_shortint \\`uvm_field_aa_int_shortint_unsigned \\`uvm_field_aa_int_string uvm_field_aa_object_int \\`uvm_field_aa_object_string \\`uvm_field_aa_string_string uvm_field_array_\\*macros \\`uvm_field_array_enum uvm_field_array_int \\`uvm_field_array_object \\`uvm_field_array_string \\`uvm_field_enum \\`uvm_field_event \\`uvm_field_object \\`uvm_field_queue_\\*macros \\`uvm_field_queue_enum \\`uvm_field_queue_int \\`uvm_field_queue_object \\`uvm_field_queue_string \\`uvm_field_real \\`uvm_field_sarray_\\*macros \\`uvm_field_sarray_enum \\`uvm_field_sarray_int \\`uvm_field_sarray_object \\`uvm_field_sarray_string \\`uvm_field_string \\`uvm_field_utils_begin \\`uvm_field_utils_end \\`uvm_get_imp_decl \\`uvm_get_peek_imp_decl \\`uvm_info \\`uvm_info_begin \\`uvm_info_context \\`uvm_info_context_begin \\`uvm_info_context_end \\`uvm_info_end \\`uvm_master_imp_decl \\`UVM_MAX_STREAMBITS \\`uvm_message_add_int \\`uvm_message_add_object \\`uvm_message_add_string \\`uvm_message_add_tag \\`uvm_nonblocking_get_imp_decl \\`uvm_nonblocking_get_peek_imp_decl \\`uvm_nonblocking_master_imp_decl \\`uvm_nonblocking_peek_imp_decl \\`uvm_nonblocking_put_imp_decl \\`uvm_nonblocking_slave_imp_decl \\`uvm_nonblocking_transport_imp_decl \\`uvm_object_param_utils \\`uvm_object_param_utils_begin \\`uvm_object_registry \\`uvm_object_utils \\`uvm_object_utils_begin \\`uvm_object_utils_end \\`uvm_pack_array \\`uvm_pack_arrayN \\`uvm_pack_enum uvm_pack_enumN \\`uvm_pack_int \\`uvm_pack_intN \\`uvm_pack_queue uvm_pack_queueN \\`uvm_pack_real \\`uvm_pack_sarray \\`uvm_pack_sarrayN \\`uvm_pack_string \\`UVM_PACKER_MAX_BYTES \\`uvm_peek_imp_decl \\`uvm_put_imp_decl \\`uvm_rand_send \\`uvm_rand_send_pri uvm_rand_send_pri_with uvm_rand_send_with uvm_record_attribute \\`uvm_record_field uvm_record_int \\`uvm_record_real uvm_record_string \\`uvm_record_time \\`UVM_REG_ADDR_WIDTH \\`UVM_REG_BYTENABLE_WIDTH \\`UVM_REG_CVR_WIDTH \\`UVM_REG_DATA_WIDTH uvm_register_cb \\`uvm_send uvm_send_pri uvm_sequence_library_utils uvm_set_super_type uvm_slave_imp_decl \\`UVM_TLM_B_MASK \\`UVM_TLM_B_TRANSPORT_IMP \\`UVM_TLM_FUNCTION_ERROR \\`UVM_TLM_NB_BW_MASK \\`UVM_TLM_NB_FW_MASK \\`UVM_TLM_NB_TRANSPORT_BW_IMP \\`UVM_TLM_NB_TRANSPORT_FW_IMP \\`UVM_TLM_TASK_ERROR \\`uvm_transport_imp_decl uvm_unpack_array \\`uvm_unpack_arrayN uvm_unpack_enum \\`uvm_unpack_enumN uvm_unpack_int \\`uvm_unpack_intN uvm_unpack_queue \\`uvm_unpack_queueN uvm_unpack_real \\`uvm_unpack_sarray \\`uvm_unpack_sarrayN \\`uvm_unpack_string uvm_warning \\`uvm_warning_begin \\`uvm_warning_context uvm_warning_context_begin \\`uvm_warning_context_end \\`uvm_warning_end"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_comparer uvm_packer uvm_recorder"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_reg_mem_hdl_paths_seq"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_visitor_adapter#(STRUCTURE,uvm_visitor#(STRUCTURE))"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "accept_tr uvm_component uvm_transaction"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_reg uvm_reg_block uvm_reg_field uvm_reg_fifo"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_link_base uvm_tlm_generic_payload"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "Action Configuration"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_reg_predictor uvm_reg_sequence"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_callbacks#(T,CB) uvm_heartbeat uvm_phase uvm_pool#(KEY,T) uvm_reg_read_only_cbs uvm_reg_write_only_cbs"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "Add/delete interface uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "add_by_name uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "add_callback uvm_event#(T)"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 783, "page_to": 783, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=783", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_container"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_container"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "add_sequence uvm_sequence_library"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "add_sequences uvm_sequence_library"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "add_slice uvm_hdl_path_concat"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_container"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "add_submap uvm_reg_map"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "add_typewide_sequenceuvm_sequence_library"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "add_typewide_sequencesuvm_sequence_library"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "add_uvm_phases uvm_domain"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "adjust_name uvm_printer"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_in_order_comparator#(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "Algorithmic Comparator all_dropped"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "uvm_component uvm_objection uvm_objection_callback"}
{"type": "text", "page_from": 784, "page_to": 784, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=784", "section_title": "Everything", "content": "alloc_mode_e uvm_mem_mam"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Global uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Analysis Ports analysis_export uvm_subscriber"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "analysis_export#(T) uvm_tlm_analysis_fifo#(T)"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "apply_config_settings uvm_component"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Argument Values uvm_cmdline_processor"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Attribute Recording uvm_recorder"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "b_transport uvm_tlm_if"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Backawards Compatibility backdoor uvm_reg_map"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "backdoor_read uvm_mem uvm_reg"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "backdoor_read_func uvm_mem uvm_reg"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "backdoor_watch uvm_reg"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "backdoor_write uvm_mem uvm_reg"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Backwards Compatibility Backwards Compatibility: BASE uvm_reg_sequence"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Basic Arguments uvm_cmdline_processor"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "Basic Messaging Macros bd_kind uvm_reg_item"}
{"type": "text", "page_from": 785, "page_to": 785, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=785", "section_title": "Everything", "content": "uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_in_order_comparator#(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "uvm_component uvm_transaction begin_elements uvm_printer_knobs begin_event uvm_transaction"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "BEGIN _REQ BEGIN_RESP begin tr uvm_component uvm_transaction"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "begin_v uvm_visitor#(NODE)"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "Bidirectional Interfaces&Ports big_endian uvm_packer"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "bin_radix uvm_printer_knobs"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "Bit Bashing Test Sequences Blocking get uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "Blocking peek uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "Blocking put uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "Blocking transport uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "blocking_put_port uvm_random_stimulus#(T)"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "uvm_mem_access_seq uvm_mem_single_walk_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_hw_reset_seq uvm_reg_mem_built_in_seq uvm_reg_mem_shared_access_seq uvm_reg_sequence uvm_sequence_base"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "build_phase uvm_component"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "Built-in UVM Aware Command Line Arguments uvm_cmdline_processor"}
{"type": "text", "page_from": 786, "page_to": 786, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=786", "section_title": "Everything", "content": "uvm_mem uvm_mem_region"}
{"type": "text", "page_from": 787, "page_to": 787, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=787", "section_title": "Everything", "content": "uvm_mem uvm_mem_region"}
{"type": "text", "page_from": 787, "page_to": 787, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=787", "section_title": "Everything", "content": "uvm_reg_map bus_in uvm_reg_predictor"}
{"type": "text", "page_from": 787, "page_to": 787, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=787", "section_title": "Everything", "content": "uvm_reg_adapter uvm_reg_tlm_adapter"}
{"type": "text", "page_from": 787, "page_to": 787, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=787", "section_title": "Everything", "content": "byte_en uvm_reg_bus_op"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "Callback Hooks uvm_objection"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "Callback Interface uvm_report_catcher"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "Callback Macros callback_mode uvm_callback"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "uvm_mem uvm_phase uvm_reg uvm_reg_field uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "Callbacks Classes can_get uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "can_peek uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "can_put uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "uvm_barrier uvm_event_base"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "capacity uvm_reg_fifo"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "catch uvm_report_catcher"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "CB uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "Change Message State uvm_report_catcher"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "check_config_usage uvm_component"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "check_data_width uvm_reg_block"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "check_phase uvm_component uvm_reg_predictor"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "check_type uvm_comparer"}
{"type": "text", "page_from": 788, "page_to": 788, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=788", "section_title": "Everything", "content": "Classes for Adapting Between Register and Bus Operations clear uvm_objection"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "clear_extension uvm_tlm_generic_payload"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "clear_extensions uvm_tlm_generic_payload"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file clear_response_queue uvm_sequence_base clone uvm_object"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "uvm_recorder uvm_tr_stream close_db uvm_tr_database"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "Code migration script Command Line Debug uvm_cmdline_processor"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "Command Line Processor Class Comparators comps/uvm_in_order_comparator.svh overviews/comparators.txt"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "compare uvm_object compare_field uvm_comparer compare_field_int uvm_comparer"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "compare_field_real uvm_comparer"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "compare_object uvm_comparer compare_string uvm_comparer"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "Comparing uvm_object"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "compose_report_message uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "Conditional Compilation Configuration uvm_object Configuration and Resource Classes Configuration API uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 789, "page_to": 789, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=789", "section_title": "Everything", "content": "Configuration Interface uvm_component"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_field uvm_reg_file uvm_reg_indirect_data uvm_reg_map uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "uvm_port_base#(IF) uvm_tlm_nb_passthrough_target_socket uvm_tlm_nb_target_socket"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "uvm_tlm_b_initiator_socket uvm_tlm_b_target_socket uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "connect_phase uvm_component"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "Construction uvm_phase"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "Container Classes Convenience Methods uvm_report_handler"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "Convenience Write/Read API uvm_reg_sequence"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "uvm_mem_mam uvm_object uvm_reg_item"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "Core Base Classes Coverage uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "uvm_component_registry#(T,Tname) uvm_object uvm_object_registry#(T,Tname) uvm_tlm_extension_base"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "uvm_component uvm_component_registry#(T,Tname) uvm_object_wrapper"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "create_component_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 790, "page_to": 790, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=790", "section_title": "Everything", "content": "create_component_by_type"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "create_item uvm_sequence_base"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "create_map uvm_reg_block"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "uvm_component uvm_object_registry#(T,Tname) uvm_object_wrapper"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "create_object_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "create_object_by_type uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "uvm_default_factory uvm_factory uvm_object"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "Current Message State uvm_report_catcher"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "Data Access Policies Database API uvm_tr_database"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "uvm_callbacks#(T,CB) uvm_default_factory uvm_factory uvm_report_catcher uvm_resource_pool"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "debug_connected_to uvm_port_base#(IF)"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "debug_create_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "debug_create_by_type uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "debug_provided_to uvm_port_base#(IF)"}
{"type": "text", "page_from": 791, "page_to": 791, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=791", "section_title": "Everything", "content": "dec_radix uvm_printer_knobs"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "uvm_reg_cbs decr uvm_tlm_time"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "Default Policy Classes default_alloc uvm_mem_mam"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "default_map uvm_reg_block default_path uvm_reg_block default_precedence uvm_resource_base"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "uvm_printer_knobs uvm_recorder"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "define_access uvm_reg_field"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "define_domain uvm_component"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "uvm_callbacks#(T,CB) uvm_object_string_pool#(T) uvm_pool#(KEY,T) uvm_queue#(T) uvm_report_message_element_container"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "delete_by_name uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "delete_callback uvm_event#(T)"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "delete_elements uvm_report_message_element_container depth uvm_printer_knobs die uvm_root"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "disable_auto_item_recording uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "disable_recording uvm_transaction display uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "display_objections uvm_objection"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "do_accept_tr uvm_component uvm_transaction"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "uvm_component uvm_transaction"}
{"type": "text", "page_from": 792, "page_to": 792, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=792", "section_title": "Everything", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_hw_reset_seq uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "do_bus_read uvm_reg_map do_bus_write uvm_reg_map"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_recorder uvm_text_recorder uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_text_tr_database uvm_tr_database"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "do_compare uvm_object"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_object uvm_reg_item uvm_report_server"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_component uvm_transaction"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_text_tr_database uvm_tr_database"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_recorder uvm_text_recorder uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "do_kill uvm_sequence_base"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_recorder uvm_text_recorder uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 793, "page_to": 793, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=793", "section_title": "Everything", "content": "uvm_text_tr_database"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "uvm_tr_database do_open_recorder uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "uvm_text_tr_database uvm_tr_database"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_post_read uvm_reg_backdoor"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_post_write uvm_reg_backdoor"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_pre_read uvm_reg_backdoor"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_pre_write uvm_reg_backdoor"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_predict uvm_reg_fifo"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "uvm_object uvm_resource_base"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record uvm_object"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record_field uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record_field_int uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record_field_real uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record_generic uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record_object uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record_string uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_record_time uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_reg_item uvm_reg_sequence"}
{"type": "text", "page_from": 794, "page_to": 794, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=794", "section_title": "Everything", "content": "do_set_lhs uvm_cause_effect_link uvm_link_base"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "do_unpack uvm_object do_write uvm_reg_map drop_objection uvm _objection uvm_phase"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "uvm_component uvm_objection uvm_objection_callback"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "uvm_resource_db uvm_resource_pool"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "element_kind uvm_reg_item"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "uvm_printer uvm_table_printer uvm_tree_printer enable_print_topology uvm_root"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "enable_recording uvm_transaction enable_report_id_count_summary uvm_default_report_server"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "encode uvm_reg_cbs end_elements uvm_printer_knobs end_event uvm_transaction end_of_elaboration_phase uvm_component"}
{"type": "text", "page_from": 795, "page_to": 795, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=795", "section_title": "Everything", "content": "end_offset uvm_mem_mam_cfg end_prematurely uvm_phase"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "END_REQ END_RESP end_tr uvm _component uvm_transaction"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "end_v uvm_visitor#(NODE)"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "reg/uvm_reg_model.svh tlm2/uvm_tlm2_ifs.svh"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "establish_link uvm_tr_database"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "events uvm_transaction"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "Example uvm_reg_adapter"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "uvm_bottomup_phase uvm_task_phase uvm_topdown_phase"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "execute_item uvm_sequencer_base"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "execute_report_message"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "uvm_config_db uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "Explicit Register Predictor extension uvm_reg_item"}
{"type": "text", "page_from": 796, "page_to": 796, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=796", "section_title": "Everything", "content": "Extensions Mechanism uvm_tlm_generic_payload"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "Factory Classes Factory Component and Object Wrappers Factory Interface uvm_component"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "Field automation Field Macros fifo uvm_reg_fifo"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "File Configuration uvm_report_object final_phase uvm_component find uvm_phase uvm_root find_all uvm_root uvm_utils#(TYPE,FIELD)"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "find_block uvm_reg_block find_blocks uvm_reg_block find_by_name uvm_phase find_override_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "find_override_by_type uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "find_unused_resources uvm_resource_pool"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "find_wrapper_by_name uvm_factory"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "finish_item uvm_sequence_base finish_on_completion uvm_root"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "first uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 797, "page_to": 797, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=797", "section_title": "Everything", "content": "uvm_in_order_comparator#(T,comp_type,convert,pair_type) uvm_tlm_fifo#(T)"}
{"type": "text", "page_from": 798, "page_to": 798, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=798", "section_title": "Everything", "content": "for_each uvm_mem_mam"}
{"type": "text", "page_from": 798, "page_to": 798, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=798", "section_title": "Everything", "content": "format_action uvm_report_handler"}
{"type": "text", "page_from": 798, "page_to": 798, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=798", "section_title": "Everything", "content": "format_header uvm_printer"}
{"type": "text", "page_from": 798, "page_to": 798, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=798", "section_title": "Everything", "content": "format_row uvm_printer"}
{"type": "text", "page_from": 798, "page_to": 798, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=798", "section_title": "Everything", "content": "free uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 798, "page_to": 798, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=798", "section_title": "Everything", "content": "free_tr_stream uvm_component"}
{"type": "text", "page_from": 798, "page_to": 798, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=798", "section_title": "Everything", "content": "from_nameuvm_enum_wrapper#(T)"}
{"type": "text", "page_from": 799, "page_to": 799, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=799", "section_title": "Everything", "content": "General Overview generate_stimulus uvm_random_stimulus#(T) Generic Payload Generic Register Operation Descriptors get uvm_build_phase uvm_check_phase uvm_component_registry#(T,Tname) uvm_config_db uvm_configure_phase uvm_connect_phase uvm_coreservice_t uvm_end_of_elaboration_phase uvm_extract_phase uvm_factory uvm_final_phase uvm_get_to_lock_dap uvm_main_phase uvm_object_registry#(T,Tname) uvm_object_string_pool#(T) uvm_pool#(KEY,T) uvm_post_configure_phase uvm_post_main_phase uvm_post_reset_phase uvm_post_shutdown_phase uvm_pre_configure_phase uvm_pre_main_phase uvm_pre_reset_phase uvm_pre_shutdown_phase uvm_queue#(T) uvm_reg uvm_reg_field uvm_reg_fifo uvm_report_phase uvm_reset_phase uvm_resource_pool uvm_root uvm_run_phase uvm_sequencer#(REQ,RSP) uvm_set_before_get_dap uvm_set_get_dap_base uvm_shutdown_phase uvm_simple_lock_dap uvm_sqr_if_base#(REQ,RSP) uvm_start_of_simulation_phase uvm_tlm_if_base#(T1,T2) Get and Peek get_abstime"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_accept_time uvm_transaction"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "uvm_mem uvm_reg_field uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_base"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_addr_unit_bytes uvm_reg_map"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_tlm_generic_payload uvm_vreg"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_adjacent_predecessor_nodes uvm_phase"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_adjacent_successor_nodes uvm_phase"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_ap uvm_tlm_fifo_base#(T)"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_arbitration uvm_sequencer_base"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_arg_matches uvm_cmdline_processor"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_arg_value uvm_cmdline_processor"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_arg_values uvm_cmdline_processor"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_args uvm_cmdline_processor"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_auto_predict uvm_reg_map"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_automatic_phase_objection uvm_sequence_base"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_base_addr uvm_reg_map"}
{"type": "text", "page_from": 800, "page_to": 800, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=800", "section_title": "Everything", "content": "get_begin_time uvm_transaction"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_block_by_name uvm_reg_block"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_blocks uvm_reg_block"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "uvm_resource#(T) uvm_resource_db uvm_resource_pool"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "uvm_resource#(T) uvm_resource_db uvm_resource_pool"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_byte_enable uvm_tlm_generic_payload"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_byte_enable_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_cb uvm_callback_iter"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_check_on_read uvm_reg_map"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_child uvm_component"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_children uvm_component"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_client uvm_report_catcher"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_close_time uvm_recorder"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_command uvm_tlm_generic_payload"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_common_domain uvm_domain"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_comp uvm_port_base#(IF)"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_compare uvm_reg_field"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_component_visitor"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_configuvm_utils#(TYPE,FIELD)"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_connected_to uvm_port_component_base"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 801, "page_to": 801, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=801", "section_title": "Everything", "content": "get_current_item uvm_sequence#(REQ,RSP)"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_data uvm_tlm_generic_payload"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_data_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_db uvm_tr_stream"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_default_hdl_path uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_default_path uvm_reg_block"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_default_tr_database uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "uvm_component uvm_sequence_item"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "uvm_component uvm_phase"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_domain_name uvm_phase"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_domains uvm_domain"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_drain_time uvm_objection"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_element_container uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_elements uvm_report_message_element_container"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_end_offset uvm_mem_region"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_end_time uvm_transaction"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_event_pool uvm_transaction"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_extension uvm_tlm_generic_payload"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "get_factory uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "uvm_reg uvm_reg_block uvm_vreg"}
{"type": "text", "page_from": 802, "page_to": 802, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=802", "section_title": "Everything", "content": "uvm_reg uvm_reg_block uvm_reg_map uvm_vreg"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "get_file uvm_report_message get_filename uvm_report_message get_first uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "get_first_child uvm_component get_fname uvm_report_catcher"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "get_frontdoor uvm_mem uvm_reg"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "uvm_component uvm_mem uvm_object uvm_phase uvm_port_base#(IF) uvm_reg uvm_reg_block uvm_reg_field uvm_reg_file uvm_reg_map uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "uvm_object_string_pool#(T) uvm_pool#(KEY,T) uvm_queue#(T)"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "uvm_object_string_pool#(T) uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "get_global_queue uvm_queue#(T)"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "get_hdl_path_kinds uvm_mem uvm_reg"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "get_highest_precedence"}
{"type": "text", "page_from": 803, "page_to": 803, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=803", "section_title": "Everything", "content": "uvm_resource#(T) uvm_resource_pool"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_id_set uvm_report_server"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_if uvm_port_base#(IF)"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_immediate_children uvm_structure_proxy#(STRUCTURE)"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_initiator uvm_transaction"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_inst uvm_cmdline_processor"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_inst_count uvm_object"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_inst_id uvm_object"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_is_active uvm_agent"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_item uvm_reg_adapter"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_jump_target uvm_phase"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_last uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_len uvm_mem_region"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_lhs uvm_link_base"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_line uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "uvm_cause_effect_link uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_lsb_pos uvm_reg_field"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_lsb_pos_in_register uvm_vreg_field"}
{"type": "text", "page_from": 804, "page_to": 804, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=804", "section_title": "Everything", "content": "get_map_by_name uvm_reg_block"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_reg uvm_reg_block uvm_vreg"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "get_mem_by_name uvm_reg_block"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "get_mem_by_offset uvm_reg_map"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "get_memories uvm_reg_block"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_mem_mam uvm_mem_region uvm_vreg"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "get_message_database uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "get_mirrored_value uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_field uvm_vreg_field"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_map uvm_vreg"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_vreg"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "get_n_memlocs uvm_vreg"}
{"type": "text", "page_from": 805, "page_to": 805, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=805", "section_title": "Everything", "content": "uvm_mem uvm_object uvm_port_base#(IF) uvm_reg uvm_reg_block uvm_reg_field uvm_reg_file uvm_reg_map uvm_report_message_element_base uvm_tlm_time uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_name_constraint uvm_component_name_check_visitor get_next uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_next_child uvm_component"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_num_children uvm_component"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_num_extensions uvm_tlm_generic_payload"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_num_last_reqs uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_num_last_rspsuvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_num_reqs_sent uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_num_rsps_received uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_num_waiters uvm_barrier uvm_event_base"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_object_type uvm_object"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_objection uvm_phase"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_objection_count uvm_objection uvm_phase"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_objection_total uvm_objection"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_objectors uvm_objection"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_offset uvm_mem uvm_reg"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_offset_in_memory uvm_vreg"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_open_time uvm_recorder"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "get_packed_size uvm_packer"}
{"type": "text", "page_from": 806, "page_to": 806, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=806", "section_title": "Everything", "content": "uvm_component uvm_mem"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "uvm_phase uvm_port_base#(IF) uvm_reg uvm_reg_block uvm_reg_field uvm_reg_file uvm_reg_map uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_parent_map uvm_reg_map get_parent_sequence uvm_sequence_item get_peek_export uvm_tlm_fifo_base#(T)"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_peek_request_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_peek_response_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_phase_type uvm_phase"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_physical_addresses uvm_reg_map"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_plusargs uvm_cmdline_processor get_port uvm_port_component#(PORT)"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_prev uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_prev_state uvm_phase_state_change get_priority uvm_sequence_base get_propagate_mode uvm_objection"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_provided_to uvm_port_component_base get_quit_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_radix_str uvm_printer_knobs get_realtime uvm_tlm_time get_record_attribute_handle uvm_recorder"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_recorder_from_handle uvm_recorder"}
{"type": "text", "page_from": 807, "page_to": 807, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=807", "section_title": "Everything", "content": "get_recorders uvm_tr_stream get_reg_by_name uvm_reg_block get_regfile uvm_reg uvm_reg_file get_region uvm_vreg"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "uvm_reg_block uvm_reg_map"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_report_action uvm_report_object"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_report_catcher uvm_report_catcher"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_report_file_handle uvm_report_object"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "uvm_report_message uvm_report_object"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_report_max_verbosity_level uvm_report_object"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_report_object uvm_report_message"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "uvm_coreservice_t uvm_default_coreservice_t uvm_report_message"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_report_verbosity_level uvm_report_object"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_reset uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_response uvm_sequence#(REQ,RSP)"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_response_queue_depth uvm_sequence_base"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_response_queue_error_report_disabled uvm_sequence_base"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_response_status uvm_tlm_generic_payload"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_response_string uvm_tlm_generic_payload"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_rhs uvm_link_base"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_vreg"}
{"type": "text", "page_from": 808, "page_to": 808, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=808", "section_title": "Everything", "content": "get_root uvm_coreservice_t"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_root_sequence uvm_sequence_item"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_root_sequence_name uvm_sequence_item"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_run_count uvm_phase"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_schedule uvm_phase"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_schedule_name uvm_phase"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "uvm_resource_base uvm_tr_stream"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_sequence_id uvm_sequence_item"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_sequence_path uvm_sequence_item"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_sequence_state uvm_sequence_base"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_sequencer uvm_reg_map uvm_sequence_item"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_sequencesuvm_sequence_library"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_server uvm_report_server"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_severity_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_severity_set uvm_report_server"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_size uvm_mem uvm_vreg"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_start_offset uvm_mem_region"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_starting_phase uvm_sequence_base"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_state uvm_phase uvm_phase_state_change"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_stream uvm_recorder"}
{"type": "text", "page_from": 809, "page_to": 809, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=809", "section_title": "Everything", "content": "get_stream_from_handle uvm_tr_stream"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_stream_type_name uvm_tr_stream"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_streaming_width uvm_tlm_generic_payload"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_streams uvm_tr_database"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_submap_offset uvm_reg_map"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_submaps uvm_reg_map"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_threshold uvm_barrier"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_tool_name uvm_cmdline_processor"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_tool_version uvm_cmdline_processor"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "uvm_sequence_base uvm_transaction"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_tr_stream uvm_component"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_transaction_id uvm_transaction"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_transaction_order_policy uvm_reg_map"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_trigger_data uvm_event#(T)"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_trigger_time uvm_event_base"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_type uvm_object uvm_resource#(T)"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "uvm_resource#(T) uvm_resource_base uvm_tlm_extension_base"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_type_handle_name uvm_tlm_extension_base"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "uvm_callback uvm_component_registry#(T,Tname) uvm_object uvm_object_registry#(T,Tname) uvm_object_string_pool#(T) uvm_object_wrapper uvm_port_base#(IF) uvm_sequence_library"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_use_response_handler uvm_sequence_base"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_use_sequence_info uvm_sequence_item"}
{"type": "text", "page_from": 810, "page_to": 810, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=810", "section_title": "Everything", "content": "get_uvm_domain uvm_domain get_uvm_schedule uvm_domain"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "get_uvmargs uvm_cmdline_processor"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "uvm_report_message_int_element uvm_report_message_object_element uvm_report_message_string_element"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "get_vfield_by_name uvm_mem uvm_reg_block"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "uvm_mem uvm_reg_block uvm_reg_map"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "get_virtual_registers"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "uvm_mem uvm_mem_region uvm_reg_block uvm_reg_map"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "get_vreg_by_name uvm_mem uvm_reg_block"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "get_vreg_by_offset uvm_mem"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "Global Declarations for the Register Layer Global Functionality Global Variables uvm_root"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "base/uvm_globals.svh tlm2/uvm_tlm2_generic_payload.svh"}
{"type": "text", "page_from": 811, "page_to": 811, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=811", "section_title": "Everything", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "has_child uvm_component"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "has_do_availableuvm_sequencer#(REQ,RSP)uvm_sequencer_baseuvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "uvm_mem uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "HDL Paths Checking Test Sequence header uvm_printer_knobs"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "hex_radix uvm_printer_knobs"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "Hierarchical Reporting Interface uvm_component"}
{"type": "text", "page_from": 812, "page_to": 812, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=812", "section_title": "Everything", "content": "Hierarchy Interface uvm_component"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "uvm_printer_knobs uvm_recorder"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "IMP binding classes IMP binding macros implement uvm_vreg"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "Implementation Agnostic API"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "uvm_recorder uvm_text_recorder uvm_text_tr_database uvm_text_tr_stream uvm_tr_database uvm_tr_stream"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "Implementation Callbacks"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "Implementation Specific API"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "uvm_text_recorder uvm_text_tr_database"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "in_use uvm_mem_mam_policy"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "include_coverage uvm_reg"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "incr_id_count uvm_default_report_server"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "incr_quit_count uvm_default_report_server"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "incr_severity_count uvm_default_report_server"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "Infrastructure References uvm_report_message"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "init_access_record uvm_resource_base"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "init_sequence_libraryuvm_sequence_library"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "initialization uvm_vreg_field"}
{"type": "text", "page_from": 813, "page_to": 813, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=813", "section_title": "Everything", "content": "uvm_mem uvm_mem_mam uvm_reg uvm_reg_block uvm_reg_field uvm_reg_fifo uvm_reg_file uvm_reg_map uvm_vreg"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "Intro base/uvm_config_db.svh base/uvm_registry.svh base/uvm_resource.svh base/uvm_resource_db.svh"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "uvm_get_to_lock_dap uvm_mem uvm_mem_mam uvm_reg uvm_reg_block uvm_reg_field uvm_reg_fifo uvm_reg_file uvm_reg_map uvm_set_before_get_dap uvm_simple_lock_dap uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "is_auditing uvm_resource_options"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "is_auto_item_recording_enableduvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "is_auto_updated uvm_reg_backdoor"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "is_child uvm_sequencer_base"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 814, "page_to": 814, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=814", "section_title": "Everything", "content": "is_dmi_allowed uvm_tlm_generic_payload"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "uvm_port_base#(IF) uvm_port_component_base"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_full uvm_tlm_fifo#(T)"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_grabbed uvm_sequencer_base"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_hdl_path_root uvm_reg_block"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_imp uvm_port_base#(IF) uvm_port_component_base"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_vreg"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_indv_accessible uvm_reg_field"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "uvm_sequence_base uvm_sequence_item"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_known_access uvm_reg_field"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "uvm_reg_block uvm_simple_lock_dap"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_off uvm_event_base"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_on uvm_event_base"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "uvm_recorder uvm_tr_database uvm_tr_stream"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "uvm_port_base#(IF) uvm_port_component_base"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_quit_count_reached uvm_default_report_server"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_read uvm_tlm_generic_payload"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_read_only uvm_resource_base"}
{"type": "text", "page_from": 815, "page_to": 815, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=815", "section_title": "Everything", "content": "is_recording_enabled uvm_transaction"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "is_response_error uvm_tlm_generic_payload"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "is_response_ok uvm_tlm_generic_payload"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "uvm_config_db_options uvm_resource_db_options"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "is_unbounded uvm_port_base#(IF)"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "is_volatile uvm_reg_field"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "is_write uvm_tlm_generic_payload"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "uvm_domain uvm_phase"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "uvm_phase_state_change"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "kind uvm_reg_bus_op uvm_reg_item"}
{"type": "text", "page_from": 816, "page_to": 816, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=816", "section_title": "Everything", "content": "uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "last_req uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "last_rspuvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "len uvm_mem_mam_policy"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "Link API uvm_tr_database"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "local_map uvm_reg_item"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "locality uvm_mem_mam_cfg"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "locality_e uvm_mem_mam"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "uvm_sequence_base uvm_sequencer_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "lock_model uvm_reg_block"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "Locking uvm_simple_lock_dap"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "lookup uvm_component"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "Lookup uvm_resource_pool"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "lookup_name uvm_resource_pool"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "lookup_regex uvm_resource_pool"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "lookup_regex_names uvm_resource_pool"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "lookup_scope uvm_resource_pool"}
{"type": "text", "page_from": 817, "page_to": 817, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=817", "section_title": "Everything", "content": "m _address uvm_tlm_generic_payload m_byte_enable uvm_tlm_generic_payload m_byte_enable_length uvm_tlm_generic_payload m command uvm_tlm_generic_payload"}
{"type": "text", "page_from": 818, "page_to": 818, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=818", "section_title": "Everything", "content": "m_data uvm_tlm_generic_payload m_dmi uvm_tlm_generic_payload m_length uvm_tlm_generic_payload m_response_status uvm_tlm_generic_payload m_streaming_width uvm_tlm_generic_payload"}
{"type": "text", "page_from": 818, "page_to": 818, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=818", "section_title": "Everything", "content": "macros/uvm_callback_defines.svh macros/uvm_reg_defines.svh macros/uvm_tlm_defines.svh tlm2/uvm_tlm2_defines.svh tlm2/uvm_tlm2_ifs.svh"}
{"type": "text", "page_from": 818, "page_to": 818, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=818", "section_title": "Everything", "content": "Macros and Defines main_phase uvm_component"}
{"type": "text", "page_from": 819, "page_to": 819, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=819", "section_title": "Everything", "content": "map uvm _reg _item uvm _reg _predictor Master and Slave master export uvm _tlm_req_rsp_channel#(REQ,RSP) match scope uvm _resource base max _offset uvm_mem_mam_policy max random _count uvm _sequence _library max _size uvm_port_base#(IF) mcd"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "uvm_mem_shared_access_seq uvm_mem_single_access_seq uvm_mem_single_walk_seq"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "Memory Access Test Sequence Memory Allocation Manager Memory Management uvm_mem_mam"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "Memory Walking-Ones Test Sequences Message Element APIs uvm_report_message"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "Message Element Macros Message Fields uvm_report_message"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "uvm_default_report_server uvm_report_handler"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "message recording uvm_default_report_server"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "Message Trace Macros Methods"}
{"type": "text", "page_from": 820, "page_to": 820, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=820", "section_title": "Everything", "content": "uvm \\*_export#(REQ,RSP) uvm_\\*_export#(T) uvm_\\*_imp#(REQ,RSP,IMP,REQ_IMP,RSP_IMP) uvm_\\*_imp#(T,IMP) uvm_\\*_port#(REQ,RSP) uvm_\\*_port#(T) uvm_agent uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_analysis_export uvm_analysis_port uvm_barrier uvm_bottomup_phase uvm_build_phase uvm_built_in_pair#(T1,T2) uvm_callback uvm_callback_iter uvm_check_phase uvm_class_pair#(T1,T2) uvm_comparer uvm_component_name_check_visitor uvm_component_registry#(T,Tname) uvm_config_db uvm_config_db_options uvm_configure_phase uvm_connect_phase uvm_coreservice_t uvm_default_coreservice_t uvm_domain uvm_driver#(REQ,RSP) uvm_end_of_elaboration_phase uvm_enum_wrapper#(T) uvm_env uvm_event#(T) uvm_event_base uvm_event_callback uvm_extract_phase uvm_final_phase uvm_hdl_path_concat uvm_heartbeat uvm_in_order_comparator#(T,comp_ty uvm_main_phase uvm_mem_access_seq uvm_mem_region uvm_mem_single_walk_seq uvm_mem_walk_seq uvm_monitor uvm_object_string_pool#(T) uvm_object_wrapper uvm_objection_callback uvm_phase_cb uvm_phase_state_change uvm_pool#(KEY,T) uvm_port_base#(IF) uvm_port_component#(PORT) uvm_port_component_base uvm_post_configure_phase uvm_post_main_phase uvm_post_reset_phase uvm_post_shutdown_phase uvm_pre_configure_phase uvm_pre_main_phase uvm_pre_reset_phase uvm_pre_shutdown_phase uvm_printer_knobs uvm_push_driver#(REQ,RSP) uvm_push_sequencer#(REQ,RSP) uvm_queue#(T) uvm_random_stimulus#(T) uvm_reg_access_seq uvm_reg_backdoor uvm_reg_bit_bash_seq uvm_reg_cbs uvm_reg_frontdoor uvm_reg_hw_reset_seq uvm_reg_indirect_data uvm_reg_item uvm_reg_mem_built_in_seq uvm_reg_mem_shared_access_seq uvm_reg_predictor uvm_reg_read_only_cbs uvm_reg_tlm_adapter uvm_reg_transaction_order_policy uvm_reg_write_only_cbs uvm_report_message_element_base uvm_report_message_element_containe uvm_report_message_int_element uvm_report_message_object_element uvm_report_message_string_element uvm_report_phase uvm_report_server uvm_reset_phase uvm_resource_db uvm_resource_db_options uvm_resource_options uvm_run_phase uvm_scoreboard uvm_seq_item_pull_imp#(REQ,RSP,IMP) uvm_sequence#(REQ,RSP) uvm_sequencer_base uvm_shutdown_phase uvm_sqr_if_base#(REQ,RSP) uvm_start_of_simulation_phase uvm_structure_proxy#(STRUCTURE) uvm_subscriber uvm_table_printer uvm_task_phase uvm_test uvm_tlm_analysis_fifo#(T) uvm_tlm_b_initiator_socket uvm_tlm_b_target_socket uvm_tlm_extension uvm_tlm_extension_base uvm_tlm_fifo#(T) uvm_tlm_fifo_base#(T) uvm_tlm_nb_initiator_socket uvm_tlm_nb_passthrough_target_socket uvm_tlm_nb_target_socket uvm_tlm_nb_transport_bw_export uvm_tlm_nb_transport_bw_port uvm_tlm_req_rsp_channel#(REQ,RSP) uvm_tlm_transport_channel#(REQ,RSP) uvm_topdown_phase uvm_transaction uvm_tree_printer uvm_utils#(TYPE,FIELD) uvm_visitor#(NODE) uvm_visitor_adapter#(STRUCTURE,uvm_vis uvm_vreg_cbs uvm_vreg_field_cbs"}
{"type": "text", "page_from": 822, "page_to": 822, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=822", "section_title": "Everything", "content": "Methods for printer subtyping uvm_printer"}
{"type": "text", "page_from": 822, "page_to": 822, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=822", "section_title": "Everything", "content": "mid_do uvm_sequence_base"}
{"type": "text", "page_from": 822, "page_to": 822, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=822", "section_title": "Everything", "content": "min_offset uvm_mem_mam_policy"}
{"type": "text", "page_from": 822, "page_to": 822, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=822", "section_title": "Everything", "content": "min_random_count uvm_sequence_library"}
{"type": "text", "page_from": 822, "page_to": 822, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=822", "section_title": "Everything", "content": "min_size uvm_port_base#(IF)"}
{"type": "text", "page_from": 822, "page_to": 822, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=822", "section_title": "Everything", "content": "uvm_reg uvm_reg_block uvm_reg_field uvm_reg_fifo"}
{"type": "text", "page_from": 823, "page_to": 823, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=823", "section_title": "Everything", "content": "Miscellaneous Miscellaneous Structures miscompares uvm_comparer"}
{"type": "text", "page_from": 823, "page_to": 823, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=823", "section_title": "Everything", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_hw_reset_seq uvm_reg_mem_built_in_seq uvm_reg_mem_shared_access_seq uvm_reg_sequence"}
{"type": "text", "page_from": 823, "page_to": 823, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=823", "section_title": "Everything", "content": "Modifying the offset of a memory will make the abstract model uvm_mem"}
{"type": "text", "page_from": 824, "page_to": 824, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=824", "section_title": "Everything", "content": "n_bytes uvm_mem_mam_cfg"}
{"type": "text", "page_from": 824, "page_to": 824, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=824", "section_title": "Everything", "content": "nb_transport uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 824, "page_to": 824, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=824", "section_title": "Everything", "content": "nb_transport_bw uvm_tlm_if"}
{"type": "text", "page_from": 824, "page_to": 824, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=824", "section_title": "Everything", "content": "nb_transport_fw uvm_tlm_if"}
{"type": "text", "page_from": 824, "page_to": 824, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=824", "section_title": "Everything", "content": "uvm_reg uvm_reg_block uvm_reg_field"}
{"type": "text", "page_from": 824, "page_to": 824, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=824", "section_title": "Everything", "content": "uvm_\\*_export#(REQ,RSP) uvm \\*_export#(T) uvm_\\*_imp#(REQ,RSP,IMP,REQ_IMP,RSP_IMP) uvm_\\*_imp#(T,IMP) uvm \\* _port#(REQ,RSP) uvm_\\*_port#(T) uvm_agent uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_analysis_export uvm_barrier uvm_bottomup_phase uvm_built_in_pair#(T1,T2) uvm_callback uvm_callback_iter uvm_cause_effect_link uvm_class_pair#(T1,T2) uvm_component uvm_default_report_server uvm_domain uvm_driver#(REQ,RSP) uvm_env uvm_event#(T) uvm_event_base uvm_event_callback uvm_get_to_lock_dap uvm_heartbeat uvm _line_printer uvm _link_base uvm _mem uvm_mem_mam uvm_mem_single_walk_seq uvm_monitor uvm_object uvm_object_string_pool#(T) uvm_objection uvm_parent_child_link uvm_phase uvm_phase_cb uvm_pool#(KEY,T) uvm_port_base#(IF) uvm_push_driver#(REQ,RSP) uvm_push_sequencer#(REQ,RSP) uvm_queue#(T) uvm_random_stimulus#(T) uvm_reg uvm_reg_adapter uvm_reg_backdoor uvm_reg_block uvm_reg_field uvm_reg_fifo uvm_reg_file uvm_reg_frontdoor uvm_reg_indirect_data uvm_reg_item uvm_reg_map uvm_reg_predictor uvm_reg_sequence uvm_related_link uvm_report_catcher uvm_report_handler uvm_report_message uvm_report_message_element_container uvm_report_object uvm_resource_base uvm_scoreboard uvm_seq_item_pull_imp#(REQ,RSP,IMP) uvm_sequence#(REQ,RSP) uvm_sequence_base uvm_sequence_item uvm_sequence_library uvm_sequencer#(REQ,RSP) uvm_sequencer_base uvm_sequencer_param_base#(REQ,RSP) uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap uvm_subscriber uvm_table_printer uvm_task_phase uvm_test uvm_text_recorder uvm_text_tr_database uvm_text_tr_stream uvm_tlm_analysis_fifo#(T) uvm_tlm_b_initiator_socket uvm_tlm_b_target_socket uvm_tlm_extension uvm_tlm_extension_base uvm_tlm_fifo#(T) uvm_tlm_fifo_base#(T) uvm_tlm_generic_payload uvm_tlm_nb_initiator_socket uvm_tlm_nb_target_socket uvm_tlm_nb_transport_bw_export uvm_tlm_nb_transport_bw_port uvm_tlm_req_rsp_channel#(REQ,RSP) uvm_tlm_time uvm_tlm_transport_channel#(REQ,RSP) uvm_topdown_phase uvm_tr_database uvm_tr_stream uvm_transaction uvm_tree_printer uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "new_report_message uvm_report_message"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Non-blocking get uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Non-blocking peek uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Non-blocking put uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Non-blocking transport uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Objection Control uvm_objection"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Objection Interface uvm_component"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Objection Mechanism Objection Status uvm_objection"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "Objections oct_radix uvm_printer_knobs"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "open_db uvm_tr_database"}
{"type": "text", "page_from": 826, "page_to": 826, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=826", "section_title": "Everything", "content": "open_recorder uvm_tr_stream"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_bits uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_bytes uvm_object uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_field uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_field_int uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_ints uvm_object uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_object uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_real uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_string uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "pack_time uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "uvm_object uvm_packer"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "Packing Macros Packing-No Size Info Packing-With Size Info pair_ap uvm_in_order_comparator#(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "parent uvm_reg_item parent_sequence uvm_reg_adapter path uvm_reg_item"}
{"type": "text", "page_from": 828, "page_to": 828, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=828", "section_title": "Everything", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_field uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP) uvm_tlm_if_base#(T1,T2) uvm_vreg"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "uvm_vreg_field peek_mem uvm_reg_sequence peek_reg uvm_reg_sequence"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "Phase Done Objection uvm_phase"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "phase_ended uvm_component phase_ready_to_end uvm_component"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "phase_started uvm_component phase_state_change uvm_phase_cb"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "Phasing Phasing Definition classes Phasing Implementation Phasing Interface uvm_component"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "Phasing Overview physical uvm _comparer uvm _packer uvm_recorder"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_field uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "poke_mem uvm_reg_sequence poke_reg uvm_reg_sequence"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "Policy Classes comps/uvm_policies.svh overviews/policies.txt"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "Pool Classes pop_back uvm_queue#(T)"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "pop_front uvm_queue#(T)"}
{"type": "text", "page_from": 829, "page_to": 829, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=829", "section_title": "Everything", "content": "Port Base Classes Port Type Ports uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_driver#(REQ,RSP) uvm_in_order_comparator#(T,comp_type,convert,pair_type) uvm_push_driver#(REQ,RSP) uvm_push_sequencer#(REQ,RSP) uvm_random_stimulus#(T) uvm_subscriber uvm_tlm_analysis_fifo#(T) uvm_tlm_fifo_base#(T) uvm_tlm_req_rsp_channel#(REQ,RSP) uvm_tlm_transport_channel#(REQ,RSP)"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "Ports,Exports,and Imps post_body uvm_sequence_base"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "post_configure_phase uvm_component"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "post_do uvm_sequence_base post_main_phase uvm_component post_predict uvm_reg_cbs post_randomize uvm_tlm_generic_payload"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "post_reset_phase uvm_component post_shutdown_phase uvm_component"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "post_start uvm_sequence_base post_trigger uvm_event_callback"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 830, "page_to": 830, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=830", "section_title": "Everything", "content": "pre_configure_phase uvm_component"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "pre_main_phase uvm_component"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "pre_predict uvm_reg_predictor"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "pre_randomize uvm_tlm_generic_payload"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_reg_fifo uvm_reg_write_only_cbs uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "pre_shutdown_phase uvm_component"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "pre_start uvm_sequence_base"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "pre_trigger uvm_event_callback"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_reg_fifo uvm_reg_read_only_cbs uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "Predefined Component Classes Predefined Extensions predict uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 831, "page_to": 831, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=831", "section_title": "Everything", "content": "prev uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "uvm_default_report_server uvm_factory uvm_object uvm_report_handler uvm_report_message"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "print_array_footer uvm_printer"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "print_array_header uvm_printer"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "print_array_range uvm_printer"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "print_catcher uvm_report_catcher print_config uvm_component print_config_matches uvm_component"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "print_config_settings uvm_component"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "print_config_with_audit uvm_component"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "print_enabled uvm_component print_field uvm_printer print_field_int uvm_printer print_generic uvm_printer print_msg uvm_comparer print_object uvm_printer print_override_info uvm_component print_real uvm_printer print_resources uvm_resource_pool print_string uvm_printer print_time uvm_printer print_topology uvm_root"}
{"type": "text", "page_from": 832, "page_to": 832, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=832", "section_title": "Everything", "content": "Printing uvm_object prior uvm_reg_item"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "uvm_resource#(T) uvm_resource_base process_report_message uvm_report_handler"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "provides_responses uvm_reg_adapter push_back uvm_queue#(T)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "push_front uvm_queue#(T)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "put uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP) uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "Put put_ap uvm_tlm_fifo_base#(T)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "put_export uvm_tlm_fifo_base#(T)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "put_request_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "put_response uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "put_response_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 833, "page_to": 833, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=833", "section_title": "Everything", "content": "uvm_default_report_server"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "uvm_objection uvm_phase"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "uvm_component uvm_objection uvm_objection_callback"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_backdoor uvm_reg_field uvm_reg_fifo uvm_resource#(T) uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "Read-only Interface uvm_resource_base"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "Read/Write Interface uvm_resource#(T)"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "read_by_name uvm_resource_db read_by_type uvm_resource_db read_func uvm_reg_backdoor read_mem uvm_reg_sequence read_mem_by_name uvm_reg_block"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "read_reg uvm_reg_sequence read_reg_by_name uvm_reg_block"}
{"type": "text", "page_from": 834, "page_to": 834, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=834", "section_title": "Everything", "content": "record_all_messages uvm_default_report_server record_error_tr uvm_component record_event_tr uvm_component record_field uvm_recorder record_field_int uvm_recorder record_field_real uvm_recorder record_generic uvm_recorder record_object uvm_recorder record_read_access uvm_resource_base record_string uvm_recorder record_time uvm_recorder record_write_access uvm_resource_base"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "Recording uvm_object"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "Recording Interface uvm_component"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "Recording Macros recursion_policy uvm_recorder"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "reference uvm_printer_knobs reg_ap uvm_reg_predictor reg_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_mem_shared_access_seq reg_seqr uvm_reg_sequence"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "uvm_reg_adapter uvm_reg_tlm_adapter"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "Register Access Test Sequences Register Callbacks Register Defines Register Layer Register Sequence Classes Registering Types uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 835, "page_to": 835, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=835", "section_title": "Everything", "content": "release_all_regions uvm_mem_mam"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "uvm_mem_mam uvm_mem_region uvm_vreg"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "uvm_heartbeat uvm_reg_read_only_cbs uvm_reg_write_only_cbs remove_sequence uvm_sequence_library"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "Report Handler Configuration uvm_report_object"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "Report Macros report_phase uvm_component report_summarize uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "Reporting Global base/uvm_globals.svh base/uvm_object_globals.svh uvm_report_catcher uvm_report_object"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "Reporting Classes Reporting Interface uvm_sequence_item req uvm_sequence#(REQ,RSP)"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "uvm_push_driver#(REQ,RSP)"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "req_portuvm_push_sequencer#(REQ,RSP)"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "request_ap uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "request_region uvm_mem_mam"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "Requests uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "reserve_region uvm_mem_mam"}
{"type": "text", "page_from": 836, "page_to": 836, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=836", "section_title": "Everything", "content": "uvm_barrier uvm_event_base uvm_reg uvm_reg_block uvm_reg_field uvm_reg_map uvm_tlm_time uvm_vreg"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_hw_reset_seq uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "reset_phase uvm_component reset_quit_count uvm_default_report_server reset_report_handler uvm_report_object reset_severity_counts uvm_default_report_server"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "uvm_component uvm_port_base#(IF)"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "Resources Response API uvm_sequence_base response_ap uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "response_handler uvm_sequence_base"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "Responses uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "result uvm_comparer resume uvm_component"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "Retrieving the factory uvm_factory"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "rg uvm_reg_shared_access_seq uvm_reg_single_access_seq uvm_reg_single_bit_bash_seq rsp uvm_sequence#(REQ,RSP)"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "rsp_export uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "rsp_port uvm_driver#(REQ,RSP) uvm_push_driver#(REQ,RSP)"}
{"type": "text", "page_from": 837, "page_to": 837, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=837", "section_title": "Everything", "content": "uvm_componentuvm_push_sequencer#(REQ,RSP)"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "select_rand uvm_sequence_library"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "select_randc uvm_sequence_library"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "select_sequence uvm_sequence_library"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "selection_mode uvm_sequence_library"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "uvm_sequence#(REQ,RSP) uvm_sequence_base uvm_sequencer_base uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "uvm_printer_knobsseq_item_exportuvm_sequencer#(REQ,RSP)"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "seq_item_port uvm_driver#(REQ,RSP)"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "Sequence Action Macros Sequence Action Macros for Pre-Existing Sequences Sequence Classes Sequence Control uvm_sequence_base"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "Sequence Execution uvm_sequence_base"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "Sequence Item Execution uvm_sequence_base"}
{"type": "text", "page_from": 839, "page_to": 839, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=839", "section_title": "Everything", "content": "Sequence Item Pull Ports Sequence on Sequencer Action Macros Sequence registration"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "uvm_sequence_library"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "Sequence selection uvm_sequence_library"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "Sequence-Related Macros sequence_count uvm_sequence_library"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "sequencer uvm_reg_frontdoor"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "Sequencer Classes Sequencer Interface uvm_sequencer#(REQ,RSP)"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "Sequencer Port Sequencer Subtypes Sequences sequences_executed uvm_sequence_library"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "uvm_config_db uvm_get_to_lock_dap uvm_hdl_path_concat uvm_link_base uvm_reg uvm_reg_field uvm_reg_fifo uvm_resource#(T) uvm_resource_db uvm_resource_pool uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "Set uvm_resource_pool"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "uvm_resource#(T) uvm_resource_base"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "uvm_get_to_lock_dap uvm_resource#(T) uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "set_access uvm_reg_field"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_base"}
{"type": "text", "page_from": 840, "page_to": 840, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=840", "section_title": "Everything", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_arbitration uvm_sequencer_base"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_auto_predict uvm_reg_map"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_auto_reset uvm_barrier"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_automatic_phase_objection uvm_sequence_base"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_base_addr uvm_reg_map"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_byte_enable uvm_tlm_generic_payload"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_byte_enable_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_check_on_read uvm_reg_map"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_command uvm_tlm_generic_payload"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "uvm_reg_field uvm_reg_fifo"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_component_visitor"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_data uvm_tlm_generic_payload"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_data_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_default uvm_resource_db"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_default_hdl_path uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_default_index uvm_port_base#(IF)"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_default_map uvm_reg_block"}
{"type": "text", "page_from": 841, "page_to": 841, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=841", "section_title": "Everything", "content": "set_default_tr_database uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_dmi_allowed uvm_tlm_generic_payload"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_domain uvm_component"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_drain_time uvm_objection"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_extension uvm_tlm_generic_payload"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_file uvm_report_message"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_file_name uvm_text_tr_database"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_filename uvm_report_message"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_hdl_path_root uvm_reg_block"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_heartbeat uvm_heartbeat"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "uvm_component uvm_component_registry#(T,Tname) uvm_object_registry#(T,Tname)"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_inst_override_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_inst_override_by_type"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "uvm_component uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 842, "page_to": 842, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=842", "section_title": "Everything", "content": "set_int_local uvm_object"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_jump_phase uvm_phase"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_lhs uvm_link_base"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_line uvm_report_message"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_max_quit_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_max_zero_time_wait_relevant_count uvm_sequencer_base"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_message_database uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_mode uvm_heartbeat"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_name uvm_object uvm_report_message_element_base"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_name_override uvm_resource_pool"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_num_last_reqs uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_num_last_rsps uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_object_local uvm_object"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_offset uvm_mem uvm_reg"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "uvm_resource#(T) uvm_resource_pool"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_parent_sequence uvm_sequence_item"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_phase_imp uvm_component"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "uvm_resource_pool uvm_sequence_base"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_priority_name uvm_resource_pool"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_priority_type uvm_resource_pool"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_propagate_mode uvm_objection"}
{"type": "text", "page_from": 843, "page_to": 843, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=843", "section_title": "Everything", "content": "set_quit_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_read uvm_tlm_generic_payload"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_read_only uvm_resource_base"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_default_file uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_default_file_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_handler uvm_report_message uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_id_action uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_id_action_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_id_file uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_id_file_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_id_verbosity uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_id_verbosity_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_message uvm_report_message"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_object uvm_report_message"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "uvm_coreservice_t uvm_default_coreservice_t uvm_report_message"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_action uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_action_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_file uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_file_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_id_action uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_id_action_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_id_file uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_id_file_hier uvm_component"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_id_override uvm_report_object"}
{"type": "text", "page_from": 844, "page_to": 844, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=844", "section_title": "Everything", "content": "set_report_severity_id_verbosity uvm_report_object"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_report_severity_id_verbosity_hier uvm_component"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_report_severity_override uvm_report_object"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_report_verbosity_level uvm_report_object"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_report_verbosity_level_hier uvm_component"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_reset uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_response_queue_depth uvm_sequence_base"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_response_queue_error_report_disabled uvm_sequence_base"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_response_status uvm_tlm_generic_payload"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_rhs uvm_link_base"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_scope uvm_resource_base"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_sequencer uvm_reg_map uvm_sequence_item"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_server uvm_report_server"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message set_severity_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_starting_phase uvm_sequence_base set_streaming_width uvm_tlm_generic_payload set_string_local uvm_object"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_submap_offset uvm_reg_map"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_threshold uvm_barrier set_time_resolution uvm_tlm_time"}
{"type": "text", "page_from": 845, "page_to": 845, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=845", "section_title": "Everything", "content": "set_timeout uvm_root set_transaction_id uvm_transaction set_transaction_order_policy uvm_reg_map"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "uvm_component uvm_component_registry#(T,Tname) uvm_object_registry#(T,Tname) uvm_resource_pool"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "set_type_override_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "set_type_override_by_type"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "uvm_component uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "set_use_sequence_info uvm_sequence_item"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "uvm_report_message_int_element uvm_report_message_object_element uvm_report_message_string_element"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "set_volatility uvm_reg_field"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "Severity Count uvm_default_report_server"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "Shared Register and Memory Access Test Sequences show_max uvm_comparer"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "show_radix uvm_printer_knobs"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "show_root uvm_printer_knobs"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "show_terminator uvm_default_report_server"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "show_verbosity uvm_default_report_server"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "shutdown_phase uvm_component"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "uvm_cmdline_processor"}
{"type": "text", "page_from": 846, "page_to": 846, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=846", "section_title": "Everything", "content": "uvm_port_base#(IF) uvm_printer_knobs uvm_queue#(T) uvm_reg_fifo uvm_report_message_element_container uvm_tlm_fifo#(T)"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "slave_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "slices uvm_hdl_path_concat sort_by_precedence uvm_resource_pool"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "Special Overrides uvm_reg_fifo"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "spell_check uvm_resource_pool sprint uvm_object"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "uvm_heartbeat uvm_sequence_base"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "start_item uvm_sequence_base"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "start_of_simulation_phase uvm_component"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "start_offset uvm_mem_mam_policy"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "start_phase_sequence uvm_sequencer_base"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "uvm_reg_bus_op uvm_reg_item"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "stop_phase_sequence uvm_sequencer_base"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "stop_sequences uvm_sequencer#(REQ,RSP) uvm_sequencer_base"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "stop_stimulus_generation uvm_random_stimulus#(T)"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "uvm_tr_database uvm_tr_stream"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "summarize uvm_report_catcher"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "supports_byte_enable uvm_reg_adapter"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "Synchronization uvm_phase"}
{"type": "text", "page_from": 847, "page_to": 847, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=847", "section_title": "Everything", "content": "Synchronization Classes"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "uvm_built_in_pair#(T1,T2)uvm_class_pair#(T1,T2)"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "uvm_built_in_pair#(T1,T2)uvm_class_pair#(T1,T2)"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "uvm_reg_mem_built_in_seq"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "TLM Channel Classes TLM Export Classes TLM FIFO Classes TLM Generic Payload&Extensions TLM Implementation Port Declaration Macros TLM Interfaces TLM Port Classes TLM Socket Base Classes TLM Sockets tlm transport methodsuvm_tlm_if TLM1 TLM1 Interfaces,Ports,Exports and Transport Interfaces TLM2 TLM2 Export Classes TLM2 imps(interface implementations) TLM2 Interfaces,Ports,Exports and Transport Interfaces Subset TLM2 ports TLM2 Types Tool informationuvm_cmdline_processor"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "tr_database uvm_component"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "trace_mode uvm_objection"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "Transaction Recorder API uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 848, "page_to": 848, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=848", "section_title": "Everything", "content": "Transaction Recording Classes Transaction Recording Databases Transaction Recording Streams transport"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "Transport transport_export uvm_tlm_transport_channel#(REQ,RSP)"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "uvm_bottomup_phase uvm_task_phase uvm_topdown_phase"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "uvm_get_to_lock_dap uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "try_peek uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "try_put uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "uvm_get_to_lock_dap uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "turn_off_auditing uvm_resource_options turn_off_tracing uvm_config_db_options uvm_resource_db_options turn_on_auditing uvm_resource_options turn_on_tracing uvm_config_db_options uvm_resource_db_options"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "Type Interface uvm_resource#(T)"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "Type&Instance Overrides"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "type_name uvm_printer_knobs"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "Typedefs Types Global base/uvm_config_db.svh reg/uvm_reg_model.svh"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "uvm_vreg_cbs uvm_vreg_field_cbs"}
{"type": "text", "page_from": 849, "page_to": 849, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=849", "section_title": "Everything", "content": "Types and Enumerations"}
{"type": "text", "page_from": 850, "page_to": 850, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=850", "section_title": "Everything", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 850, "page_to": 850, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=850", "section_title": "Everything", "content": "Unidirectional Interfaces&Ports UNINITIALIZED_PHASE unlock uvm_sequence_base uvm_sequencer_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 850, "page_to": 850, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=850", "section_title": "Everything", "content": "unpack uvm_object unpack_bits uvm_packer unpack_bytes uvm_object uvm_packer unpack_field uvm_packer unpack_field_int uvm_packer"}
{"type": "text", "page_from": 850, "page_to": 850, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=850", "section_title": "Everything", "content": "unpack_ints uvm _object uvm_packer unpack_object uvm_packer unpack_real uvm_packer unpack_string uvm_packer unpack_time uvm_packer"}
{"type": "text", "page_from": 850, "page_to": 850, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=850", "section_title": "Everything", "content": "Unpacking uvm_object uvm_packer"}
{"type": "text", "page_from": 850, "page_to": 850, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=850", "section_title": "Everything", "content": "Unpacking Macros Unpacking-No Size Info Unpacking-With Size Info unsigned_radix uvm_printer_knobs"}
{"type": "text", "page_from": 850, "page_to": 850, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=850", "section_title": "Everything", "content": "unsync uvm_phase update uvm_reg uvm_reg_block uvm_reg_fifo"}
{"type": "text", "page_from": 851, "page_to": 851, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=851", "section_title": "Everything", "content": "Global uvm_default_factory uvm_object_registry#(T,Tname)"}
{"type": "text", "page_from": 851, "page_to": 851, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=851", "section_title": "Everything", "content": "use_metadata uvm_packer use_record_attribute uvm_recorder"}
{"type": "text", "page_from": 851, "page_to": 851, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=851", "section_title": "Everything", "content": "use_response_handler uvm_sequence_base use_uvm_seeding uvm_object"}
{"type": "text", "page_from": 851, "page_to": 851, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=851", "section_title": "Everything", "content": "used uvm_tlm_fifo#(T)"}
{"type": "text", "page_from": 851, "page_to": 851, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=851", "section_title": "Everything", "content": "User-Defined Phases user_priority_arbitration uvm_sequencer_base"}
{"type": "text", "page_from": 851, "page_to": 851, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=851", "section_title": "Everything", "content": "Utility and Field Macros for Components and Objects Utility Classes Utility Functions uvm_resource_base UVM_BIG_FIFO UVM_BIN uvm_bits_to_string uvm_bitstream_t UVM_BODY uvm_bottom_up_visitor_adapter uvm_bottomup_phase uvm_build_phase uvm_built_in_clone#(T) uvm_built_in_comp#(T) uvm_built_in_converter#(T) uvm_built_in_pair#(T1,T2) uvm_by_level_visitor_adapter UVM_CALL_HOOK uvm_callback uvm_callback_iter uvm_callbacks#(T,CB) uvm_cause_effect_link UVM_CHECK uvm_check_e uvm_check_phase uvm_class_clone#(T) uvm_class_comp#(T) uvm_class_converter#(T) uvm_class_pair#(T1,T2) uvm_cmdline_processor uvm_comparer uvm_component uvm_component_name_check_visitor uvm_component_proxy uvm_component_registry#(T,Tname) uvm_config_db uvm_config_db_options uvm_config_int uvm_config_object uvm_config_string uvm_config_wrapper uvm_configure_phase uvm_connect_phase uvm_coreservice_t UVM_COUNT uvm_coverage_model_e UVM_CREATED UVM_CVR_ADDR_MAP UVM_CVR_ALL UVM_CVR_FIELD_VALS UVM_CVR_REG_BITS UVM_DEC UVM_DEEP uvm_default_comparer uvm_default_coreservice_t uvm_default_factory uvm_default_line_printer uvm_default_packer UVM_DEFAULT_PATH uvm_default_printer uvm_default_report_server uvm_default_table_printer uvm_default_tree_printer UVM_DISPLAY UVM DO_ALL_REG_MEM_TESTS UVM DO_MEM_ACCESS UVM DO_MEM_WALK UVM DO_REG _ACCESS UVM DO_REG_BIT_BASH UVM DO_REG_HW_RESET UVM DO_SHARED_ACCESS uvm domain uvm _driver#(REQ,RSP) UVM DROPPED uvm _elem_kind_e uvm _end_of_elaboration_phase UVM_ENDED uvm _endianness_e UVM_ENUM uvm _enum_wrapper#(T) uvm env UVM EQ UVM ERROR uvm_event#(T) uvm _event_base uvm_event_callback UVM EXIT UVM EXPORT uvm extract_phase uvm _factory UVM FATAL UVM FIELD uvm _final_phase UVM FINISHED UVM FIX_REV UVM_FRONTDOOR UVM FULL uvm_get_report_object Global uvm_report_object uvm_get_to_lock_dap UVM _GT UVM_GTE UVM_HAS_X uvm _hdl_check_path uvm hdl_deposit uvm hdl _force uvm hdl_force_time UVM _HDL_MAX_WIDTH uvm_hdl_path_concat uvm_hdl_path_slice uvm _hdl_read uvm _hdl_release uvm _hdl_release_and_read uvm _heartbeat UVM _HEX UVM _HIER uvm _hier_e UVM_HIGH UVM_IMPLEMENTATION uvm_in_order_built_in_com uvm_in_order_class_compar : UVM_PHASE_NODE UVM_PHASE_READY_TO_END UVM_PHASE_SCHEDULE UVM_PHASE_SCHEDULED UVM_PHASE_STARTED uvm_phase_state uvm_phase_state_change UVM_PHASE_SYNCING UVM_PHASE_TERMINAL uvm_phase_type UVM_PHASE_UNINITIALIZED uvm_pool#(KEY,T) UVM_PORT uvm_port_base#(IF) uvm_port_component#(PORT) uvm_port_component_base uvm_port_type_e UVM_POST_BODY uvm_post_configure_phase uvm_post_main_phase uvm_post_reset_phase uvm_post_shutdown_phase UVM_POST_START UVM_POST_VERSION_1_1 UVM_PRE_BODY uvm_pre_configure_phase uvm_pre_main_phase uvm_pre_reset_phase uvm_pre_shutdown_phase UVM_PRE_START UVM_PREDICT UVM_PREDICT_DIRECT uvm_predict_e UVM_PREDICT_READ UVM_PREDICT_WRITE uvm_printer uvm_printer_knobs uvm_process_report_message Global uvm_report_object uvm_push_driver#(REQ,RSP) uvm_push_sequencer#(REQ,RSP) uvm_queue#(T) uvm_radix_enum UVM_RAISED uvm_random_stimulus#(T) UVM_READ UVM_REAL UVM_REAL_DEC UVM_REAL_EXP uvm_recorder uvm_recursion_policy_enum UVM_REFERENCE uvm_reg uvm_reg_addr_t uvm_reg_backdoor uvm_reg_bd_cb uvm_reg_bd_cb_iter uvm_reg_bit_bash_seq uvm_reg_block uvm_reg_bus_op uvm_reg_byte_en_t uvm_reg_cb uvm_reg_cb_iter uvm_reg_cbs uvm_reg_cvr_t uvm_reg_data_logic_t uvm_reg_data_t uvm_reg_field uvm_reg_field_cb uvm_reg_field_cb_iter uvm_reg_fifo uvm_reg_file uvm_reg_frontdoor uvm_reg_hw_reset_seq uvm_reg_indirect_data uvm_reg_item uvm_reg_map uvm_reg_mem_access_seq uvm_reg_mem_built_in_seq uvm_reg_mem_hdl_paths_seq uvm_reg_mem_shared_access_seq uvm_reg_mem_tests_e uvm_reg_predictor uvm_reg_read_only_cbs uvm_reg_sequence uvm_reg_shared_access_seq uvm_reg_single_access_seq uvm_reg_single_bit_bash_seq uvm_reg_tlm_adapter uvm_reg_transaction_order_policy uvm_reg_write_only_cbs uvm_related_link uvm_report Global uvm_report_catcher uvm_report_object uvm_sequence_item uvm_report_catcher uvm_report_enabled Global uvm_report_object uvm_report_error Global uvm_report_catcher uvm_report_object uvm_sequence_item uvm_report_fatal"}
{"type": "text", "page_from": 857, "page_to": 857, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=857", "section_title": "Everything", "content": "uvm_report_catcher uvm_report_object uvm_sequence_item"}
{"type": "text", "page_from": 857, "page_to": 857, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=857", "section_title": "Everything", "content": "uvm_report_handler uvm_report_info Global uvm_report_catcher uvm_report_object uvm_sequence_item uvm_report_message uvm_report_message_element_base uvm_report_message_element_container uvm_report_message_int_element uvm_report_message_object_element uvm_report_message_string_element uvm_report_object uvm_report_phase uvm _report_server uvm_report_warning Global uvm_report_catcher uvm_report_object uvm_sequence_item uvm_reset_phase uvm_resource#(T) uvm_resource_base uvm_resource_db uvm_resource_db_options uvm_resource_options uvm_resource_pool uvm_resource_types UVM_RM_RECORD uvm_root uvm_run_phase uvm_scoreboard UVM_SEQ_ARB_FIFO UVM_SEQ_ARB_RANDOM UVM_SEQ_ARB_STRICT_FIFO UVM_SEQ_ARB_STRICT_RANDOM UVM_SEQ_ARB_USER UVM_SEQ_ARB_WEIGHTED uvm_seq_item_pull_export#(REQ,RSP) uvm_seq_item_pull_imp#(REQ,RSP,IMP) uvm_seq_item_pull_port#(REQ,RSP) UVM_SEQ_LIB_ITEM UVM_SEQ_LIB_RAND UVM_SEQ_LIB_RANDC UVM_SEQ_LIB_USER uvm_sequence#(REQ,RSP) uvm_sequence_base uvm_sequence_item uvm_sequence_lib_mode uvm_sequence_library uvm_sequence_library_cfg uvm_sequence_library_utils uvm_sequence_library uvm_sequence_state_enum uvm_sequencer_arb_mode uvm_sequencer_base uvm_sequencer_param_base#(REQ,RSP) uvm_set_before_get_dap uvm_set_get_dap_base uvm_severity UVM_SHALLOW uvm_shutdown_phase uvm_simple_lock_dap uvm_split_string uvm_sqr_if_base#(REQ,RSP) uvm_start_of_simulation_phase uvm_status_e UVM_STOP UVM_STOPPED UVM_STRING uvm_string_to_bits uvm_structure_proxy#(STRUCTURE) uvm_subscriber uvm_table_printer uvm_task_phase uvm_test uvm_text_recorder uvm_text_tr_database uvm_text_tr_stream UVM_TIME UVM_TLM_ACCEPTED UVM_TLM_ADDRESS_ERROR_RESPONSE uvm_tlm_analysis_fifo#(T) uvm_tlm_b_initiator_socket uvm_tlm_b_initiator_socket_base uvm_tlm_b_passthrough_initiator_socket uvm_tlm_b_passthrough_initiator_socket_base uvm_tlm_b_passthrough_target_socket uvm_tlm_b_passthrough_target_socket_base uvm_tlm_b_target_socket uvm_tlm_b_target_socket_base uvm_tlm_b_transport_export uvm_tlm_b_transport_imp uvm_tlm_b_transport_port UVM_TLM_BURST_ERROR_RESPONSE UVM_TLM_BYTE_ENABLE_ERROR_RESPONSE uvm_tlm_command_e UVM_TLM_COMMAND_ERROR_RESPONSE UVM_TLM_COMPLETED uvm_tlm_extension uvm_tlm_extension_base uvm_tlm_fifo#(T) uvm_tlm_fifo_base#(T) UVM_TLM_GENERIC_ERROR_RESPONSE uvm_tlm_generic_payload uvm_tlm_gp uvm_tlm_if uvm_tlm_if_base#(T1,T2) UVM_TLM_IGNORE_COMMAND UVM_TLM_INCOMPLETE_RESPONSE uvm_tlm_nb_initiator_socket uvm_tlm_nb_initiator_socket_base uvm_tlm_nb_passthrough_initiator_socket uvm_tlm_nb_passthrough_initiator_socket_base uvm_tlm_nb_passthrough_target_socket uvm_tlm_nb_passthrough_target_socket_base uvm_tlm_nb_target_socket uvm_tlm_nb_target_socket_base uvm_tlm_nb_transport_bw_export uvm_tlm_nb_transport_bw_imp uvm_tlm_nb_transport_bw_port uvm_tlm_nb_transport_fw_export uvm_tlm_nb_transport_fw_imp uvm_tlm_nb_transport_fw_port UVM_TLM_OK_RESPONSE uvm_tlm_phase_e UVM_TLM_READ_COMMAND uvm_tlm_req_rsp_channel#(REQ,RSP) uvm_tlm_response_status_e uvm_tlm_sync_e uvm_tlm_time uvm_tlm_transport_channel#(REQ,RSP) UVM_TLM_UPDATED UVM_TLM_WRITE_COMMAND uvm_top uvm_root uvm_top_down_visitor_adapter uvm_topdown_phase uvm_tr_database uvm_tr_stream uvm_transaction uvm_tree_printer UVM_UNFORMAT2 UVM_UNFORMAT4 UVM_UNSIGNED uvm_utils#(TYPE,FIELD) uvm_verbosity UVM_VERSION_1_2 UVM_VERSION_STRING uvm_visitor#(NODE) uvm_visitor_adapter#(STRUCTURE,uvm_visitor#(STRUCTURE)) uvm_void uvm_vreg uvm_vreg_cb uvm_vreg_cbs uvm_vreg_cb_iter uvm_vreg_cbs uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cb uvm_vreg_field_cbs uvm_vreg_field_cb_iter uvm_vreg_field_cbs uvm_vreg_field_cbs uvm_wait_for_nba_region uvm_wait_op UVM_WARNING UVM_WRITE"}
{"type": "text", "page_from": 860, "page_to": 860, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=860", "section_title": "Everything", "content": "uvm_reg_field uvm_reg_item"}
{"type": "text", "page_from": 860, "page_to": 860, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=860", "section_title": "Everything", "content": "Global uvm_built_in_pair#(T1,T2) uvm_class_pair#(T1,T2) uvm_comparer uvm_hdl_path_concat uvm_line_printer uvm_mem_access_seq uvm_mem_mam_cfg uvm_mem_mam_policy uvm_mem_shared_access_seq uvm_mem_single_access_seq uvm_mem_single_walk_seq uvm_mem_walk_seq uvm_packer uvm_printer_knobs uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_bus_op uvm_reg_frontdoor uvm_reg_hw_reset_seq uvm_reg_item uvm_reg_mem_built_in_seq uvm_reg_mem_hdl_paths_seq uvm_reg_mem_shared_access_seq uvm_reg_predictor uvm_reg_shared_access_seq uvm_reg_single_access_seq uvm_reg_single_bit_bash_seq uvm_sequence#(REQ,RSP) uvm_table_printer uvm_transaction uvm_tree_printer"}
{"type": "text", "page_from": 860, "page_to": 860, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=860", "section_title": "Everything", "content": "Verbosity Configuration uvm_report_object"}
{"type": "text", "page_from": 860, "page_to": 860, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=860", "section_title": "Everything", "content": "Virtual Register Field Classes Virtual Registers visit uvm_visitor#(NODE)"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "uvm_barrier uvm_objection"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "wait_for_change uvm_reg_backdoor"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "wait_for_grant uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "wait_for_item_done uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "wait_for_relevant uvm_sequence_base"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "wait_for_sequence_state uvm_sequence_base"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "uvm_sequencer#(REQ,RSP) uvm_sequencer_base uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "wait_for_state uvm_phase wait_modified uvm_config_db uvm_resource_base wait_off uvm_event_base wait_on uvm_event_base wait_ptrigger uvm_event_base wait_ptrigger_data uvm_event#(T)"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "wait_trigger uvm_event_base wait_trigger_data uvm_event#(T)"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "What’s Changed Why is this necessary uvm_tlm_time"}
{"type": "text", "page_from": 861, "page_to": 861, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=861", "section_title": "Everything", "content": "uvm_analysis_port uvm_mem uvm_mem_region uvm _reg uvm _reg _backdoor uvm _reg_field uvm _reg_fifo uvm_resource#(T) uvm_subscriber uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 862, "page_to": 862, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=862", "section_title": "Everything", "content": "uvm_vreg uvm_vreg_field write_attribute uvm_text_recorder write_attribute_int uvm_text_recorder write_by_name uvm_resource_db write_by_type uvm_resource_db write_mem uvm_reg_sequence write_mem_by_name uvm_reg_block"}
{"type": "text", "page_from": 862, "page_to": 862, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=862", "section_title": "Everything", "content": "write_reg uvm_reg_sequence write_reg_by_name uvm_reg_block"}
{"type": "text", "page_from": 863, "page_to": 863, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=863", "section_title": "Classes", "content": "Phasing Implementation"}
{"type": "text", "page_from": 863, "page_to": 863, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=863", "section_title": "Classes", "content": "uvm_\\*_export#(REQ,RSP) uvm_\\*_export#(T) uvm_\\*_imp#(REQ,RSP,IMP,REQ_IMP,RSP_IMP) uvm_\\*_imp#(T,IMP) uvm_\\*_port#(REQ,RSP) uvm_\\*_port#(T) uvm_agent uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_analysis_export uvm_analysis_imp uvm_analysis_port uvm_barrier uvm_bottom_up_visitor_adapter uvm_bottomup_phase uvm_build_phase uvm_built_in_clone#(T) uvm_built_in_comp#(T) uvm_built_in_converter#(T) uvm_built_in_pair#(T1,T2) uvm_by_level_visitor_adapter uvm_callback uvm_callback_iter uvm_callbacks#(T,CB) uvm_cause_effect_link uvm_check_phase uvm_class_clone#(T) uvm_class_comp#(T) uvm_class_converter#(T) uvm_class_pair#(T1,T2) uvm_cmdline_processor uvm_comparer uvm_component uvm_component_name_check_visitor uvm_component_proxy uvm_component_registry#(T,Tname) uvm_config_db uvm_config_db_options uvm_configure_phase uvm_connect_phase uvm_coreservice_t uvm_default_coreservice_t uvm_default_factory uvm_default_report_server uvm_domain uvm_driver#(REQ,RSP) uvm_enum_wrapper#(T) uvm_env uvm_event#(T) uvm_event_base uvm_event_callback uvm_extract_phase uvm_factory uvm_final_phase uvm_get_to_lock_dap uvm_hdl_path_concat uvm_heartbeat uvm_in_order_built_in_comparato uvm_in_order_class_comparator# uvm_in_order_comparator#(T,co uvm_line_printer uvm_link_base uvm_main_phase uvm_mem uvm_mem_access_seq uvm_mem_mam uvm_mem_mam_cfg uvm_mem_mam_policy uvm_mem_region uvm_mem_shared_access_seq uvm_mem_single_access_seq uvm_mem_single_walk_seq uvm_mem_walk_seq uvm_monitor uvm_object uvm_object_registry#(T,Tname) uvm_object_string_pool#(T) uvm_object_wrapper uvm_objection uvm_objection_callback uvm_packer uvm_parent_child_link uvm_phase uvm_phase_cb uvm_phase_cb_pool uvm_phase_state_change uvm_pool#(KEY,T) uvm_port_base#(IF) uvm_port_component#(PORT) uvm_port_component_base uvm_post_configure_phase uvm_post_main_phase uvm_post_reset_phase uvm_post_shutdown_phase uvm_pre_configure_phase uvm_pre_main_phase uvm_pre_reset_phase uvm_pre_shutdown_phase uvm_printer uvm_printer_knobs uvm_push_driver#(REQ,RSP) uvm_push_sequencer#(REQ,RSP) uvm_queue#(T) uvm_random_stimulus#(T) uvm_recorder uvm_reg_adapter uvm_reg_backdoor uvm_reg_bit_bash_seq uvm_reg_block uvm_reg_bus_op uvm_reg_cbs uvm_reg_field uvm_reg_fifo uvm_reg_file uvm_reg_frontdoor uvm_reg_hw_reset_seq uvm_reg_indirect_data uvm_reg_item uvm_reg_map uvm_reg_mem_access_seq uvm_reg_mem_built_in_seq uvm_reg_mem_hdl_paths_seq uvm_reg_mem_shared_access_seq uvm_reg_predictor uvm_reg_read_only_cbs uvm_reg_sequence uvm_reg_shared_access_seq uvm_reg_single_access_seq uvm_reg_single_bit_bash_seq uvm_reg_tlm_adapter uvm_reg_transaction_order_policy uvm_reg_write_only_cbs uvm_related_link uvm_report_catcher uvm_report_handler uvm_report_message uvm_report_message_element_base uvm_report_message_element_container uvm_report_message_int_element uvm_report_message_object_element uvm_report_message_string_element uvm_report_object uvm_report_phase uvm_report_server uvm_reset_phase uvm_resource#(T) uvm_resource_base uvm_resource_db uvm_resource_db_options uvm_resource_options uvm_resource_pool uvm_resource_types uvm_root uvm_run_phase uvm_scoreboard uvm_seq_item_pull_export#(REQ,RSP) uvm_seq_item_pull_imp#(REQ,RSP,IMP) uvm_seq_item_pull_port#(REQ,RSP) uvm_sequence#(REQ,RSP) uvm_sequence_base uvm_sequence_item uvm_sequence_library uvm_sequence_library_cfg uvm_sequencer_param_base#(REQ,RSP) uvm_set_before_get_dap uvm_set_get_dap_base uvm_shutdown_phase uvm_simple_lock_dap uvm_sqr_if_base#(REQ,RSP) uvm_start_of_simulation_phase uvm_structure_proxy#(STRUCTURE) uvm_subscriber uvm_table_printer uvm_task_phase uvm_test uvm_text_recorder uvm_text_tr_database uvm_text_tr_stream uvm_tlm_analysis_fifo#(T) uvm_tlm_b_initiator_socket uvm_tlm_b_initiator_socket_base uvm_tlm_b_passthrough_initiator_socket uvm_tlm_b_passthrough_initiator_socket_base uvm_tlm_b_passthrough_target_socket uvm_tlm_b_passthrough_target_socket_base uvm_tlm_b_target_socket uvm_tlm_b_target_socket_base uvm_tlm_b_transport_export uvm_tlm_b_transport_imp uvm_tlm_b_transport_port uvm_tlm_extension uvm_tlm_extension_base uvm_tlm_fifo#(T) uvm_tlm_fifo_base#(T) uvm_tlm_generic_payload uvm_tlm_gp uvm_tlm_if uvm_tlm_if_base#(T1,T2) uvm_tlm_nb_initiator_socket uvm_tlm_nb_initiator_socket_base uvm_tlm_nb_passthrough_initiator_socket uvm_tlm_nb_passthrough_initiator_socket_base uvm_tlm_nb_passthrough_target_socket uvm_tlm_nb_passthrough_target_socket_base uvm_tlm_nb_target_socket uvm_tlm_nb_target_socket_base uvm_tlm_nb_transport_bw_export uvm_tlm_nb_transport_bw_imp uvm_tlm_nb_transport_bw_port uvm_tlm_nb_transport_fw_export uvm_tlm_nb_transport_fw_imp uvm_tlm_nb_transport_fw_port uvm_tlm_req_rsp_channel#(REQ,RSP) uvm_tlm_time uvm_tlm_transport_channel#(REQ,RSP) uvm_top_down_visitor_adapter uvm_topdown_phase uvm_tr_database uvm_tr_stream uvm_transaction uvm_tree_printer uvm_utils#(TYPE,FIELD) uvm_visitor#(NODE) uvm_visitor_adapter#(STRUCTURE,uvm_visitor#(STRUCTURE)) uvm_void uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 869, "page_to": 869, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=869", "section_title": "Macros", "content": "\\`uvm_add_to_sequence_library \\`uvm_analysis_imp_decl \\`uvm_blocking_get_imp_decl \\`uvm_blocking_get_peek_imp_decl \\`uvm_blocking_master_imp_decl \\`uvm_blocking_peek_imp_decl \\`uvm_blocking_put_imp_decl uvm_blocking_slave_imp_decl \\`uvm_blocking_transport_imp_decl \\`uvm_component_end \\`uvm_component_param_utils \\`uvm_component_param_utils_begin \\`uvm_component_registry uvm_component_utils \\`uvm_component_utils_begin \\`uvm_create uvm_create_on \\`uvm_declare_p_sequencer \\`UVM_DEFAULT_TIMEOUT \\`uvm_do \\`uvm_do_callbacks \\`uvm_do_callbacks_exit_on uvm_do_obj_callbacks \\`uvm_do_obj_callbacks_exit_on \\`uvm_do_on \\`uvm_do_on_pri \\`uvm_do_on_pri_with \\`uvm_do_on_with \\`uvm_do_pri \\`uvm_do_pri_with \\`uvm_do_with \\`uvm_error \\`uvm_error_begin \\`uvm_error_context uvm_error_context_begin \\`uvm_error_context_end \\`uvm_error_end \\`uvm_fatal uvm_fatal_begin \\`uvm_fatal_context \\`uvm_fatal_context_begin \\`uvm_fatal_context_end \\`uvm_fatal_end \\`uvm_field_aa_int_byte \\`uvm_field_aa_int_byte_unsigned \\`uvm_field_aa_int_enumkey \\`uvm_field_aa_int_int uvm_field_aa_int_int_unsigned \\`uvm_field_aa_int_integer \\`uvm_field_aa_int_integer_unsigned \\`uvm_field_aa_int_key \\`uvm_field_aa_int_longint_unsigned \\`uvm_field_aa_int_shortint \\`uvm_field_aa_int_shortint_unsigned \\`uvm_field_aa_int_string \\`uvm_field_aa_object_int \\`uvm_field_aa_object_string \\`uvm_field_aa_string_string \\`uvm_field_array_enum \\`uvm_field_array_int \\`uvm_field_array_object \\`uvm_field_array_string \\`uvm_field_enum \\`uvm_field_event \\`uvm_field_int \\`uvm_field_object \\`uvm_field_queue_enum \\`uvm_field_queue_int \\`uvm_field_queue_object \\`uvm_field_queue_string \\`uvm_field_real \\`uvm_field_sarray_enum \\`uvm_field_sarray_int \\`uvm_field_sarray_object \\`uvm_field_sarray_string \\`uvm_field_string \\`uvm_field_utils_begin \\`uvm_field_utils_end \\`uvm_get_imp_decl \\`uvm_get_peek_imp_decl \\`uvm_info \\`uvm_info_begin \\`uvm_info_context \\`uvm_info_context_begin \\`uvm_info_context_end \\`uvm_info_end \\`uvm_master_imp_decl \\`UVM_MAX_STREAMBITS \\`uvm_message_add_int \\`uvm_message_add_object \\`uvm_message_add_string \\`uvm_message_add_tag \\`uvm_nonblocking_get_imp_decl \\`uvm_nonblocking_get_peek_imp_decl \\`uvm_nonblocking_master_imp_decl \\`uvm_nonblocking_peek_imp_decl \\`uvm_nonblocking_put_imp_decl \\`uvm_nonblocking_slave_imp_decl \\`uvm_nonblocking_transport_imp_decl \\`uvm_object_param_utils uvm_object_param_utils_begin \\`uvm_object_registry \\`uvm_object_utils \\`uvm_object_utils_begin \\`uvm_object_utils_end \\`uvm_pack_array \\`uvm_pack_arrayN \\`uvm_pack_enum \\`uvm_pack_enumN \\`uvm_pack_int \\`uvm_pack_intN \\`uvm_pack_queue \\`uvm_pack_queueN \\`uvm_pack_real \\`uvm_pack_sarray \\`uvm_pack_sarrayN \\`uvm_pack_string \\`UVM_PACKER_MAX_BYTES \\`uvm_peek_imp_decl \\`uvm_put_imp_decl \\`uvm_rand_send \\`uvm_rand_send_pri \\`uvm_rand_send_pri_with \\`uvm_rand_send_with \\`uvm_record_attribute \\`uvm_record_field \\`uvm_record_int \\`uvm_record_real \\`uvm_record_string \\`uvm_record_time \\`UVM_REG_ADDR_WIDTH \\`UVM_REG_BYTENABLE_WIDTH \\`UVM_REG_CVR_WIDTH \\`UVM_REG_DATA_WIDTH \\`uvm_register_cb \\`uvm_send \\`uvm_send_pri \\`uvm_sequence_library_utils \\`uvm_set_super_type \\`uvm_slave_imp_decl \\`UVM_TLM_B_MASK \\`UVM_TLM_B_TRANSPORT_IMP \\`UVM_TLM_FUNCTION_ERROR \\`UVM_TLM_NB_BW_MASK \\`UVM_TLM_NB_FW_MASK \\`UVM_TLM_NB_TRANSPORT_BW_IMP \\`UVM_TLM_NB_TRANSPORT_FW_IMP \\`UVM_TLM_TASK_ERROR \\`uvm_transport_imp_decl \\`uvm_unpack_array \\`uvm_unpack_arrayN \\`uvm_unpack_enum \\`uvm_unpack_enumN \\`uvm_unpack_int \\`uvm_unpack_intN \\`uvm_unpack_queue \\`uvm_unpack_queueN \\`uvm_unpack_real uvm_unpack_sarray \\`uvm_unpack_sarrayN \\`uvm_unpack_string \\`uvm_warning uvm_warning_begin \\`uvm_warning_context \\`uvm_warning_context_begin uvm_warning_context_end uvm_warning_end"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "uvm_visitor_adapter#(STRUCTURE,uvm_visitor#(STRUCTURE))"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "uvm_component uvm_transaction"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "uvm_callbacks#(T,CB) uvm_heartbeat uvm_phase uvm_pool#(KEY,T) uvm_reg_read_only_cbs uvm_reg_write_only_cbs"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "add_by_name uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "add_callback uvm_event#(T)"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file add_hdl_path_slice uvm_mem uvm_reg"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_container"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_container"}
{"type": "text", "page_from": 873, "page_to": 873, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=873", "section_title": "Methods", "content": "add_sequence uvm_sequence_library"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "uvm_sequence_library add_slice uvm_hdl_path_concat"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_container"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "add_submap uvm_reg_map"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "add_typewide_sequenceuvm_sequence_library"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "add_typewide_sequencesuvm_sequence_library"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "add_uvm_phases uvm_domain"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "adjust_name uvm_printer"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "uvm_component uvm_objection uvm_objection_callback"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "apply_config_settings uvm_component"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "backdoor_read uvm_mem uvm_reg"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "backdoor_read_func uvm_mem uvm_reg"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "backdoor_watch uvm_reg"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "backdoor_write uvm_mem uvm_reg"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "begin_child_tr uvm_component uvm_transaction"}
{"type": "text", "page_from": 874, "page_to": 874, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=874", "section_title": "Methods", "content": "uvm_component uvm_transaction"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "uvm_mem_access_seq uvm_mem_single_walk_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_mem_built_in_seq uvm_reg_mem_shared_access_seq uvm_reg_sequence uvm_sequence_base"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "build_phase uvm_component"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "burst_read uvm_mem uvm_mem_region"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "uvm_mem uvm_mem_region"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "uvm_reg_adapter uvm_reg_tlm_adapter"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "can_get uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "can_put uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "uvm_barrier uvm_event_base"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "catch uvm_report_catcher"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "check_config_usage uvm_component"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "check_data_width uvm_reg_block"}
{"type": "text", "page_from": 875, "page_to": 875, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=875", "section_title": "Methods", "content": "uvm_component uvm_reg_predictor"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "clear_extension uvm_tlm_generic_payload"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "clear_extensions uvm_tlm_generic_payload"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file clear_response_queue uvm_sequence_base"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "close_db uvm_tr_database"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "compare_field uvm_comparer"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "compare_field_int uvm_comparer"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "compare_field_real uvm_comparer"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "compare_object uvm_comparer"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "compare_string uvm_comparer"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "compose_report_message"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_field uvm_reg_file uvm_reg_indirect_data uvm_reg_map uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "uvm_port_base#(IF) uvm_tlm_nb_passthrough_target_socket uvm_tlm_nb_target_socket"}
{"type": "text", "page_from": 876, "page_to": 876, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=876", "section_title": "Methods", "content": "uvm_tlm_b_initiator_socket"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "uvm_tlm_b_target_socket uvm_tlm_nb_initiator_socket"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "connect_phase uvm_component"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "uvm_mem_mam uvm_object uvm_reg_item"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "uvm_component_registry#(T,Tname) uvm_object uvm_object_registry#(T,Tname) uvm_tlm_extension_base"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "uvm_component uvm_component_registry#(T,Tname) uvm_object_wrapper"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "create_component_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "create_component_by_type uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "create_item uvm_sequence_base"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "create_map uvm_reg_block"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "uvm_component uvm_object_registry#(T,Tname) uvm_object_wrapper"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "create_object_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "create_object_by_type"}
{"type": "text", "page_from": 877, "page_to": 877, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=877", "section_title": "Methods", "content": "uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "debug_connected_to uvm_port_base#(IF)"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "debug_create_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "debug_create_by_type uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "debug_provided_to uvm_port_base#(IF)"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "define_access uvm_reg_field"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "define_domain uvm_component"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "uvm_callbacks#(T,CB) uvm_object_string_pool#(T) uvm_pool#(KEY,T) uvm_queue#(T) uvm_report_message_element_container"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "delete_by_name uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "delete_callback uvm_event#(T)"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "uvm_report_message_element_container die uvm_root"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "disable_auto_item_recording uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "disable_recording uvm_transaction"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "display uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "display_objections uvm_objection"}
{"type": "text", "page_from": 878, "page_to": 878, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=878", "section_title": "Methods", "content": "uvm_component uvm_transaction"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_component uvm_transaction"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_hw_reset_seq uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "do_bus_read uvm_reg_map do_bus_write uvm_reg_map"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_recorder uvm_text_recorder uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_text_tr_database uvm_tr_database"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "do_compare uvm_object do_copy uvm_object uvm_reg_item uvm_report_server"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_component uvm_transaction"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_text_tr_database uvm_tr_database"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_recorder uvm_text_recorder uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 879, "page_to": 879, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=879", "section_title": "Methods", "content": "uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "uvm_text_tr_database uvm_tr_database"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "uvm_text_tr_stream uvm_tr_stream"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "uvm_text_tr_database uvm_tr_database"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_post_read uvm_reg_backdoor"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_post_write uvm_reg_backdoor"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_pre_read uvm_reg_backdoor"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_pre_write uvm_reg_backdoor"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_predict uvm_reg_fifo"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_print uvm_object uvm_resource_base"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record uvm_object"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record_field uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record_field_int uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record_field_real uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record_generic uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record_object uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record_string uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 880, "page_to": 880, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=880", "section_title": "Methods", "content": "do_record_time uvm_recorder uvm_text_recorder"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "uvm_cause_effect_link uvm_link_base uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "do_unpack uvm_object do_write uvm_reg_map drop_objection uvm _objection uvm_phase"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "uvm_component uvm_objection uvm_objection_callback"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "uvm_resource_db uvm_resource_pool"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "uvm_printer uvm_table_printer uvm_tree_printer"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "end_of_elaboration_phase uvm_component"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "end_prematurely uvm_phase"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "end_tr uvm_component uvm_transaction"}
{"type": "text", "page_from": 881, "page_to": 881, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=881", "section_title": "Methods", "content": "establish_link uvm_tr_database"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "uvm_bottomup_phase uvm_task_phase uvm_topdown_phase"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "execute_report_message uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "uvm_config_db uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "extract_phase uvm_component"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_all uvm_root uvm_utils#(TYPE,FIELD)"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_block uvm_reg_block"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_blocks uvm_reg_block"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_by_name uvm_phase"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_override_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_override_by_type uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_unused_resources uvm_resource_pool"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "find_wrapper_by_name uvm_factory"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "finish_item uvm_sequence_base"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "first uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 882, "page_to": 882, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=882", "section_title": "Methods", "content": "uvm_in_order_comparator#(T,comp_type,convert,pair_type) uvm_tlm_fifo#(T)"}
{"type": "text", "page_from": 884, "page_to": 884, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=884", "section_title": "Methods", "content": "uvm_random_stimulus#(T) get uvm_build_phase uvm_check_phase uvm_component_registry#(T,Tname) uvm_config_db uvm_configure_phase uvm_connect_phase uvm_coreservice_t uvm_end_of_elaboration_phase uvm_extract_phase uvm_factory uvm_final_phase uvm_get_to_lock_dap uvm_main_phase uvm_object_registry#(T,Tname) uvm_object_string_pool#(T) uvm_pool#(KEY,T) uvm_post_configure_phase uvm_post_main_phase uvm_post_reset_phase uvm_post_shutdown_phase uvm_pre_configure_phase uvm_pre_main_phase uvm_pre_reset_phase uvm_pre_shutdown_phase uvm_queue#(T) uvm_reg uvm_reg_field uvm_reg_fifo uvm_report_phase uvm_reset_phase uvm_resource_pool uvm_root uvm_run_phase uvm_sequencer#(REQ,RSP) uvm_set_before_get_dap uvm_set_get_dap_base uvm_shutdown_phase uvm_simple_lock_dap uvm_sqr_if_base#(REQ,RSP) uvm_start_of_simulation_phase uvm_tlm_if_base#(T1,T2) get_abstime uvm_tlm_time get_accept_time uvm_transaction"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "uvm_mem uvm_reg_field uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_base"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_addr_unit_bytes uvm_reg_map"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_tlm_generic_payload uvm_vreg"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_adjacent_predecessor_nodes uvm_phase"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_adjacent_successor_nodes uvm_phase"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_arbitration uvm_sequencer_base"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_arg_matches uvm_cmdline_processor"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_arg_value uvm_cmdline_processor"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_arg_values uvm_cmdline_processor"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_args uvm_cmdline_processor"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_auto_predict uvm_reg_map"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_automatic_phase_objection uvm_sequence_base"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_base_addr uvm_reg_map"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_begin_time uvm_transaction"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_block_by_name uvm_reg_block"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_blocks uvm_reg_block"}
{"type": "text", "page_from": 885, "page_to": 885, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=885", "section_title": "Methods", "content": "get_by_name uvm_resource#(T)"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "uvm_resource_db uvm_resource_pool"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "uvm_resource#(T) uvm_resource_db uvm_resource_pool"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_byte_enable uvm_tlm_generic_payload"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_byte_enable_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_cb uvm_callback_iter"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_check_on_read uvm_reg_map"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_child uvm_component"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_children uvm_component"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_client uvm_report_catcher"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_close_time uvm_recorder"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_command uvm_tlm_generic_payload"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_common_domain uvm_domain"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_comp uvm_port_base#(IF)"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_compare uvm_reg_field"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_component_visitor uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_configuvm_utils#(TYPE,FIELD)"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_connected_to uvm_port_component_base"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_context uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "uvm_sequence#(REQ,RSP) uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "get_data uvm_tlm_generic_payload"}
{"type": "text", "page_from": 886, "page_to": 886, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=886", "section_title": "Methods", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_db uvm_tr_stream"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_default_hdl_path"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_default_path uvm_reg_block"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_default_tr_database uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "uvm_component uvm_sequence_item"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "uvm_component uvm_phase"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_domain_name uvm_phase"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_domains uvm_domain get_drain_time uvm_objection get_element_container uvm_report_catcher uvm_report_message get_elements uvm_report_message_element_container"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_end_offset uvm_mem_region get_end_time uvm_transaction get_event_pool uvm_transaction get_extension uvm_tlm_generic_payload get_factory uvm_coreservice_t uvm_default_coreservice_t get_field_by_name uvm_reg uvm_reg_block uvm_vreg"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "uvm_reg uvm_reg_block uvm_reg_map uvm_vreg"}
{"type": "text", "page_from": 887, "page_to": 887, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=887", "section_title": "Methods", "content": "get_file uvm_report_message"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "get_fname uvm_report_catcher"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_component uvm_mem uvm_object uvm_phase uvm_port_base#(IF) uvm _reg uvm_reg_block uvm_reg_field uvm_reg_file uvm_reg_map uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_object_string_pool#(T) uvm_pool#(KEY,T) uvm_queue#(T)"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "get_global_pool uvm_object_string_pool#(T) uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "get_global_queue uvm_queue#(T)"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file get_hdl_path_kinds uvm_mem uvm_reg"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "get_highest_precedence"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_resource#(T) uvm_resource_pool"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 888, "page_to": 888, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=888", "section_title": "Methods", "content": "uvm_default_report_server"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_id_set uvm_report_server"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_immediate_children uvm_structure_proxy#(STRUCTURE)"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_initiator uvm_transaction"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_inst uvm_cmdline_processor"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_inst_count uvm_object"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_inst_id uvm_object"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_is_active uvm_agent"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_item uvm_reg_adapter"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_jump_target uvm_phase"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_last uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_len uvm_mem_region"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_lhs uvm_link_base"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "uvm_cause_effect_link uvm_parent_child_link uvm_related_link"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_lsb_pos uvm_reg_field"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_lsb_pos_in_register uvm_vreg_field"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "get_map_by_name uvm_reg_block"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block uvm_vreg"}
{"type": "text", "page_from": 889, "page_to": 889, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=889", "section_title": "Methods", "content": "uvm_default_report_server"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "get_mem_by_name uvm_reg_block"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "get_mem_by_offset uvm_reg_map"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "get_memories uvm_reg_block"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_mem_mam uvm_mem_region uvm_vreg"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "get_message_database"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_field uvm_vreg_field"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_map uvm_vreg"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_vreg"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "get_n_memlocs uvm_vreg"}
{"type": "text", "page_from": 890, "page_to": 890, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=890", "section_title": "Methods", "content": "uvm_mem uvm_object uvm_port_base#(IF) uvm_reg uvm_reg_block uvm_reg_field uvm_reg_file uvm_reg_map uvm_report_message_element_base uvm_tlm_time uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_name_constraint uvm_component_name_check_visitor get_next uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_next_child uvm_component get_next_item uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_num_children uvm_component get_num_extensions uvm_tlm_generic_payload get_num_last_reqs uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_num_last_rspsuvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_num_reqs_sent uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_num_rsps_received uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_num_waiters uvm_barrier uvm_event_base get_object_type uvm_object"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_objection uvm_phase get_objection_count uvm_objection uvm_phase"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_objection_total uvm_objection"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_objectors uvm_objection"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_offset_in_memory uvm_vreg"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_open_time uvm_recorder"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "get_packed_size uvm_packer"}
{"type": "text", "page_from": 891, "page_to": 891, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=891", "section_title": "Methods", "content": "uvm_component uvm_mem uvm_phase uvm_port_base#(IF) uvm_reg uvm_reg_block uvm_reg_field"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "uvm_reg_file uvm_reg_map uvm_vreg uvm_vreg_field get_parent_map uvm_reg_map get_parent_sequence uvm_sequence_item get_phase_type uvm_phase"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_physical_addresses uvm_reg_map"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_plusargs uvm_cmdline_processor get_port uvm_port_component#(PORT)"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_prev uvm_callbacks#(T,CB)"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_prev_state uvm_phase_state_change get_priority uvm_sequence_base get_propagate_mode uvm_objection"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_provided_to uvm_port_component_base get_quit_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_radix_str uvm_printer_knobs get_record_attribute_handle uvm_recorder"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_recorder_from_handle uvm_recorder"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_recorders uvm_tr_stream get_reg_by_name uvm_reg_block get_reg_by_offset uvm_reg_map"}
{"type": "text", "page_from": 892, "page_to": 892, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=892", "section_title": "Methods", "content": "get_regfile uvm_reg uvm_reg_file get_region uvm_vreg get_registers uvm_reg_block uvm_reg_map get_report_action uvm_report_object get_report_catcher uvm_report_catcher get_report_file_handle uvm_report_object"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "uvm_report_message uvm_report_object"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_report_max_verbosity_level uvm_report_object"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_report_object uvm_report_message"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "uvm_coreservice_t uvm_default_coreservice_t uvm_report_message"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_report_verbosity_level uvm_report_object"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_reset uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_response uvm_sequence#(REQ,RSP)"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_response_queue_depth uvm_sequence_base"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_response_queue_error_report_disabled uvm_sequence_base"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_response_status uvm_tlm_generic_payload"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_response_string uvm_tlm_generic_payload"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_rhs uvm_link_base"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_vreg"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_root uvm_coreservice_t"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_root_blocks uvm_reg_block"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_root_map uvm_reg_map"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_root_sequence uvm_sequence_item"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_root_sequence_name uvm_sequence_item"}
{"type": "text", "page_from": 893, "page_to": 893, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=893", "section_title": "Methods", "content": "get_run_count uvm_phase"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_schedule_name uvm_phase"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "uvm_resource_base uvm_tr_stream"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_sequence_id uvm_sequence_item"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_sequence_path uvm_sequence_item"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_sequence_state uvm_sequence_base"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_sequencer uvm_reg_map uvm_sequence_item"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_sequencesuvm_sequence_library"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_server uvm_report_server"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_severity_set uvm_report_server"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_size uvm_mem uvm_vreg"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_start_offset uvm_mem_region"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_starting_phase uvm_sequence_base"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_state uvm_phase uvm_phase_state_change"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_stream uvm_recorder"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_stream_from_handle uvm_tr_stream"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_stream_type_name uvm_tr_stream"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_streaming_width uvm_tlm_generic_payload"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_streams uvm_tr_database"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_submap_offset uvm_reg_map"}
{"type": "text", "page_from": 894, "page_to": 894, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=894", "section_title": "Methods", "content": "get_submaps uvm_reg_map"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_threshold uvm_barrier"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_tool_name uvm_cmdline_processor"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_tool_version uvm_cmdline_processor"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "uvm_sequence_base uvm_transaction"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_tr_stream uvm_component"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_transaction_id uvm_transaction"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_transaction_order_policy uvm_reg_map"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_trigger_data uvm_event#(T)"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_trigger_time uvm_event_base"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_type uvm_object uvm_resource#(T)"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "uvm_resource#(T) uvm_resource_base uvm_tlm_extension_base"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_type_handle_name uvm_tlm_extension_base"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "uvm_callback uvm_component_registry#(T,Tname) uvm_object uvm_object_registry#(T,Tname) uvm_object_string_pool#(T) uvm_object_wrapper uvm_port_base#(IF) uvm_sequence_library"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_use_response_handler uvm_sequence_base"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_use_sequence_info uvm_sequence_item"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_uvm_domain uvm_domain"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_uvm_schedule uvm_domain"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "get_uvmargs uvm_cmdline_processor"}
{"type": "text", "page_from": 895, "page_to": 895, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=895", "section_title": "Methods", "content": "uvm_report_message_int_element uvm_report_message_object_element uvm_report_message_string_element"}
{"type": "text", "page_from": 896, "page_to": 896, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=896", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message get_vfield_by_name uvm_mem uvm_reg_block"}
{"type": "text", "page_from": 896, "page_to": 896, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=896", "section_title": "Methods", "content": "get_virtual_fields uvm_mem uvm_reg_block uvm_reg_map get_virtual_registers uvm_mem uvm_mem_region uvm_reg_block uvm_reg_map"}
{"type": "text", "page_from": 896, "page_to": 896, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=896", "section_title": "Methods", "content": "get_vreg_by_name uvm_mem uvm_reg_block"}
{"type": "text", "page_from": 896, "page_to": 896, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=896", "section_title": "Methods", "content": "get_vreg_by_offset uvm_mem"}
{"type": "text", "page_from": 896, "page_to": 896, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=896", "section_title": "Methods", "content": "grab uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 897, "page_to": 897, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=897", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 897, "page_to": 897, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=897", "section_title": "Methods", "content": "uvm_sequencer#(REQ,RSP) uvm_sequencer_base uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 897, "page_to": 897, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=897", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 897, "page_to": 897, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=897", "section_title": "Methods", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 897, "page_to": 897, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=897", "section_title": "Methods", "content": "uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 897, "page_to": 897, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=897", "section_title": "Methods", "content": "ID uvm_tlm_extension implement uvm_vreg include coverage uvm_reg incr uvm_tlm_time incr_id_count uvm_default_report_server incr_quit_count uvm_default_report_server incr severity count uvm_default_report_server init_access record uvm_resource_base init_sequence_library uvm_sequence_library"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_active uvm_transaction"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_auditing uvm_resource_options"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_auto_item_recording_enableduvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_auto_updated uvm_reg_backdoor"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_child uvm_sequencer_base"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "uvm_recorder uvm_tr_stream"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_dmi_allowed uvm_tlm_generic_payload"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_empty uvm_tlm_fifo#(T)"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_enabled uvm_callback"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "uvm_port_base#(IF) uvm_port_component_base"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_grabbed uvm_sequencer_base"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_hdl_path_root uvm_reg_block"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_imp uvm_port_base#(IF) uvm_port_component_base"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_vreg"}
{"type": "text", "page_from": 898, "page_to": 898, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=898", "section_title": "Methods", "content": "is_indv_accessible uvm_reg_field"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "uvm_sequence_base uvm_sequence_item"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_known_access uvm_reg_field"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "uvm_reg_block uvm_simple_lock_dap"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_off uvm_event_base"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_on uvm_event_base"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "uvm_recorder uvm_tr_database uvm_tr_stream"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "uvm_port_base#(IF) uvm_port_component_base"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_quit_count_reached uvm_default_report_server"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_read uvm_tlm_generic_payload"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_read_only uvm_resource_base"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_recording_enabled uvm_transaction"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_response_error uvm_tlm_generic_payload"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "is_response_ok uvm_tlm_generic_payload"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "uvm_config_db_options uvm_resource_db_options"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 899, "page_to": 899, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=899", "section_title": "Methods", "content": "uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 900, "page_to": 900, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=900", "section_title": "Methods", "content": "uvm_domain uvm_phase"}
{"type": "text", "page_from": 900, "page_to": 900, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=900", "section_title": "Methods", "content": "uvm_phase_state_change"}
{"type": "text", "page_from": 900, "page_to": 900, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=900", "section_title": "Methods", "content": "uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 900, "page_to": 900, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=900", "section_title": "Methods", "content": "last_req uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 900, "page_to": 900, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=900", "section_title": "Methods", "content": "last_rspuvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 900, "page_to": 900, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=900", "section_title": "Methods", "content": "lock uvm_sequence_base uvm_sequencer_base uvm_simple_lock_dap lock_model uvm_reg_block lookup uvm_component lookup_name uvm_resource_pool lookup_regex uvm_resource_pool lookup_regex_names uvm_resource_pool lookup_scope uvm_resource_pool lookup_type uvm_resource_pool"}
{"type": "text", "page_from": 900, "page_to": 900, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=900", "section_title": "Methods", "content": "main_phase uvm_component match scope"}
{"type": "text", "page_from": 901, "page_to": 901, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=901", "section_title": "Methods", "content": "uvm_resource_base max_size uvm_port_base#(IF) mid_do uvm_sequence_base min_size uvm_port_base#(IF) mirror uvm _reg uvm_reg_block uvm_reg_field uvm_reg_fifo mirror_reg uvm_reg_sequence"}
{"type": "text", "page_from": 901, "page_to": 901, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=901", "section_title": "Methods", "content": "nb_transport_bw uvm_tlm_if"}
{"type": "text", "page_from": 901, "page_to": 901, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=901", "section_title": "Methods", "content": "nb_transport_fw uvm_tlm_if"}
{"type": "text", "page_from": 901, "page_to": 901, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=901", "section_title": "Methods", "content": "uvm_reg uvm_reg_block uvm_reg_field"}
{"type": "text", "page_from": 901, "page_to": 901, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=901", "section_title": "Methods", "content": "uvm_\\*_export#(REQ,RSP) uvm _\\* export#(T) uvm_\\*_imp#(REQ,RSP,IMP,REQ_IMP,RSP_IMP) uvm_\\*_imp#(T,IMP) uvm \\* port#(REQ,RSP) uvm \\* _port#(T) uvm_agent uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_analysis_export uvm _barrier uvm_bottomup_phase uvm_built_in_pair#(T1,T2) uvm_callback uvm_callback_iter uvm_cause_effect_link uvm_class_pair#(T1,T2) uvm_component uvm_default_report_server uvm_domain uvm_driver#(REQ,RSP) uvm_env uvm_event#(T) uvm_event_base uvm_event_callback uvm_get_to_lock_dap uvm_link_base uvm_mem uvm_mem_mam uvm_mem_single_walk_seq uvm_monitor uvm_object uvm_object_string_pool#(T) uvm_objection uvm_parent_child_link uvm_phase uvm_phase_cb uvm_pool#(KEY,T) uvm_port_base#(IF) uvm_push_driver#(REQ,RSP) uvm_push_sequencer#(REQ,RSP) uvm_queue#(T) uvm_random_stimulus#(T) uvm_reg uvm_reg_adapter uvm_reg_backdoor uvm_reg_block uvm_reg_field uvm_reg_fifo uvm_reg_file uvm_reg_frontdoor uvm_reg_indirect_data uvm_reg_item uvm_reg_map uvm_reg_predictor uvm_reg_sequence uvm_related_link uvm_report_catcher uvm_report_handler uvm_report_message uvm_report_message_element_container uvm_report_object uvm_resource_base uvm_scoreboard uvm_seq_item_pull_imp#(REQ,RSP,IMP) uvm_sequence#(REQ,RSP) uvm_sequence_base uvm_sequence_item uvm_sequence_library uvm_sequencer#(REQ,RSP) uvm_sequencer_base uvm_sequencer_param_base#(REQ,RSP) uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap uvm_subscriber uvm_task_phase uvm_test uvm_text_recorder uvm_text_tr_database uvm_text_tr_stream uvm_tlm_analysis_fifo#(T) uvm_tlm_b_initiator_socket uvm_tlm_b_target_socket uvm_tlm_extension uvm_tlm_extension_base uvm_tlm_fifo#(T) uvm_tlm_fifo_base#(T) uvm_tlm_generic_payload uvm_tlm_nb_initiator_socket uvm_tlm_nb_target_socket uvm _tlm_nb_transport_bw_export uvm _tlm_nb_transport_bw_port uvm _tlm_req_rsp_channel#(REQ,RSP) uvm _tlm _time uvm_tlm_transport_channel#(REQ,RSP) uvm_topdown_phase uvm_tr_database uvm_tr_stream uvm_transaction uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 903, "page_to": 903, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=903", "section_title": "Methods", "content": "new_report_message uvm_report_message"}
{"type": "text", "page_from": 903, "page_to": 903, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=903", "section_title": "Methods", "content": "uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 903, "page_to": 903, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=903", "section_title": "Methods", "content": "open_db uvm_tr_database open_recorder uvm_tr_stream open_stream uvm_tr_database order uvm_reg_transaction_order_policy"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_bits uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_bytes uvm _object uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_field uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_field_int uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_ints uvm_object uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_object uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_real uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_string uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "pack_time uvm_packer"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_field uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP) uvm_tlm_if_base#(T1,T2) uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "peek_reg uvm_reg_sequence"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "phase_ended uvm_component"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "phase_ready_to_end uvm_component"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "phase_started uvm_component"}
{"type": "text", "page_from": 904, "page_to": 904, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=904", "section_title": "Methods", "content": "phase_state_change uvm_phase_cb"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_field uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "poke_mem uvm_reg_sequence poke_reg uvm_reg_sequence pop_back uvm_queue#(T)"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "pop_front uvm_queue#(T)"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "post_body uvm_sequence_base post_configure_phase uvm_component"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "post_do uvm_sequence_base post_main_phase uvm_component post_predict uvm_reg_cbs post_randomize uvm_tlm_generic_payload"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "post_reset_phase uvm_component post_shutdown_phase uvm_component"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "post_start uvm_sequence_base post_trigger uvm_event_callback"}
{"type": "text", "page_from": 905, "page_to": 905, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=905", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_vreg uvm_vreg_cbs uvm_vreg_field"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "pre_configure_phase uvm_component"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "pre_do uvm_sequence_base"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "pre_main_phase uvm_component"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "pre_predict uvm_reg_predictor"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "pre_randomize uvm_tlm_generic_payload"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_reg_fifo uvm_reg_write_only_cbs uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "pre_reset_phase uvm_component pre_shutdown_phase uvm_component"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "pre_start uvm_sequence_base pre_trigger uvm_event_callback"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_backdoor uvm_reg_cbs uvm_reg_field uvm_reg_fifo uvm_reg_read_only_cbs uvm_vreg uvm_vreg_cbs uvm_vreg_field uvm_vreg_field_cbs"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 906, "page_to": 906, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=906", "section_title": "Methods", "content": "uvm_callback_iter uvm_pool#(KEY,T)"}
{"type": "text", "page_from": 907, "page_to": 907, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=907", "section_title": "Methods", "content": "uvm_default_report_serve uvm_factory uvm_object uvm_report_handler uvm_report_message print_accessors uvm_resource_base print_array_footer uvm_printer print_array_header uvm_printer print_array_range uvm_printer print_catcher uvm_report_catcher print_config uvm_component print_config_settings uvm_component print_config_with_audit uvm_component print_field uvm_printer print_field_int uvm_printer print_generic uvm_printer print_msg uvm_comparer print_object uvm_printer print_override_info uvm_component print_real uvm_printer print_resources uvm_resource_pool print_string uvm_printer print_time uvm_printer print_topology uvm_root process_report_message uvm_report_handler push_back uvm_queue#(T) push_front uvm_queue#(T) put"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP) uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "uvm_objection uvm_phase"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "uvm_component uvm_objection uvm_objection_callback"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "uvm_mem uvm_mem_region uvm_reg uvm_reg_backdoor uvm_reg_field uvm_reg_fifo uvm_resource#(T) uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "read_by_name uvm_resource_db read_by_type uvm_resource_db read_func uvm_reg_backdoor read_mem uvm_reg_sequence read_mem_by_name uvm_reg_block"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "read_reg uvm_reg_sequence read_reg_by_name uvm_reg_block"}
{"type": "text", "page_from": 908, "page_to": 908, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=908", "section_title": "Methods", "content": "reconfigure uvm_mem_mam record uvm_object record_error_tr uvm_component record_event_tr uvm_component record_field uvm_recorder record_field_int uvm_recorder record_field_real uvm_recorder record_generic uvm_recorder record_object uvm_recorder record_read_access uvm_resource_base record_string uvm_recorder record_time uvm_recorder record_write_access uvm_resource_base"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "uvm_reg_adapter uvm_reg_tlm_adapter"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "release_all_regions uvm_mem_mam"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "uvm_mem_mam uvm_mem_region uvm_vreg"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "uvm_heartbeat uvm_reg_read_only_cbs uvm_reg_write_only_cbs"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "remove_sequence uvm_sequence_library"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "report_phase uvm_component"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "report_summarize uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "reserve_region uvm_mem_mam"}
{"type": "text", "page_from": 909, "page_to": 909, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=909", "section_title": "Methods", "content": "uvm_barrier uvm_event_base uvm_reg uvm_reg_block uvm_reg_field uvm_reg_map uvm_tlm_time uvm_vreg"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_hw_reset_seq uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "reset_quit_count uvm_default_report_server"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "reset_report_handler uvm_report_object"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "reset_severity_counts uvm_default_report_server"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "resolve_bindings uvm_component uvm_port_base#(IF)"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "response_handler uvm_sequence_base"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "resume uvm_component"}
{"type": "text", "page_from": 910, "page_to": 910, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=910", "section_title": "Methods", "content": "run_phase uvm_component uvm_push_sequencer#(REQ,RSP)"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "select_sequence uvm_sequence_library"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "uvm_sequence#(REQ,RSP) uvm_sequence_base uvm_sequencer_base uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "uvm_config_db uvm_get_to_lock_dap uvm_hdl_path_concat uvm_link_base uvm_reg uvm_reg_field uvm_reg_fifo uvm_resource#(T) uvm_resource_db uvm_resource_pool uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "uvm_resource#(T) uvm_resource_base"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "set_access uvm_reg_field"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message uvm_report_message_element_base"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 911, "page_to": 911, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=911", "section_title": "Methods", "content": "set_anonymous uvm_resource_db"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_auto_reset uvm_barrier"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_automatic_phase_objection uvm_sequence_base"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_base_addr uvm_reg_map"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_byte_enable uvm_tlm_generic_payload"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_byte_enable_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_check_on_read uvm_reg_map"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_command uvm_tlm_generic_payload"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_compare uvm_reg_field uvm_reg_fifo"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_component_visitor"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "uvm_mem uvm_reg uvm_reg_block"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_data uvm_tlm_generic_payload"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_data_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_default uvm_resource_db"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_default_hdl_path uvm_reg_block uvm_reg_file"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_default_index uvm_port_base#(IF)"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_default_map uvm_reg_block"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_default_tr_database"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 912, "page_to": 912, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=912", "section_title": "Methods", "content": "set_dmi_allowed uvm_tlm_generic_payload"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_drain_time uvm_objection"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_extension uvm_tlm_generic_payload"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "uvm_coreservice_t uvm_default_coreservice_t"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_file uvm_report_message"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_file_name uvm_text_tr_database"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_filename uvm_report_message"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_hdl_path_root uvm_reg_block"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_heartbeat uvm_heartbeat"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_id uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_id_info uvm_sequence_item"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "uvm_component uvm_component_registry#(T,Tname) uvm_object_registry#(T,Tname)"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_inst_override_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_inst_override_by_type"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "uvm_component uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_int_local uvm_object"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_item_context uvm_sequence_item"}
{"type": "text", "page_from": 913, "page_to": 913, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=913", "section_title": "Methods", "content": "set_jump_phase uvm_phase"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_max_zero_time_wait_relevant_count uvm_sequencer_base"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_message_database"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_mode uvm_heartbeat"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "uvm_object uvm_report_message_element_base"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_name_override uvm_resource_pool"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_num_last_reqs uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_num_last_rsps uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_object_local uvm_object"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "uvm_resource#(T) uvm_resource_pool"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_parent_sequence uvm_sequence_item"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_phase_imp uvm_component"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_priority uvm_resource_pool uvm_sequence_base"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_priority_name uvm_resource_pool"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_priority_type uvm_resource_pool"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_propagate_mode uvm_objection"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_quit_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_read uvm_tlm_generic_payload"}
{"type": "text", "page_from": 914, "page_to": 914, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=914", "section_title": "Methods", "content": "set_read_only uvm_resource_base"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_default_file uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_default_file_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_handler uvm_report_message uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_id_action uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_id_action_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_id_file uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_id_file_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_id_verbosity uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_id_verbosity_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_message uvm_report_message"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_object uvm_report_message"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "uvm_coreservice_t uvm_default_coreservice_t uvm_report_message"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_action uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_action_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_file uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_file_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_id_action uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_id_action_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_id_file uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_id_file_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_id_override uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_id_verbosity uvm_report_object"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_id_verbosity_hier uvm_component"}
{"type": "text", "page_from": 915, "page_to": 915, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=915", "section_title": "Methods", "content": "set_report_severity_override uvm_report_object"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_report_verbosity_level uvm_report_object"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_report_verbosity_level_hier uvm_component"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "uvm_reg uvm_reg_field"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_response_queue_depth uvm_sequence_base"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_response_queue_error_report_disabled uvm_sequence_base"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_response_status uvm_tlm_generic_payload"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_rhs uvm_link_base"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_scope uvm_resource_base"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_sequencer uvm_reg_map uvm_sequence_item"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_server uvm_report_server"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_severity_count uvm_default_report_server uvm_report_server"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_starting_phase uvm_sequence_base"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_streaming_width uvm_tlm_generic_payload"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_string_local uvm_object"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_submap_offset uvm_reg_map"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_threshold uvm_barrier"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_time_resolution uvm_tlm_time"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_timeout uvm_root"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_transaction_id uvm_transaction"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "set_transaction_order_policy uvm_reg_map"}
{"type": "text", "page_from": 916, "page_to": 916, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=916", "section_title": "Methods", "content": "uvm_component uvm_component_registry#(T,Tname) uvm_object_registry#(T,Tname) uvm_resource_pool"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "set_type_override_by_name uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "set_type_override_by_type"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "uvm_component uvm_default_factory uvm_factory"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "set_use_sequence_info uvm_sequence_item"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "uvm_report_message_int_element uvm_report_message_object_element uvm_report_message_string_element"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "uvm_report_catcher uvm_report_message set_volatility uvm_reg_field set_write uvm_tlm_generic_payload shutdown_phase uvm_component"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "size uvm_port_base#(IF) uvm_queue#(T) uvm_reg_fifo uvm_report_message_element_container uvm_tlm_fifo#(T)"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "sort_by_precedence uvm_resource_pool spell_check uvm_resource_pool sprint uvm_object"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "uvm_heartbeat uvm_sequence_base"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "start_item uvm_sequence_base"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "start_of_simulation_phase uvm_component"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "start_phase_sequence uvm_sequencer_base"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "stop_phase_sequence uvm_sequencer_base"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "uvm_sequencer#(REQ,RSP) uvm_sequencer_base"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "stop_stimulus_generation"}
{"type": "text", "page_from": 917, "page_to": 917, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=917", "section_title": "Methods", "content": "uvm_random_stimulus#(T)"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "trace_mode uvm_objection"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_bottomup_phase uvm_task_phase uvm_topdown_phase"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_get_to_lock_dap uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_sequencer#(REQ,RSP) uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "try_put uvm_tlm_if_base#(T1,T2)"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_get_to_lock_dap uvm_set_before_get_dap uvm_set_get_dap_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "turn_off_auditing uvm_resource_options"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_config_db_options uvm_resource_db_options"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "turn_on_auditing uvm_resource_options"}
{"type": "text", "page_from": 918, "page_to": 918, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=918", "section_title": "Methods", "content": "uvm_config_db_options uvm_resource_db_options"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "uvm_sequence_base uvm_sequencer_base uvm_simple_lock_dap"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_bits uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_bytes uvm _object uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_field uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_field_int uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_ints uvm _object uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_object uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_real uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_string uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "unpack_time uvm_packer"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "uvm_reg uvm_reg_block uvm_reg_fifo"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "update_reg uvm_reg_sequence"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "use_record_attribute uvm_recorder"}
{"type": "text", "page_from": 919, "page_to": 919, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=919", "section_title": "Methods", "content": "use_response_handler uvm_sequence_base"}
{"type": "text", "page_from": 920, "page_to": 920, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=920", "section_title": "Methods", "content": "user_priority_arbitration uvm_sequencer_base"}
{"type": "text", "page_from": 920, "page_to": 920, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=920", "section_title": "Methods", "content": "uvm_bits_to_string uvm_get_report_object Global uvm_report_object"}
{"type": "text", "page_from": 920, "page_to": 920, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=920", "section_title": "Methods", "content": "uvm_hdl_check_path uvm_hdl_deposit uvm_hdl_force uvm _hdl_force_time uvm hdl_read uvm _hdl_release uvm hdl_release_and_read uvm _is_match uvm_process_report_message Global uvm_report_object"}
{"type": "text", "page_from": 920, "page_to": 920, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=920", "section_title": "Methods", "content": "Global uvm_report_catcher uvm_report_object uvm_sequence_item uvm_report_enabled Global uvm_report_object uvm_report_error Global uvm_report_catcher uvm_report_object uvm_sequence_item"}
{"type": "text", "page_from": 920, "page_to": 920, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=920", "section_title": "Methods", "content": "Global uvm_report_catcher uvm_report_object uvm_sequence_item"}
{"type": "text", "page_from": 920, "page_to": 920, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=920", "section_title": "Methods", "content": "Global uvm_report_catcher uvm_report_object uvm_sequence_item"}
{"type": "text", "page_from": 920, "page_to": 920, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=920", "section_title": "Methods", "content": "Global uvm_report_catcher uvm_report_object uvm_sequence_item uvm_split_string uvm_string_to_bits uvm_wait_for_nba_region"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "uvm_barrier uvm_objection"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_for_change uvm_reg_backdoor"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_for_grant uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "uvm_sequence_base uvm_sequencer_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_for_relevant uvm_sequence_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_for_sequence_state uvm_sequence_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "uvm_sequencer#(REQ,RSP) uvm_sequencer_base uvm_sqr_if_base#(REQ,RSP)"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_for_state uvm_phase"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "uvm_config_db uvm_resource_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_off uvm_event_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_on uvm_event_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_ptrigger uvm_event_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_ptrigger_data uvm_event#(T)"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_trigger uvm_event_base"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "wait_trigger_data uvm_event#(T)"}
{"type": "text", "page_from": 921, "page_to": 921, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=921", "section_title": "Methods", "content": "uvm_analysis_port uvm_mem uvm_mem_region uvm _reg uvm _reg_backdoor uvm_reg_field uvm_reg_fifo uvm _resource#(T) uvm_subscriber uvm_tlm_if_base#(T1,T2) uvm_vreg uvm_vreg_field"}
{"type": "text", "page_from": 922, "page_to": 922, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=922", "section_title": "Methods", "content": "write_attribute uvm_text_recorder write_attribute_int uvm_text_recorder write_by_name uvm_resource_db write_by_type uvm_resource_db write_mem uvm_reg_sequence write_mem_by_name uvm_reg_block"}
{"type": "text", "page_from": 922, "page_to": 922, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=922", "section_title": "Methods", "content": "write_reg uvm_reg_sequence write_reg_by_name uvm_reg_block"}
{"type": "text", "page_from": 923, "page_to": 923, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=923", "section_title": "Types", "content": "uvm_access_e uvm_action uvm_active_passive_enum uvm_bitstream_t uvm_check_e uvm_coverage_model_e uvm_elem_kind_e uvm_endianness_e uvm_hdl_path_slice uvm_hier_e uvm_integral_t uvm_mem_cb uvm_mem_cb_iter uvm_objection_event uvm_path_e uvm_phase_state uvm_phase_type uvm_port_type_e uvm_predict_e uvm_radix_enum uvm_recursion_policy_enum uvm_reg_addr_logic_t uvm_reg_addr_t uvm_reg_bd_cb uvm_reg_bd_cb_iter uvm_reg_byte_en_t uvm_reg_cb uvm_reg_cb_iter uvm_reg_cvr_t uvm_reg_data_logic_t uvm_reg_data_t uvm_reg_field_cb uvm_reg_field_cb_iter uvm_reg_mem_tests_e uvm_sequence_lib_mode uvm sequence_state_enum uvm sequencer_arb_mode uvm _severity uvm _status_e uvm tlm command_e uvm tlm phase_e uvm tlm response_status_e uvm _tlm sync_ e uvm _verbosity uvm _vreg cb uvm _vreg _cbs uvm _vreg cb _iter uvm _vreg_cbs uvm _vreg _field cb uvm _vreg _field cbs uvm _vreg _field cb _iter uvm _vreg _field_cbs uvm wait op"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_CONFIG_DB_TRACE uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_DUMP_CMDLINE_ARGS uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_MAX_QUIT_COUNT uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_OBJECTION_TRACE uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_PHASE_TRACE uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_RESOURCE_DB_TRACE uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_action uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_config_int uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_config_string uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_default_sequence uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_inst_override uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_severity uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_type_override uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+uvm_set_verbosity uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_TESTNAME uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_TIMEOUT uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "+UVM_VERBOSITY uvm_cmdline_processor"}
{"type": "text", "page_from": 925, "page_to": 925, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=925", "section_title": "Variables", "content": "uvm_comparer uvm_packer uvm_recorder"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "uvm_reg_mem_hdl_paths_seq"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "uvm_reg_predictor uvm_reg_sequence"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "begin_elements uvm_printer_knobs"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "begin_event uvm_transaction"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "big_endian uvm_packer"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "bin_radix uvm_printer_knobs"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "body uvm_reg_hw_reset_seq"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "bus_in uvm_reg_predictor"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "byte_en uvm_reg_bus_op"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "default_alloc uvm_mem_mam"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "default_path uvm_reg_block"}
{"type": "text", "page_from": 926, "page_to": 926, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=926", "section_title": "Variables", "content": "default_precedence uvm_resource_base"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "uvm_printer_knobs uvm_recorder"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "do_not_randomize uvm_sequence_base"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "element_kind uvm_reg_item"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "enable_print_topology uvm_root"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "enable_report_id_count_summary uvm_default_report_server"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "end_elements uvm_printer_knobs"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "end_event uvm_transaction"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "end_offset uvm_mem_mam_cfg"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "events uvm_transaction"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "finish_on_completion uvm_root"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "footer uvm_printer_knobs"}
{"type": "text", "page_from": 927, "page_to": 927, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=927", "section_title": "Variables", "content": "full_name uvm_printer_knobs"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "uvm_printer_knobs hex_radix uvm_printer_knobs"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "uvm_printer_knobs uvm_recorder"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "in_use uvm_mem_mam_policy"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "uvm_reg_bus_op uvm_reg_item"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "local_map uvm_reg_item"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "m_address uvm_tlm_generic_payload"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "m_byte_enable uvm_tlm_generic_payload"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "m_byte_enable_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 928, "page_to": 928, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=928", "section_title": "Variables", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "uvm_tlm_generic_payload"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "m_dmi uvm_tlm_generic_payload"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "m_length uvm_tlm_generic_payload"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "m_response_status uvm_tlm_generic_payload"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "m_streaming_width uvm_tlm_generic_payload"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "map uvm_reg_item uvm_reg_predictor"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "max_random_count uvm_sequence_library"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "uvm_printer_knobs mem uvm_mem_shared_access_seq uvm_mem_single_access_seq uvm_mem_single_walk_seq"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "min_random_count uvm_sequence_library"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "miscompares uvm_comparer"}
{"type": "text", "page_from": 929, "page_to": 929, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=929", "section_title": "Variables", "content": "uvm_mem_access_seq uvm_mem_walk_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_hw_reset_seq uvm_reg_mem_built_in_seq uvm_reg_mem_shared_access_seq uvm_reg_sequence"}
{"type": "text", "page_from": 930, "page_to": 930, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=930", "section_title": "Variables", "content": "n_bytes uvm_mem_mam_cfg"}
{"type": "text", "page_from": 930, "page_to": 930, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=930", "section_title": "Variables", "content": "uvm_line_printer uvm_table_printer uvm_tree_printer"}
{"type": "text", "page_from": 930, "page_to": 930, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=930", "section_title": "Variables", "content": "oct_radix uvm_printer_knobs"}
{"type": "text", "page_from": 930, "page_to": 930, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=930", "section_title": "Variables", "content": "uvm_reg_item parent_sequence uvm_reg_adapter path uvm_reg_item physical uvm _comparer uvm_packer uvm_recorder policy uvm_comparer precedence uvm_resource_base prefix uvm_printer_knobs print_config_matches uvm_component"}
{"type": "text", "page_from": 930, "page_to": 930, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=930", "section_title": "Variables", "content": "print_enabled uvm_component prior uvm_reg_item provides_responses uvm_reg_adapter"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "uvm_recorder reference uvm_printer_knobs reg_ap uvm_reg_predictor reg_seq uvm_reg_access_seq uvm_reg_bit_bash_seq uvm_reg_mem_shared_access_seq"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "uvm_reg_sequence req uvm_sequence#(REQ,RSP)"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "result uvm_comparer rg uvm_reg_shared_access_seq uvm_reg_single_access_seq uvm_reg_single_bit_bash_seq rsp uvm_sequence#(REQ,RSP)"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "uvm_sequence_library"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "uvm_sequence_library"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "uvm_sequence_library"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "separator uvm_printer_knobs"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "seq_item_exportuvm_sequencer#(REQ,RSP)"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "sequence_count uvm_sequence_library"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "sequencer uvm_reg_frontdoor"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "uvm_sequence_library"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "show_max uvm_comparer"}
{"type": "text", "page_from": 931, "page_to": 931, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=931", "section_title": "Variables", "content": "show_radix uvm_printer_knobs"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "show_terminator uvm_default_report_server"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "show_verbosity uvm_default_report_server"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "size uvm_printer_knobs"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "slices uvm_hdl_path_concat"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "start_offset uvm_mem_mam_policy"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "uvm_reg_bus_op uvm_reg_item"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "supports_byte_enable uvm_reg_adapter"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "T1 firstuvm_built_in_pair#(T1,T2)uvm_class_pair#(T1,T2)"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "uvm_built_in_pair#(T1,T2)uvm_class_pair#(T1,T2)"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "uvm_reg_mem_built_in_seq"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "uvm_printer_knobs use_metadata uvm_packer use_uvm_seeding uvm_object"}
{"type": "text", "page_from": 932, "page_to": 932, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=932", "section_title": "Variables", "content": "uvm_default_comparer uvm_default_line_printer uvm_default_packer uvm_default_printer uvm_default_table_printer uvm_default_tree_printer"}
{"type": "text", "page_from": 933, "page_to": 933, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=933", "section_title": "Variables", "content": "UVM_HDL_MAX_WIDTH uvm_top uvm_root"}
{"type": "text", "page_from": 933, "page_to": 933, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=933", "section_title": "Variables", "content": "uvm_reg_field uvm_reg_item"}
{"type": "text", "page_from": 933, "page_to": 933, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=933", "section_title": "Variables", "content": "verbosity uvm_comparer"}
{"type": "text", "page_from": 936, "page_to": 936, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=936", "section_title": "Constants", "content": "UVM_REFERENCE UVM_REG UVM_RM_RECORD UVM_SEQ_ARB_FIFO UVM_SEQ_ARB_RANDOM UVM_SEQ_ARB_STRICT_FIFO UVM_SEQ_ARB_STRICT_RANDOM UVM_SEQ_ARB_USER UVM_SEQ_ARB_WEIGHTED UVM_SEQ_LIB_ITEM UVM_SEQ_LIB_RAND UVM_SEQ_LIB_RANDC UVM_SEQ_LIB_USER UVM_SHALLOW UVM_STOP UVM_STOPPED UVM_STRING UVM _TIME UVM _TLM_ACCEPTED UVM_TLM_ADDRESS_ERROR_RESPONSE UVM_TLM_BURST_ERROR_RESPONSE UVM_TLM_BYTE_ENABLE_ERROR_RESPONSE UVM_TLM_COMMAND_ERROR_RESPONSE UVM_TLM_COMPLETED UVM_TLM_GENERIC_ERROR_RESPONSE UVM_TLM_IGNORE_COMMAND UVM_TLM_INCOMPLETE_RESPONSE UVM_TLM_OK_RESPONSE UVM_TLM_READ_COMMAND UVM_TLM_UPDATED UVM_TLM_WRITE_COMMAND UVM_UNFORMAT2 UVM_UNFORMAT4 UVM_UNSIGNED UVM_WARNING UVM_WRITE"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_in_order_comparator#(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "analysis_export uvm_subscriber"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "uvm_tlm_analysis_fifo#(T)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "uvm_algorithmic_comparator#(BEFORE,AFTER,TRANSFORMER) uvm_in_order_comparator#(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "uvm_random_stimulus#(T)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "uvm_tlm_fifo_base#(T)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "get_peek_export uvm_tlm_fifo_base#(T)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "get_peek_request_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "get_peek_response_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 937, "page_to": 937, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=937", "section_title": "Ports", "content": "uvm_in_order_comparator#(T,comp_type,convert,pair_type)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "uvm_tlm_fifo_base#(T) put_export uvm_tlm_fifo_base#(T) put_request_export uvm_tlm_req_rsp_channel#(REQ,RSP) put_response_export uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "uvm_push_driver#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "uvm_push_sequencer#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "request_ap uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "response_ap uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "rsp_export uvm_sequencer_param_base#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "uvm_driver#(REQ,RSP) uvm_push_driver#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "uvm_driver#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "uvm_tlm_req_rsp_channel#(REQ,RSP)"}
{"type": "text", "page_from": 938, "page_to": 938, "std": "UVM-1.2", "uri": "/pdf/UVM_Class_Reference_Manual_1.2.pdf", "anchor": "#page=938", "section_title": "Ports", "content": "transport_export uvm_tlm_transport_channel#(REQ,RSP)"}
